<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VHDL] Verilog Hardware Description Language | Rain Hu's Workspace</title><meta name=keywords content="VHDL,Programming,Verilog,Logic Design"><meta name=description content="1 Verilog HDL
1.1 Verilog 簡介

一套硬體描述語言

輔助設計數位系統
描述電路的行為
電子自動化工具


類似C語言的硬體描述語言

易學、容易接受
高階行為描述
切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的)


支援多種硬體層級的描述方式

從低階到高階模式
依照不同的方法設計


支援階層式的設計方法

樹狀式的設計結構
由繁化簡



1.2 Verilog 的模型
1.2.1 電晶體層級

Transistor Level
或低階交換層次模型(Switch Level Model)
Verilog 最低階的層次模型
電路是由開關與電晶體所組成
一般不會採取低階的層級來進行設計

1.2.2 邏輯閘層級

Gate Level
使用基本的邏輯閘元件
AND、OR、NOT
邏輯電路圖

1.2.3 資料流層級

Data Flow Level
描述電路中資料的處理方式
資料如何在電路中運算及傳送
輸入持續驅動輸出
運算式

如：out = a + b + c



1.2.4 行為模型

Behavior Level
Verilog 最高階的層次模型
不需考慮硬體元件的特型，只需放在模組的功能描述
很像 C 語言
合成軟體工具

1.2.5 結構式模型

Structure Level
引用硬體模組的模式
類似邏輯閘層次模型
支援階層式設計法

將複雜電路分為層狀結構
架構上類似樹狀結構

Bottom-up：元件→子模組→設計目標
Top-Down：設計目標→子模組→元件
Mixed：設計目標→子模組←元件(常用於大型複雜系統)

\(
\boxed{\text{Full Adder}}
\begin{cases}
\boxed{\text{Half Adder}}
\begin{cases}
\boxed{\text{XOR}}\\
\boxed{\text{AND}}
\end{cases}\\
\boxed{\text{Half Adder}}
\begin{cases}
\boxed{\text{XOR}}\\
\boxed{\text{AND}}
\end{cases}\\
\boxed{\text{OR}}
\end{cases}\\
\text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件}
\)







1.3 Verilog 語法詞彙

由一連串的標記(token)所組成

識別字(identifiers)
關鍵字(keywords)
字串(strings)
註解(comments)
空白(whitespace)
數值(numbers)



1.3.1 識別字(identifiers)

描述電路行為所使用的自訂物件

不違反命名規則，工程師自行定義的物件名稱


命名規則

字母、數字、底線_或是錢字號$所組合而成。
開頭只能使用字母或底線。
識別字是有大小寫之分的。


舉例
Shift_reg_b         (Valid)
_bus123             (Valid)
$error_condition    (Invalid)
NT$899              (Valid)
3_bit_data          (Invalid)


1.3.2 關鍵字(keywords)

描述電路語法所保留的一組特殊名稱的標記
定義語言的結構來描述電路

輸入(input)、輸出(output)
資料型態、電路行為


所有關鍵字都必須使用小寫表示
不可當作識別字使用
常見關鍵字
\(\begin{array}{|l|l|l|l|l|l|}\hline
\text{always}&\text{and}&\text{assign}&\text{begin}&\text{buf}&\text{bufif0}\\\hline
\text{bufif1}&\text{case}&\text{casex}&\text{casez}&\text{cmos}&\text{default}\\\hline
\text{defparam}&\text{else}&\text{end}&\text{endcase}&\text{endfunction}&\text{endmodule}\\\hline
\text{endtask}&\text{event}&\text{for}&\text{forever}&\text{fork}&\text{function}\\\hline
\text{highz0}&\text{highz1}&\text{if}&\text{initial}&\text{inout}&\text{input}\\\hline
\text{integer}&\text{join}&\text{module}&\text{nand}&\text{negedge}&\text{nmos}\\\hline
\text{nor}&\text{not}&\text{notif0}&\text{notif1}&\text{or}&\text{output}\\\hline
\text{parameter}&\text{pmos}&\text{posedge}&\text{pull0}&\text{pull1}&\text{pulldown}\\\hline
\text{pullup}&\text{rcmos}&\text{real}&\text{realtime}&\text{reg}&\text{repeat}\\\hline
\text{rnmos}&\text{rpmos}&\text{rtran}&\text{rtranif0}&\text{rtranif1}&\text{strong0}\\\hline
\text{string1}&\text{supply0}&\text{supply1}&\text{task}&\text{time}&\text{tran}\\\hline
\text{tranif0}&\text{tranif1}&\text{tri}&\text{tri0}&\text{tri1}&\text{triand}\\\hline
\text{trior}&\text{trireg}&\text{wait}&\text{wand}&\text{weak0}&\text{weak1}\\\hline
\text{while}&\text{wire}&\text{wor}&\text{xnor}&\text{xor}\\\hline
\end{array}\)

1.3.3 字串(strings)

一連串字元(character)組成的單一個體
可含有字母、數字、及一些特殊字元
字串的所有字元必須在同一行上，並在雙引號之間

1.3.4 註解(comments)

程式碼中加入說明文字

可讀性(readability)
文件化(documentation)
版權宣告(license declaration)


以//開頭的單行註解(one-line comment)
以/*為開頭，並以*/為結尾的多行註解(multiple-line comment)
多行註解不支援巢狀結構

1.3.5 空白(whitespace)

區隔不同物件
空格(blank spaces，\b)
欄位(tabs，\t)
換行(newlines，\n)
除字串內空白，註解與空白在編譯與合成時會被忽略

1.3.6 數值(numbers)

Verilog 有兩種數值表示法

固定長度(sized): 定義位元寬度

<size>'<bsase format><number>

<size>：十進位來表示此數的位元數(bits)
<base format>：定義進制

'H|'h：十六進制
'D|'d：十進制
'O|'p：八進制
'B|'b：二進制


<number>：用<base format>來表示數值
若為負號，將-放在<size>前面


舉例：

18'h47CB：18 bits 的十六進位數 47CB
13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB
12'd1023：12 bits 的十進位數 1023
9'o723：9 bits 的八進位數 723
5'b11101：5bits 的二進位數 11101
5'b1xx01：含有 unknown values 的表示法




不定長度(unsized): 未定義位元寬度

&lsquo;<base format><number

不使用<size>規定位元長度
使用 HDL 編譯器內定的長度(32bit的寬度)
沒有寫明<base format>，則內定為十進制


舉例：

'h47CB：32 bits 的十六進位數 47CB
1023：32 bits 的十進位數 1023
'o723：32 bits 的八進位數 723
'b11101：32 bits 的二進位數 11101






Verilog 有四種數值位準(value level)

\(\begin{array}{|c|l|}\hline
\text{數值位準}&\text{實際電路狀態}\\\hline
\text{0}&\text{邏輯0，假(false)，接地}\\\hline
\text{1}&\text{邏輯1，真(true)，接壓電源}\\\hline
\text{x}&\text{不確定值(unknown value)}\\\hline
\text{z}&\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\hline
\end{array}
\)



1.4 Verilog 資料物件與型態

資料物件(data objects)

描述行為過程中所使用的訊號載具
一個物件經過處理再傳到另一個物件


資料型態(data type)

定義資料物件的類型
接線、暫存器、參數等



1.4.1 接線(Nets)

接線(nets)是連接實體元件的連接線
要被驅動才能改變其內部的值
最主要的關鍵字是 wire

一個位元的純量(scalar)
多位元長度的向量(vector)
內定值為 z(高阻抗、浮接)


宣告方式
wire w;         // 宣告一條接線，命名為w，內定預設值為z
wire x = 1'b0;  // 宣告一條接線，命名為x，並指定x為邏輯0
wire a, b, c    // 宣告三條接線，命名為a, b, c


1.4.2 暫存器(Registers)

抽象的資料儲存物件(有別於實體暫存器 D flip-flop)
保留一個數值直到下一次指定新值為止
觀念類似 C 語言中的變數
主要的關鍵字是 reg

一個位元的純量(scalar)
多位元長度的向量(vector)
內定值為 x(未知)


\(\begin{array}{|l|l|}\hline
\text{reg}&\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\hline
\text{integer}&\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\
&\text{算術運算產生2補數結果(2&rsquo;s complement results))}\\\hline
\text{real}&\text{雙倍精確度之有號浮點數}\\
&\text{(signed floating-point variable with double precision)}\\\hline
\text{time}&\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\hline
\end{array}\)

設計電路請以reg為主，其他類型合成器可能不支援。


宣告方式
reg a;          // 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x
reg x, y;       // 宣告 2 個宣存器，命名為 x, y
integer count;  // 宣告 1 個整數為 count，值可以為正負
real fraction;  // 宣告 1 個浮點數為 fraction，值含小數點


1.4.3 純量與向量(scalar and vector)

純量(scalar)

一個位元的物件


向量(vector)

多個位元的物件


接線(ex. wire) 與 reg

內定一位元
[大數字:小數字]、[小數字:大數字]→[MSB:LSB]


宣告方式
wire a;         // 宣告 1 個 1-bits 接線
wire [4:0] x;   // 宣告 1 個 5-bits 接線
reg b;          // 宣告 1 個 1-bits 暫存器
reg [0:7] y;    // 宣告 1 個 8-bits 暫存器
reg [31:0] z;   // 宣告 1 個 32-bits 暫存器


1.4.4 陣列(Array)

多個暫存器、接線的聚合體
索引值(index)定義聚合體中的個別物件
支援多維度的陣列
記憶體(memory)、暫存器檔案(register file)
陣列中暫存器、接線的個數

[大數字:小數字]、[小數字:大數字]


宣告方式
// mem_block 是一個包含 128 個暫存器的陣列，
// 每個暫存器皆為 32 位元寬
reg [31:0] mem_block [127:0];
// mem_2D 是一個 2 維 4x64 的暫存器陣列，
// 每個暫存器皆為 8 位元寬
reg [7:0] mem_2D [3:0][63:0];


1.4.5 參數(parameter)

定義編譯合成電路時的常數
每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路
重複使用
關鍵字 parameter
宣告方式
parameter width = 4;
wire [width-1:0] a, b;  // 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動
reg [width-1:0] y;      // 暫存器 y 的位元寬度，會隨著參數值的改變而變動


1.5 模組(Module)、埠(Port)
1.5.1 模組(Module)

一個電路區塊、可以由其他模組組成
連接模組時

考慮模組的輸入與輸出介面
不需要考慮模組內部的詳細電路


電路設計時

只修改模組內部電路
不會改變電路外部及周遭的模組


模組內部的電路描述可包含

訊號資料型態宣告
引用其他模組(邏輯閘)
assign 資料處理模型之描述
always 行為模型之描述
函數(function) 與 任務(task)
除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為


模組宣告

以關鍵字 module 為開頭，在其後加一個識別用的模組名稱(module name)
再來是輸入與輸出埠列(module terminal list)和埠列宣告，接著是模組內部關於電路的描述
以關鍵字 endmodule 做為模組結尾
支援階層`式的設計概念

module module_name(terminal_list)
port_declaration(...)
param_declaration(optional)
data_type_declaration(wire, reg)
other_module(logic_gate)
assign data_flow_model
always behavior_model
function, task
endmodule


1.5.2 埠(port)

終端點、模組與外界溝通的介面接點(門)
一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通
若模組與外界不需要溝通，則埠列也就不存在(封閉系統)

測試環境(test bench)


埠的宣告

埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。
埠的宣告型態內定為接線(net)的 wire，若需要將訊號儲存起來則埠號型態須宣告成暫存器 reg。
輸入埠和雙向埠只能是接線(net)，不可宣告成暫存器。
輸出埠可以宣告成接線(net)或暫存器。

module full_adder(a, b, carry, sum);    // 埠列
input  [3:0] a, b;                      // 輸入埠(4位元向量)
input  carry                            // 輸入埠(1位元純量)
output [4:0] sum;                       // 輸出埠(5位元向量)
reg    [4:0] sum;                       // 因輸出sum需儲存資料，故宣告成暫存器
...
endmodule


1.6 邏輯閘層次模型

利用關鍵字即可引用基本的邏輯閘元件
基本的邏輯閘關鍵字

and
nand
or
nor
not
xor
xnor



1.6.1 多個輸入邏輯閘(Multiple-Input Gates)

and、nand、or、nor、xor、xnor
具有多個純量(scalar)的輸入，但是只有一個純量的輸出
多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面
輸出必須透過接線(wire)連接，輸入無規定
多個輸入邏輯閘的別名可以加或是不加
使用方法
gate_type instance(out, in_1, in_2, in_3, ..., in_n);
gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n),
          inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n),
          inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n),
          ...
          inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn);

\(\begin{array}{ccc}
\underbrace{\text{a, b, c, d}}_{\text{輸入}}
\rightarrow
\boxed{\text{Multiple-Input Gate}}
\rightarrow
\underbrace{\text{e}} _{\text{輸出}}
\end{array}
\)
\(\text{and\quad a1(}
\underbrace{\text{e}}_{\text{輸出}}
\text{, }
\underbrace{\text{a, b, c, d}} _{\text{輸入}}
\text{);}
\)

1.6.2 多個輸出邏輯閘(Multiple-Output Gates)


not、buf"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/verilog/intro/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/verilog/intro/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[VHDL] Verilog Hardware Description Language"><meta property="og:description" content="1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \( \boxed{\text{Full Adder}} \begin{cases} \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{OR}} \end{cases}\\ \text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件} \) 1.3 Verilog 語法詞彙 由一連串的標記(token)所組成 識別字(identifiers) 關鍵字(keywords) 字串(strings) 註解(comments) 空白(whitespace) 數值(numbers) 1.3.1 識別字(identifiers) 描述電路行為所使用的自訂物件 不違反命名規則，工程師自行定義的物件名稱 命名規則 字母、數字、底線_或是錢字號$所組合而成。 開頭只能使用字母或底線。 識別字是有大小寫之分的。 舉例 Shift_reg_b (Valid) _bus123 (Valid) $error_condition (Invalid) NT$899 (Valid) 3_bit_data (Invalid) 1.3.2 關鍵字(keywords) 描述電路語法所保留的一組特殊名稱的標記 定義語言的結構來描述電路 輸入(input)、輸出(output) 資料型態、電路行為 所有關鍵字都必須使用小寫表示 不可當作識別字使用 常見關鍵字 \(\begin{array}{|l|l|l|l|l|l|}\hline \text{always}&\text{and}&\text{assign}&\text{begin}&\text{buf}&\text{bufif0}\\\hline \text{bufif1}&\text{case}&\text{casex}&\text{casez}&\text{cmos}&\text{default}\\\hline \text{defparam}&\text{else}&\text{end}&\text{endcase}&\text{endfunction}&\text{endmodule}\\\hline \text{endtask}&\text{event}&\text{for}&\text{forever}&\text{fork}&\text{function}\\\hline \text{highz0}&\text{highz1}&\text{if}&\text{initial}&\text{inout}&\text{input}\\\hline \text{integer}&\text{join}&\text{module}&\text{nand}&\text{negedge}&\text{nmos}\\\hline \text{nor}&\text{not}&\text{notif0}&\text{notif1}&\text{or}&\text{output}\\\hline \text{parameter}&\text{pmos}&\text{posedge}&\text{pull0}&\text{pull1}&\text{pulldown}\\\hline \text{pullup}&\text{rcmos}&\text{real}&\text{realtime}&\text{reg}&\text{repeat}\\\hline \text{rnmos}&\text{rpmos}&\text{rtran}&\text{rtranif0}&\text{rtranif1}&\text{strong0}\\\hline \text{string1}&\text{supply0}&\text{supply1}&\text{task}&\text{time}&\text{tran}\\\hline \text{tranif0}&\text{tranif1}&\text{tri}&\text{tri0}&\text{tri1}&\text{triand}\\\hline \text{trior}&\text{trireg}&\text{wait}&\text{wand}&\text{weak0}&\text{weak1}\\\hline \text{while}&\text{wire}&\text{wor}&\text{xnor}&\text{xor}\\\hline \end{array}\) 1.3.3 字串(strings) 一連串字元(character)組成的單一個體 可含有字母、數字、及一些特殊字元 字串的所有字元必須在同一行上，並在雙引號之間 1.3.4 註解(comments) 程式碼中加入說明文字 可讀性(readability) 文件化(documentation) 版權宣告(license declaration) 以//開頭的單行註解(one-line comment) 以/*為開頭，並以*/為結尾的多行註解(multiple-line comment) 多行註解不支援巢狀結構 1.3.5 空白(whitespace) 區隔不同物件 空格(blank spaces，\b) 欄位(tabs，\t) 換行(newlines，\n) 除字串內空白，註解與空白在編譯與合成時會被忽略 1.3.6 數值(numbers) Verilog 有兩種數值表示法 固定長度(sized): 定義位元寬度 <size>'<bsase format><number> <size>：十進位來表示此數的位元數(bits) <base format>：定義進制 'H|'h：十六進制 'D|'d：十進制 'O|'p：八進制 'B|'b：二進制 <number>：用<base format>來表示數值 若為負號，將-放在<size>前面 舉例： 18'h47CB：18 bits 的十六進位數 47CB 13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB 12'd1023：12 bits 的十進位數 1023 9'o723：9 bits 的八進位數 723 5'b11101：5bits 的二進位數 11101 5'b1xx01：含有 unknown values 的表示法 不定長度(unsized): 未定義位元寬度 ‘<base format><number 不使用<size>規定位元長度 使用 HDL 編譯器內定的長度(32bit的寬度) 沒有寫明<base format>，則內定為十進制 舉例： 'h47CB：32 bits 的十六進位數 47CB 1023：32 bits 的十進位數 1023 'o723：32 bits 的八進位數 723 'b11101：32 bits 的二進位數 11101 Verilog 有四種數值位準(value level) \(\begin{array}{|c|l|}\hline \text{數值位準}&\text{實際電路狀態}\\\hline \text{0}&\text{邏輯0，假(false)，接地}\\\hline \text{1}&\text{邏輯1，真(true)，接壓電源}\\\hline \text{x}&\text{不確定值(unknown value)}\\\hline \text{z}&\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\hline \end{array} \) 1.4 Verilog 資料物件與型態 資料物件(data objects) 描述行為過程中所使用的訊號載具 一個物件經過處理再傳到另一個物件 資料型態(data type) 定義資料物件的類型 接線、暫存器、參數等 1.4.1 接線(Nets) 接線(nets)是連接實體元件的連接線 要被驅動才能改變其內部的值 最主要的關鍵字是 wire 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 z(高阻抗、浮接) 宣告方式 wire w; // 宣告一條接線，命名為w，內定預設值為z wire x = 1'b0; // 宣告一條接線，命名為x，並指定x為邏輯0 wire a, b, c // 宣告三條接線，命名為a, b, c 1.4.2 暫存器(Registers) 抽象的資料儲存物件(有別於實體暫存器 D flip-flop) 保留一個數值直到下一次指定新值為止 觀念類似 C 語言中的變數 主要的關鍵字是 reg 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 x(未知) \(\begin{array}{|l|l|}\hline \text{reg}&\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\hline \text{integer}&\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\ &\text{算術運算產生2補數結果(2’s complement results))}\\\hline \text{real}&\text{雙倍精確度之有號浮點數}\\ &\text{(signed floating-point variable with double precision)}\\\hline \text{time}&\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\hline \end{array}\) 設計電路請以reg為主，其他類型合成器可能不支援。 宣告方式 reg a; // 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x reg x, y; // 宣告 2 個宣存器，命名為 x, y integer count; // 宣告 1 個整數為 count，值可以為正負 real fraction; // 宣告 1 個浮點數為 fraction，值含小數點 1.4.3 純量與向量(scalar and vector) 純量(scalar) 一個位元的物件 向量(vector) 多個位元的物件 接線(ex. wire) 與 reg 內定一位元 [大數字:小數字]、[小數字:大數字]→[MSB:LSB] 宣告方式 wire a; // 宣告 1 個 1-bits 接線 wire [4:0] x; // 宣告 1 個 5-bits 接線 reg b; // 宣告 1 個 1-bits 暫存器 reg [0:7] y; // 宣告 1 個 8-bits 暫存器 reg [31:0] z; // 宣告 1 個 32-bits 暫存器 1.4.4 陣列(Array) 多個暫存器、接線的聚合體 索引值(index)定義聚合體中的個別物件 支援多維度的陣列 記憶體(memory)、暫存器檔案(register file) 陣列中暫存器、接線的個數 [大數字:小數字]、[小數字:大數字] 宣告方式 // mem_block 是一個包含 128 個暫存器的陣列， // 每個暫存器皆為 32 位元寬 reg [31:0] mem_block [127:0]; // mem_2D 是一個 2 維 4x64 的暫存器陣列， // 每個暫存器皆為 8 位元寬 reg [7:0] mem_2D [3:0][63:0]; 1.4.5 參數(parameter) 定義編譯合成電路時的常數 每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路 重複使用 關鍵字 parameter 宣告方式 parameter width = 4; wire [width-1:0] a, b; // 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動 reg [width-1:0] y; // 暫存器 y 的位元寬度，會隨著參數值的改變而變動 1.5 模組(Module)、埠(Port) 1.5.1 模組(Module) 一個電路區塊、可以由其他模組組成 連接模組時 考慮模組的輸入與輸出介面 不需要考慮模組內部的詳細電路 電路設計時 只修改模組內部電路 不會改變電路外部及周遭的模組 模組內部的電路描述可包含 訊號資料型態宣告 引用其他模組(邏輯閘) assign 資料處理模型之描述 always 行為模型之描述 函數(function) 與 任務(task) 除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為 模組宣告 以關鍵字 module 為開頭，在其後加一個識別用的模組名稱(module name) 再來是輸入與輸出埠列(module terminal list)和埠列宣告，接著是模組內部關於電路的描述 以關鍵字 endmodule 做為模組結尾 支援階層`式的設計概念 module module_name(terminal_list) port_declaration(...) param_declaration(optional) data_type_declaration(wire, reg) other_module(logic_gate) assign data_flow_model always behavior_model function, task endmodule 1.5.2 埠(port) 終端點、模組與外界溝通的介面接點(門) 一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通 若模組與外界不需要溝通，則埠列也就不存在(封閉系統) 測試環境(test bench) 埠的宣告 埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。 埠的宣告型態內定為接線(net)的 wire，若需要將訊號儲存起來則埠號型態須宣告成暫存器 reg。 輸入埠和雙向埠只能是接線(net)，不可宣告成暫存器。 輸出埠可以宣告成接線(net)或暫存器。 module full_adder(a, b, carry, sum); // 埠列 input [3:0] a, b; // 輸入埠(4位元向量) input carry // 輸入埠(1位元純量) output [4:0] sum; // 輸出埠(5位元向量) reg [4:0] sum; // 因輸出sum需儲存資料，故宣告成暫存器 ... endmodule 1.6 邏輯閘層次模型 利用關鍵字即可引用基本的邏輯閘元件 基本的邏輯閘關鍵字 and nand or nor not xor xnor 1.6.1 多個輸入邏輯閘(Multiple-Input Gates) and、nand、or、nor、xor、xnor 具有多個純量(scalar)的輸入，但是只有一個純量的輸出 多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面 輸出必須透過接線(wire)連接，輸入無規定 多個輸入邏輯閘的別名可以加或是不加 使用方法 gate_type instance(out, in_1, in_2, in_3, ..., in_n); gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n), inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n), inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n), ... inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn); \(\begin{array}{ccc} \underbrace{\text{a, b, c, d}}_{\text{輸入}} \rightarrow \boxed{\text{Multiple-Input Gate}} \rightarrow \underbrace{\text{e}} _{\text{輸出}} \end{array} \) \(\text{and\quad a1(} \underbrace{\text{e}}_{\text{輸出}} \text{, } \underbrace{\text{a, b, c, d}} _{\text{輸入}} \text{);} \) 1.6.2 多個輸出邏輯閘(Multiple-Output Gates) not、buf"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="verilog"><meta property="article:published_time" content="2022-05-01T17:37:22+08:00"><meta property="article:modified_time" content="2022-05-01T17:37:22+08:00"><meta property="article:tag" content="VHDL"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Verilog"><meta property="article:tag" content="Logic Design"><meta property="og:image" content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[VHDL] Verilog Hardware Description Language"><meta name=twitter:description content="1 Verilog HDL
1.1 Verilog 簡介

一套硬體描述語言

輔助設計數位系統
描述電路的行為
電子自動化工具


類似C語言的硬體描述語言

易學、容易接受
高階行為描述
切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的)


支援多種硬體層級的描述方式

從低階到高階模式
依照不同的方法設計


支援階層式的設計方法

樹狀式的設計結構
由繁化簡



1.2 Verilog 的模型
1.2.1 電晶體層級

Transistor Level
或低階交換層次模型(Switch Level Model)
Verilog 最低階的層次模型
電路是由開關與電晶體所組成
一般不會採取低階的層級來進行設計

1.2.2 邏輯閘層級

Gate Level
使用基本的邏輯閘元件
AND、OR、NOT
邏輯電路圖

1.2.3 資料流層級

Data Flow Level
描述電路中資料的處理方式
資料如何在電路中運算及傳送
輸入持續驅動輸出
運算式

如：out = a + b + c



1.2.4 行為模型

Behavior Level
Verilog 最高階的層次模型
不需考慮硬體元件的特型，只需放在模組的功能描述
很像 C 語言
合成軟體工具

1.2.5 結構式模型

Structure Level
引用硬體模組的模式
類似邏輯閘層次模型
支援階層式設計法

將複雜電路分為層狀結構
架構上類似樹狀結構

Bottom-up：元件→子模組→設計目標
Top-Down：設計目標→子模組→元件
Mixed：設計目標→子模組←元件(常用於大型複雜系統)

\(
\boxed{\text{Full Adder}}
\begin{cases}
\boxed{\text{Half Adder}}
\begin{cases}
\boxed{\text{XOR}}\\
\boxed{\text{AND}}
\end{cases}\\
\boxed{\text{Half Adder}}
\begin{cases}
\boxed{\text{XOR}}\\
\boxed{\text{AND}}
\end{cases}\\
\boxed{\text{OR}}
\end{cases}\\
\text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件}
\)







1.3 Verilog 語法詞彙

由一連串的標記(token)所組成

識別字(identifiers)
關鍵字(keywords)
字串(strings)
註解(comments)
空白(whitespace)
數值(numbers)



1.3.1 識別字(identifiers)

描述電路行為所使用的自訂物件

不違反命名規則，工程師自行定義的物件名稱


命名規則

字母、數字、底線_或是錢字號$所組合而成。
開頭只能使用字母或底線。
識別字是有大小寫之分的。


舉例
Shift_reg_b         (Valid)
_bus123             (Valid)
$error_condition    (Invalid)
NT$899              (Valid)
3_bit_data          (Invalid)


1.3.2 關鍵字(keywords)

描述電路語法所保留的一組特殊名稱的標記
定義語言的結構來描述電路

輸入(input)、輸出(output)
資料型態、電路行為


所有關鍵字都必須使用小寫表示
不可當作識別字使用
常見關鍵字
\(\begin{array}{|l|l|l|l|l|l|}\hline
\text{always}&\text{and}&\text{assign}&\text{begin}&\text{buf}&\text{bufif0}\\\hline
\text{bufif1}&\text{case}&\text{casex}&\text{casez}&\text{cmos}&\text{default}\\\hline
\text{defparam}&\text{else}&\text{end}&\text{endcase}&\text{endfunction}&\text{endmodule}\\\hline
\text{endtask}&\text{event}&\text{for}&\text{forever}&\text{fork}&\text{function}\\\hline
\text{highz0}&\text{highz1}&\text{if}&\text{initial}&\text{inout}&\text{input}\\\hline
\text{integer}&\text{join}&\text{module}&\text{nand}&\text{negedge}&\text{nmos}\\\hline
\text{nor}&\text{not}&\text{notif0}&\text{notif1}&\text{or}&\text{output}\\\hline
\text{parameter}&\text{pmos}&\text{posedge}&\text{pull0}&\text{pull1}&\text{pulldown}\\\hline
\text{pullup}&\text{rcmos}&\text{real}&\text{realtime}&\text{reg}&\text{repeat}\\\hline
\text{rnmos}&\text{rpmos}&\text{rtran}&\text{rtranif0}&\text{rtranif1}&\text{strong0}\\\hline
\text{string1}&\text{supply0}&\text{supply1}&\text{task}&\text{time}&\text{tran}\\\hline
\text{tranif0}&\text{tranif1}&\text{tri}&\text{tri0}&\text{tri1}&\text{triand}\\\hline
\text{trior}&\text{trireg}&\text{wait}&\text{wand}&\text{weak0}&\text{weak1}\\\hline
\text{while}&\text{wire}&\text{wor}&\text{xnor}&\text{xor}\\\hline
\end{array}\)

1.3.3 字串(strings)

一連串字元(character)組成的單一個體
可含有字母、數字、及一些特殊字元
字串的所有字元必須在同一行上，並在雙引號之間

1.3.4 註解(comments)

程式碼中加入說明文字

可讀性(readability)
文件化(documentation)
版權宣告(license declaration)


以//開頭的單行註解(one-line comment)
以/*為開頭，並以*/為結尾的多行註解(multiple-line comment)
多行註解不支援巢狀結構

1.3.5 空白(whitespace)

區隔不同物件
空格(blank spaces，\b)
欄位(tabs，\t)
換行(newlines，\n)
除字串內空白，註解與空白在編譯與合成時會被忽略

1.3.6 數值(numbers)

Verilog 有兩種數值表示法

固定長度(sized): 定義位元寬度

<size>'<bsase format><number>

<size>：十進位來表示此數的位元數(bits)
<base format>：定義進制

'H|'h：十六進制
'D|'d：十進制
'O|'p：八進制
'B|'b：二進制


<number>：用<base format>來表示數值
若為負號，將-放在<size>前面


舉例：

18'h47CB：18 bits 的十六進位數 47CB
13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB
12'd1023：12 bits 的十進位數 1023
9'o723：9 bits 的八進位數 723
5'b11101：5bits 的二進位數 11101
5'b1xx01：含有 unknown values 的表示法




不定長度(unsized): 未定義位元寬度

&lsquo;<base format><number

不使用<size>規定位元長度
使用 HDL 編譯器內定的長度(32bit的寬度)
沒有寫明<base format>，則內定為十進制


舉例：

'h47CB：32 bits 的十六進位數 47CB
1023：32 bits 的十進位數 1023
'o723：32 bits 的八進位數 723
'b11101：32 bits 的二進位數 11101






Verilog 有四種數值位準(value level)

\(\begin{array}{|c|l|}\hline
\text{數值位準}&\text{實際電路狀態}\\\hline
\text{0}&\text{邏輯0，假(false)，接地}\\\hline
\text{1}&\text{邏輯1，真(true)，接壓電源}\\\hline
\text{x}&\text{不確定值(unknown value)}\\\hline
\text{z}&\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\hline
\end{array}
\)



1.4 Verilog 資料物件與型態

資料物件(data objects)

描述行為過程中所使用的訊號載具
一個物件經過處理再傳到另一個物件


資料型態(data type)

定義資料物件的類型
接線、暫存器、參數等



1.4.1 接線(Nets)

接線(nets)是連接實體元件的連接線
要被驅動才能改變其內部的值
最主要的關鍵字是 wire

一個位元的純量(scalar)
多位元長度的向量(vector)
內定值為 z(高阻抗、浮接)


宣告方式
wire w;         // 宣告一條接線，命名為w，內定預設值為z
wire x = 1'b0;  // 宣告一條接線，命名為x，並指定x為邏輯0
wire a, b, c    // 宣告三條接線，命名為a, b, c


1.4.2 暫存器(Registers)

抽象的資料儲存物件(有別於實體暫存器 D flip-flop)
保留一個數值直到下一次指定新值為止
觀念類似 C 語言中的變數
主要的關鍵字是 reg

一個位元的純量(scalar)
多位元長度的向量(vector)
內定值為 x(未知)


\(\begin{array}{|l|l|}\hline
\text{reg}&\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\hline
\text{integer}&\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\
&\text{算術運算產生2補數結果(2&rsquo;s complement results))}\\\hline
\text{real}&\text{雙倍精確度之有號浮點數}\\
&\text{(signed floating-point variable with double precision)}\\\hline
\text{time}&\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\hline
\end{array}\)

設計電路請以reg為主，其他類型合成器可能不支援。


宣告方式
reg a;          // 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x
reg x, y;       // 宣告 2 個宣存器，命名為 x, y
integer count;  // 宣告 1 個整數為 count，值可以為正負
real fraction;  // 宣告 1 個浮點數為 fraction，值含小數點


1.4.3 純量與向量(scalar and vector)

純量(scalar)

一個位元的物件


向量(vector)

多個位元的物件


接線(ex. wire) 與 reg

內定一位元
[大數字:小數字]、[小數字:大數字]→[MSB:LSB]


宣告方式
wire a;         // 宣告 1 個 1-bits 接線
wire [4:0] x;   // 宣告 1 個 5-bits 接線
reg b;          // 宣告 1 個 1-bits 暫存器
reg [0:7] y;    // 宣告 1 個 8-bits 暫存器
reg [31:0] z;   // 宣告 1 個 32-bits 暫存器


1.4.4 陣列(Array)

多個暫存器、接線的聚合體
索引值(index)定義聚合體中的個別物件
支援多維度的陣列
記憶體(memory)、暫存器檔案(register file)
陣列中暫存器、接線的個數

[大數字:小數字]、[小數字:大數字]


宣告方式
// mem_block 是一個包含 128 個暫存器的陣列，
// 每個暫存器皆為 32 位元寬
reg [31:0] mem_block [127:0];
// mem_2D 是一個 2 維 4x64 的暫存器陣列，
// 每個暫存器皆為 8 位元寬
reg [7:0] mem_2D [3:0][63:0];


1.4.5 參數(parameter)

定義編譯合成電路時的常數
每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路
重複使用
關鍵字 parameter
宣告方式
parameter width = 4;
wire [width-1:0] a, b;  // 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動
reg [width-1:0] y;      // 暫存器 y 的位元寬度，會隨著參數值的改變而變動


1.5 模組(Module)、埠(Port)
1.5.1 模組(Module)

一個電路區塊、可以由其他模組組成
連接模組時

考慮模組的輸入與輸出介面
不需要考慮模組內部的詳細電路


電路設計時

只修改模組內部電路
不會改變電路外部及周遭的模組


模組內部的電路描述可包含

訊號資料型態宣告
引用其他模組(邏輯閘)
assign 資料處理模型之描述
always 行為模型之描述
函數(function) 與 任務(task)
除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為


模組宣告

以關鍵字 module 為開頭，在其後加一個識別用的模組名稱(module name)
再來是輸入與輸出埠列(module terminal list)和埠列宣告，接著是模組內部關於電路的描述
以關鍵字 endmodule 做為模組結尾
支援階層`式的設計概念

module module_name(terminal_list)
port_declaration(...)
param_declaration(optional)
data_type_declaration(wire, reg)
other_module(logic_gate)
assign data_flow_model
always behavior_model
function, task
endmodule


1.5.2 埠(port)

終端點、模組與外界溝通的介面接點(門)
一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通
若模組與外界不需要溝通，則埠列也就不存在(封閉系統)

測試環境(test bench)


埠的宣告

埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。
埠的宣告型態內定為接線(net)的 wire，若需要將訊號儲存起來則埠號型態須宣告成暫存器 reg。
輸入埠和雙向埠只能是接線(net)，不可宣告成暫存器。
輸出埠可以宣告成接線(net)或暫存器。

module full_adder(a, b, carry, sum);    // 埠列
input  [3:0] a, b;                      // 輸入埠(4位元向量)
input  carry                            // 輸入埠(1位元純量)
output [4:0] sum;                       // 輸出埠(5位元向量)
reg    [4:0] sum;                       // 因輸出sum需儲存資料，故宣告成暫存器
...
endmodule


1.6 邏輯閘層次模型

利用關鍵字即可引用基本的邏輯閘元件
基本的邏輯閘關鍵字

and
nand
or
nor
not
xor
xnor



1.6.1 多個輸入邏輯閘(Multiple-Input Gates)

and、nand、or、nor、xor、xnor
具有多個純量(scalar)的輸入，但是只有一個純量的輸出
多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面
輸出必須透過接線(wire)連接，輸入無規定
多個輸入邏輯閘的別名可以加或是不加
使用方法
gate_type instance(out, in_1, in_2, in_3, ..., in_n);
gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n),
          inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n),
          inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n),
          ...
          inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn);

\(\begin{array}{ccc}
\underbrace{\text{a, b, c, d}}_{\text{輸入}}
\rightarrow
\boxed{\text{Multiple-Input Gate}}
\rightarrow
\underbrace{\text{e}} _{\text{輸出}}
\end{array}
\)
\(\text{and\quad a1(}
\underbrace{\text{e}}_{\text{輸出}}
\text{, }
\underbrace{\text{a, b, c, d}} _{\text{輸入}}
\text{);}
\)

1.6.2 多個輸出邏輯閘(Multiple-Output Gates)


not、buf"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Verilogs","item":"https://intervalrain.github.io/verilog/"},{"@type":"ListItem","position":2,"name":"[VHDL] Verilog Hardware Description Language","item":"https://intervalrain.github.io/verilog/intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VHDL] Verilog Hardware Description Language","name":"[VHDL] Verilog Hardware Description Language","description":"1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\) 1.3 Verilog 語法詞彙 由一連串的標記(token)所組成 識別字(identifiers) 關鍵字(keywords) 字串(strings) 註解(comments) 空白(whitespace) 數值(numbers) 1.3.1 識別字(identifiers) 描述電路行為所使用的自訂物件 不違反命名規則，工程師自行定義的物件名稱 命名規則 字母、數字、底線_或是錢字號$所組合而成。 開頭只能使用字母或底線。 識別字是有大小寫之分的。 舉例 Shift_reg_b (Valid) _bus123 (Valid) $error_condition (Invalid) NT$899 (Valid) 3_bit_data (Invalid) 1.3.2 關鍵字(keywords) 描述電路語法所保留的一組特殊名稱的標記 定義語言的結構來描述電路 輸入(input)、輸出(output) 資料型態、電路行為 所有關鍵字都必須使用小寫表示 不可當作識別字使用 常見關鍵字 \\(\\begin{array}{|l|l|l|l|l|l|}\\hline \\text{always}\u0026amp;\\text{and}\u0026amp;\\text{assign}\u0026amp;\\text{begin}\u0026amp;\\text{buf}\u0026amp;\\text{bufif0}\\\\\\hline \\text{bufif1}\u0026amp;\\text{case}\u0026amp;\\text{casex}\u0026amp;\\text{casez}\u0026amp;\\text{cmos}\u0026amp;\\text{default}\\\\\\hline \\text{defparam}\u0026amp;\\text{else}\u0026amp;\\text{end}\u0026amp;\\text{endcase}\u0026amp;\\text{endfunction}\u0026amp;\\text{endmodule}\\\\\\hline \\text{endtask}\u0026amp;\\text{event}\u0026amp;\\text{for}\u0026amp;\\text{forever}\u0026amp;\\text{fork}\u0026amp;\\text{function}\\\\\\hline \\text{highz0}\u0026amp;\\text{highz1}\u0026amp;\\text{if}\u0026amp;\\text{initial}\u0026amp;\\text{inout}\u0026amp;\\text{input}\\\\\\hline \\text{integer}\u0026amp;\\text{join}\u0026amp;\\text{module}\u0026amp;\\text{nand}\u0026amp;\\text{negedge}\u0026amp;\\text{nmos}\\\\\\hline \\text{nor}\u0026amp;\\text{not}\u0026amp;\\text{notif0}\u0026amp;\\text{notif1}\u0026amp;\\text{or}\u0026amp;\\text{output}\\\\\\hline \\text{parameter}\u0026amp;\\text{pmos}\u0026amp;\\text{posedge}\u0026amp;\\text{pull0}\u0026amp;\\text{pull1}\u0026amp;\\text{pulldown}\\\\\\hline \\text{pullup}\u0026amp;\\text{rcmos}\u0026amp;\\text{real}\u0026amp;\\text{realtime}\u0026amp;\\text{reg}\u0026amp;\\text{repeat}\\\\\\hline \\text{rnmos}\u0026amp;\\text{rpmos}\u0026amp;\\text{rtran}\u0026amp;\\text{rtranif0}\u0026amp;\\text{rtranif1}\u0026amp;\\text{strong0}\\\\\\hline \\text{string1}\u0026amp;\\text{supply0}\u0026amp;\\text{supply1}\u0026amp;\\text{task}\u0026amp;\\text{time}\u0026amp;\\text{tran}\\\\\\hline \\text{tranif0}\u0026amp;\\text{tranif1}\u0026amp;\\text{tri}\u0026amp;\\text{tri0}\u0026amp;\\text{tri1}\u0026amp;\\text{triand}\\\\\\hline \\text{trior}\u0026amp;\\text{trireg}\u0026amp;\\text{wait}\u0026amp;\\text{wand}\u0026amp;\\text{weak0}\u0026amp;\\text{weak1}\\\\\\hline \\text{while}\u0026amp;\\text{wire}\u0026amp;\\text{wor}\u0026amp;\\text{xnor}\u0026amp;\\text{xor}\\\\\\hline \\end{array}\\) 1.3.3 字串(strings) 一連串字元(character)組成的單一個體 可含有字母、數字、及一些特殊字元 字串的所有字元必須在同一行上，並在雙引號之間 1.3.4 註解(comments) 程式碼中加入說明文字 可讀性(readability) 文件化(documentation) 版權宣告(license declaration) 以//開頭的單行註解(one-line comment) 以/*為開頭，並以*/為結尾的多行註解(multiple-line comment) 多行註解不支援巢狀結構 1.3.5 空白(whitespace) 區隔不同物件 空格(blank spaces，\\b) 欄位(tabs，\\t) 換行(newlines，\\n) 除字串內空白，註解與空白在編譯與合成時會被忽略 1.3.6 數值(numbers) Verilog 有兩種數值表示法 固定長度(\bsized): 定義位元寬度 \u0026lt;size\u0026gt;'\u0026lt;bsase format\u0026gt;\u0026lt;number\u0026gt; \u0026lt;size\u0026gt;：十進位來表示此數的位元數(bits) \u0026lt;base format\u0026gt;：定義進制 'H|'h：十六進制 'D|'d：十進制 'O|'p：八進制 'B|'b：二進制 \u0026lt;number\u0026gt;：用\u0026lt;base format\u0026gt;來表示數值 若為負號，將-放在\u0026lt;size\u0026gt;前面 舉例： 18'h47CB：18 bits 的十六進位數 47CB 13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB 12'd1023：12 bits 的十進位數 1023 9'o723：9 bits 的八進位數 723 5'b11101：5bits 的二進位數 11101 5'b1xx01：含有 unknown values 的表示法 不定長度(unsized): 未定義位元寬度 \u0026lsquo;\u0026lt;base format\u0026gt;\u0026lt;number 不使用\u0026lt;size\u0026gt;規定位元長度 使用 HDL 編譯器內定的長度(32bit的寬度) 沒有寫明\u0026lt;base format\u0026gt;，則內定為十進制 舉例： 'h47CB：32 bits 的十六進位數 47CB 1023：32 bits 的十進位數 1023 'o723：32 bits 的八進位數 723 'b11101：32 bits 的二進位數 11101 Verilog 有四種數值位準(value level) \\(\\begin{array}{|c|l|}\\hline \\text{數值位準}\u0026amp;\\text{實際電路狀態}\\\\\\hline \\text{0}\u0026amp;\\text{邏輯0，假(false)，接地}\\\\\\hline \\text{1}\u0026amp;\\text{邏輯1，真(true)，接壓電源}\\\\\\hline \\text{x}\u0026amp;\\text{不確定值(unknown value)}\\\\\\hline \\text{z}\u0026amp;\\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\\\\hline \\end{array} \\) 1.4 Verilog 資料物件與型態 資料物件(data objects) 描述行為過程中所使用的訊號載具 一個物件經過處理再傳到另一個物件 資料型態(data type) 定義資料物件的類型 接線、暫存器、參數等 1.4.1 接線(Nets) 接線(nets)是連接實體元件的連接線 要被驅動才能改變其內部的值 最主要的關鍵字是 wire 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 z(高阻抗、浮接) 宣告方式 wire w; // 宣告一條接線，命名為\bw，內定預設值為z wire x = 1\u0026#39;b0; // 宣告一條接線，命名為x，並指定x為邏輯0 wire a, b, c // 宣告三條接線，命名為a, b, c 1.4.2 暫存器(Registers) 抽象的資料儲存物件(有別於實體暫存器 D flip-flop) 保留一個數值直到下一次指定新值為止 觀念類似 C 語言中的變數 主要的關鍵字是 reg 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 x(未知) \\(\\begin{array}{|l|l|}\\hline \\text{reg}\u0026amp;\\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\\\\hline \\text{integer}\u0026amp;\\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\\\ \u0026amp;\\text{算術運算產生2補數結果(2\u0026rsquo;s complement results))}\\\\\\hline \\text{real}\u0026amp;\\text{雙倍精確度之有號浮點數}\\\\ \u0026amp;\\text{(signed floating-point variable with double precision)}\\\\\\hline \\text{time}\u0026amp;\\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\\\\hline \\end{array}\\) 設計電路請以reg為主，其他類型合成器可能不支援。 宣告方式 reg a; // 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x reg x, y; // 宣告 2 個宣存器，命名為 x, y integer count; // 宣告 1 個整數為 count，值可以為正負 real fraction; // 宣告 1 個浮點數為 fraction，值含小數點 1.4.3 純量與向量(scalar and vector) 純量(scalar) 一個位元的物件 向量(vector) 多個位元的物件 接線(ex. wire) 與 reg 內定一位元 [大數字:小數字]、[小數字:大數字]→[MSB:LSB] 宣告方式 wire a; // 宣告 1 個 1-bits 接線 wire [4:0] x; // 宣告 1 個 5-bits 接線 reg b; // 宣告 1 個 1-bits 暫存器 reg [0:7] y; // 宣告 1 個 8-bits 暫存器 reg [31:0] z; // 宣告 1 個 32-bits 暫存器 1.4.4 陣列(Array) 多個暫存器、接線的聚合體 索引值(index)定義聚合體中的個別物件 支援多維度的陣列 記憶體(memory)、暫存器檔案(register file) 陣列中暫存器、接線的個數 [大數字:小數字]、[小數字:大數字] 宣告方式 // mem_block 是一個包含 128 個暫存器的陣列， // 每個暫存器皆為 32 位元寬 reg [31:0] mem_block [127:0]; // mem_2D 是一個 2 維 4x64 的暫存器陣列， // 每個暫存器皆為 8 位元寬 reg [7:0] mem_2D [3:0][63:0]; 1.4.5 參數(parameter) 定義編譯合成電路時的常數 每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路 重複使用 關鍵字 parameter 宣告方式 parameter width = 4; wire [width-1:0] a, b; // 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動 reg [width-1:0] y; // 暫存器 y 的位元寬度，會隨著參數值的改變而變動 1.5 模組(Module)、埠(Port) 1.5.1 模組(Module) 一個電路區塊、可以由其他模組組成 連接模組時 考慮模組的輸入與輸出介面 不需要考慮模組內部的詳細電路 電路設計時 只修改模組內部電路 不會改變電路外部及周遭的模組 模組內部的電路描述可包含 訊號資料型態宣告 引用其他模組(邏輯閘) assign 資料處理模型之描述 always 行為模型之描述 函數(function) 與 任務(task) 除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為 模組宣告 以關鍵字 module 為開頭，在其後加一個識別用的模組名稱(module name) 再來是輸入與輸出埠列(module terminal list)和埠列宣告，接著是模組內部關於電路的描述 以關鍵字 endmodule 做為模組結尾 支援階層`式的設計概念 module module_name(terminal_list) port_declaration(...) param_declaration(optional) data_type_declaration(wire, reg) other_module(logic_gate) assign data_flow_model always behavior_model function, task endmodule 1.5.2 埠(port) 終端點、模組與外界溝通的介面接點(門) 一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通 若模組與外界不需要溝通，則埠列也就不存在(封閉系統) 測試環境(test bench) 埠的宣告 埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。 埠的宣告型態內定為接線(net)的 wire，若需要將訊號儲存起來則埠號型態須宣告成暫存器 reg。 輸入埠和雙向埠只能是接線(net)，不可宣告成暫存器。 輸出埠可以宣告成接線(net)或暫存器。 module full_adder(a, b, carry, sum); // 埠列 input [3:0] a, b; // 輸入埠(4位元向量) input carry // 輸入埠(1位元純量) output [4:0] sum; // 輸出埠(5位元向量) reg [4:0] sum; // 因輸出sum需儲存資料，故宣告成暫存器 ... endmodule 1.6 邏輯閘層次模型 利用關鍵字即可引用基本的邏輯閘元件 基本的邏輯閘關鍵字 and nand or nor not xor xnor 1.6.1 多個輸入邏輯閘(Multiple-Input Gates) and、nand、or、nor、xor、xnor 具有多個純量(scalar)的輸入，但是只有一個純量的輸出 多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面 輸出必須透過接線(wire)連接，輸入無規定 多個輸入邏輯閘的別名可以加或是不加 使用方法 gate_type instance(out, in_1, in_2, in_3, ..., in_n); gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n), inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n), inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n), ... inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn); \\(\\begin{array}{ccc} \\underbrace{\\text{a, b, c, d}}_{\\text{輸入}} \\rightarrow \\boxed{\\text{Multiple-Input Gate}} \\rightarrow \\underbrace{\\text{e}} _{\\text{輸出}} \\end{array} \\) \\(\\text{and\\quad a1(} \\underbrace{\\text{e}}_{\\text{輸出}} \\text{, } \\underbrace{\\text{a, b, c, d}} _{\\text{輸入}} \\text{);} \\) 1.6.2 多個輸出邏輯閘(Multiple-Output Gates) not、buf\n","keywords":["VHDL","Programming","Verilog","Logic Design"],"articleBody":"1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\) 1.3 Verilog 語法詞彙 由一連串的標記(token)所組成 識別字(identifiers) 關鍵字(keywords) 字串(strings) 註解(comments) 空白(whitespace) 數值(numbers) 1.3.1 識別字(identifiers) 描述電路行為所使用的自訂物件 不違反命名規則，工程師自行定義的物件名稱 命名規則 字母、數字、底線_或是錢字號$所組合而成。 開頭只能使用字母或底線。 識別字是有大小寫之分的。 舉例 Shift_reg_b (Valid) _bus123 (Valid) $error_condition (Invalid) NT$899 (Valid) 3_bit_data (Invalid) 1.3.2 關鍵字(keywords) 描述電路語法所保留的一組特殊名稱的標記 定義語言的結構來描述電路 輸入(input)、輸出(output) 資料型態、電路行為 所有關鍵字都必須使用小寫表示 不可當作識別字使用 常見關鍵字 \\(\\begin{array}{|l|l|l|l|l|l|}\\hline \\text{always}\u0026\\text{and}\u0026\\text{assign}\u0026\\text{begin}\u0026\\text{buf}\u0026\\text{bufif0}\\\\\\hline \\text{bufif1}\u0026\\text{case}\u0026\\text{casex}\u0026\\text{casez}\u0026\\text{cmos}\u0026\\text{default}\\\\\\hline \\text{defparam}\u0026\\text{else}\u0026\\text{end}\u0026\\text{endcase}\u0026\\text{endfunction}\u0026\\text{endmodule}\\\\\\hline \\text{endtask}\u0026\\text{event}\u0026\\text{for}\u0026\\text{forever}\u0026\\text{fork}\u0026\\text{function}\\\\\\hline \\text{highz0}\u0026\\text{highz1}\u0026\\text{if}\u0026\\text{initial}\u0026\\text{inout}\u0026\\text{input}\\\\\\hline \\text{integer}\u0026\\text{join}\u0026\\text{module}\u0026\\text{nand}\u0026\\text{negedge}\u0026\\text{nmos}\\\\\\hline \\text{nor}\u0026\\text{not}\u0026\\text{notif0}\u0026\\text{notif1}\u0026\\text{or}\u0026\\text{output}\\\\\\hline \\text{parameter}\u0026\\text{pmos}\u0026\\text{posedge}\u0026\\text{pull0}\u0026\\text{pull1}\u0026\\text{pulldown}\\\\\\hline \\text{pullup}\u0026\\text{rcmos}\u0026\\text{real}\u0026\\text{realtime}\u0026\\text{reg}\u0026\\text{repeat}\\\\\\hline \\text{rnmos}\u0026\\text{rpmos}\u0026\\text{rtran}\u0026\\text{rtranif0}\u0026\\text{rtranif1}\u0026\\text{strong0}\\\\\\hline \\text{string1}\u0026\\text{supply0}\u0026\\text{supply1}\u0026\\text{task}\u0026\\text{time}\u0026\\text{tran}\\\\\\hline \\text{tranif0}\u0026\\text{tranif1}\u0026\\text{tri}\u0026\\text{tri0}\u0026\\text{tri1}\u0026\\text{triand}\\\\\\hline \\text{trior}\u0026\\text{trireg}\u0026\\text{wait}\u0026\\text{wand}\u0026\\text{weak0}\u0026\\text{weak1}\\\\\\hline \\text{while}\u0026\\text{wire}\u0026\\text{wor}\u0026\\text{xnor}\u0026\\text{xor}\\\\\\hline \\end{array}\\) 1.3.3 字串(strings) 一連串字元(character)組成的單一個體 可含有字母、數字、及一些特殊字元 字串的所有字元必須在同一行上，並在雙引號之間 1.3.4 註解(comments) 程式碼中加入說明文字 可讀性(readability) 文件化(documentation) 版權宣告(license declaration) 以//開頭的單行註解(one-line comment) 以/*為開頭，並以*/為結尾的多行註解(multiple-line comment) 多行註解不支援巢狀結構 1.3.5 空白(whitespace) 區隔不同物件 空格(blank spaces，\\b) 欄位(tabs，\\t) 換行(newlines，\\n) 除字串內空白，註解與空白在編譯與合成時會被忽略 1.3.6 數值(numbers) Verilog 有兩種數值表示法 固定長度(\bsized): 定義位元寬度 ' ：十進位來表示此數的位元數(bits) ：定義進制 'H|'h：十六進制 'D|'d：十進制 'O|'p：八進制 'B|'b：二進制 ：用來表示數值 若為負號，將-放在前面 舉例： 18'h47CB：18 bits 的十六進位數 47CB 13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB 12'd1023：12 bits 的十進位數 1023 9'o723：9 bits 的八進位數 723 5'b11101：5bits 的二進位數 11101 5'b1xx01：含有 unknown values 的表示法 不定長度(unsized): 未定義位元寬度 ‘","wordCount":"790","inLanguage":"zh-tw","image":"https://intervalrain.github.io/images/cover.jpg","datePublished":"2022-05-01T17:37:22+08:00","dateModified":"2022-05-01T17:37:22+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/verilog/intro/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/verilog/>Verilogs</a></div><h1 class="post-title entry-hint-parent">[VHDL] Verilog Hardware Description Language</h1><div class=post-meta><span title='2022-05-01 17:37:22 +0800 +0800'>May 1, 2022</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//Verilog/intro.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#1-verilog-hdl aria-label="1 Verilog HDL">1 Verilog HDL</a><ul><li><a href=#11-verilog-%e7%b0%a1%e4%bb%8b aria-label="1.1 Verilog 簡介">1.1 Verilog 簡介</a></li><li><a href=#12-verilog-%e7%9a%84%e6%a8%a1%e5%9e%8b aria-label="1.2 Verilog 的模型">1.2 Verilog 的模型</a><ul><li><a href=#121-%e9%9b%bb%e6%99%b6%e9%ab%94%e5%b1%a4%e7%b4%9a aria-label="1.2.1 電晶體層級">1.2.1 電晶體層級</a></li><li><a href=#122-%e9%82%8f%e8%bc%af%e9%96%98%e5%b1%a4%e7%b4%9a aria-label="1.2.2 邏輯閘層級">1.2.2 邏輯閘層級</a></li><li><a href=#123-%e8%b3%87%e6%96%99%e6%b5%81%e5%b1%a4%e7%b4%9a aria-label="1.2.3 資料流層級">1.2.3 資料流層級</a></li><li><a href=#124-%e8%a1%8c%e7%82%ba%e6%a8%a1%e5%9e%8b aria-label="1.2.4 行為模型">1.2.4 行為模型</a></li><li><a href=#125-%e7%b5%90%e6%a7%8b%e5%bc%8f%e6%a8%a1%e5%9e%8b aria-label="1.2.5 結構式模型">1.2.5 結構式模型</a></li></ul></li><li><a href=#13-verilog-%e8%aa%9e%e6%b3%95%e8%a9%9e%e5%bd%99 aria-label="1.3 Verilog 語法詞彙">1.3 Verilog 語法詞彙</a><ul><li><a href=#131-%e8%ad%98%e5%88%a5%e5%ad%97identifiers aria-label="1.3.1 識別字(identifiers)">1.3.1 識別字(identifiers)</a></li><li><a href=#132-%e9%97%9c%e9%8d%b5%e5%ad%97keywords aria-label="1.3.2 關鍵字(keywords)">1.3.2 關鍵字(keywords)</a></li><li><a href=#133-%e5%ad%97%e4%b8%b2strings aria-label="1.3.3 字串(strings)">1.3.3 字串(strings)</a></li><li><a href=#134-%e8%a8%bb%e8%a7%a3comments aria-label="1.3.4 註解(comments)">1.3.4 註解(comments)</a></li><li><a href=#135-%e7%a9%ba%e7%99%bdwhitespace aria-label="1.3.5 空白(whitespace)">1.3.5 空白(whitespace)</a></li><li><a href=#136-%e6%95%b8%e5%80%bcnumbers aria-label="1.3.6 數值(numbers)">1.3.6 數值(numbers)</a></li></ul></li><li><a href=#14-verilog-%e8%b3%87%e6%96%99%e7%89%a9%e4%bb%b6%e8%88%87%e5%9e%8b%e6%85%8b aria-label="1.4 Verilog 資料物件與型態">1.4 Verilog 資料物件與型態</a><ul><li><a href=#141-%e6%8e%a5%e7%b7%9anets aria-label="1.4.1 接線(Nets)">1.4.1 接線(Nets)</a></li><li><a href=#142-%e6%9a%ab%e5%ad%98%e5%99%a8registers aria-label="1.4.2 暫存器(Registers)">1.4.2 暫存器(Registers)</a></li><li><a href=#143-%e7%b4%94%e9%87%8f%e8%88%87%e5%90%91%e9%87%8fscalar-and-vector aria-label="1.4.3 純量與向量(scalar and vector)">1.4.3 純量與向量(scalar and vector)</a></li><li><a href=#144-%e9%99%a3%e5%88%97array aria-label="1.4.4 陣列(Array)">1.4.4 陣列(Array)</a></li></ul></li><li><a href=#145-%e5%8f%83%e6%95%b8parameter aria-label="1.4.5 參數(parameter)">1.4.5 參數(parameter)</a></li><li><a href=#15-%e6%a8%a1%e7%b5%84module%e5%9f%a0port aria-label="1.5 模組(Module)、埠(Port)">1.5 模組(Module)、埠(Port)</a><ul><li><a href=#151-%e6%a8%a1%e7%b5%84module aria-label="1.5.1 模組(Module)">1.5.1 模組(Module)</a></li><li><a href=#152-%e5%9f%a0port aria-label="1.5.2 埠(port)">1.5.2 埠(port)</a></li></ul></li><li><a href=#16-%e9%82%8f%e8%bc%af%e9%96%98%e5%b1%a4%e6%ac%a1%e6%a8%a1%e5%9e%8b aria-label="1.6 邏輯閘層次模型">1.6 邏輯閘層次模型</a><ul><li><a href=#161-%e5%a4%9a%e5%80%8b%e8%bc%b8%e5%85%a5%e9%82%8f%e8%bc%af%e9%96%98multiple-input-gates aria-label="1.6.1 多個輸入邏輯閘(Multiple-Input Gates)">1.6.1 多個輸入邏輯閘(Multiple-Input Gates)</a></li><li><a href=#162-%e5%a4%9a%e5%80%8b%e8%bc%b8%e5%87%ba%e9%82%8f%e8%bc%af%e9%96%98multiple-output-gates aria-label="1.6.2 多個輸出邏輯閘(Multiple-Output Gates)">1.6.2 多個輸出邏輯閘(Multiple-Output Gates)</a></li></ul></li></ul></li><li><a href=#2-%e5%af%a6%e4%bd%9c aria-label="2 實作">2 實作</a><ul><ul><li><a href=#1-hdlbits aria-label="1. HDLbits">1. <a href=/verilog/hdlbits1/>HDLbits</a></a></li><li><a href=#2-verilog aria-label="2. Verilog">2. <a href=/verilog/hdlbits2/>Verilog</a></a></li><li><a href=#3-circuits aria-label="3. Circuits">3. <a href=/verilog/hdlbits3/>Circuits</a></a></li><li><a href=#4-verification-reading-simulations aria-label="4. Verification: Reading Simulations">4. <a href=/verilog/hdlbits4/>Verification: Reading Simulations</a></a></li><li><a href=#5-verification-writing-testbenches aria-label="5. Verification: Writing Testbenches">5. <a href=/verilog/hdlbits5/>Verification: Writing Testbenches</a></a></li><li><a href=#6-cs450 aria-label="6. CS450">6. <a href=/verilog/hdlbits6/>CS450</a></a></li></ul></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=1-verilog-hdl>1 Verilog HDL<a hidden class=anchor aria-hidden=true href=#1-verilog-hdl>#</a></h1><h2 id=11-verilog-簡介>1.1 Verilog 簡介<a hidden class=anchor aria-hidden=true href=#11-verilog-簡介>#</a></h2><ul><li>一套硬體描述語言<ul><li>輔助設計<strong>數位系統</strong></li><li>描述電路的行為</li><li>電子自動化工具</li></ul></li><li>類似C語言的硬體描述語言<ul><li>易學、容易接受</li><li>高階行為描述</li><li>切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的)</li></ul></li><li>支援多種硬體層級的描述方式<ul><li>從低階到高階模式</li><li>依照不同的方法設計</li></ul></li><li>支援階層式的設計方法<ul><li>樹狀式的設計結構</li><li>由繁化簡</li></ul></li></ul><h2 id=12-verilog-的模型>1.2 Verilog 的模型<a hidden class=anchor aria-hidden=true href=#12-verilog-的模型>#</a></h2><h3 id=121-電晶體層級>1.2.1 電晶體層級<a hidden class=anchor aria-hidden=true href=#121-電晶體層級>#</a></h3><ul><li>Transistor Level</li><li>或低階交換層次模型(Switch Level Model)</li><li>Verilog 最低階的層次模型</li><li>電路是由開關與電晶體所組成</li><li>一般不會採取低階的層級來進行設計</li></ul><h3 id=122-邏輯閘層級>1.2.2 邏輯閘層級<a hidden class=anchor aria-hidden=true href=#122-邏輯閘層級>#</a></h3><ul><li>Gate Level</li><li>使用基本的邏輯閘元件</li><li>AND、OR、NOT</li><li>邏輯電路圖</li></ul><h3 id=123-資料流層級>1.2.3 資料流層級<a hidden class=anchor aria-hidden=true href=#123-資料流層級>#</a></h3><ul><li>Data Flow Level</li><li>描述電路中資料的處理方式</li><li>資料如何在電路中運算及傳送</li><li>輸入持續驅動輸出</li><li>運算式<ul><li>如：<code>out = a + b + c</code></li></ul></li></ul><h3 id=124-行為模型>1.2.4 行為模型<a hidden class=anchor aria-hidden=true href=#124-行為模型>#</a></h3><ul><li>Behavior Level</li><li>Verilog 最高階的層次模型</li><li>不需考慮硬體元件的特型，只需放在模組的功能描述</li><li>很像 C 語言</li><li>合成軟體工具</li></ul><h3 id=125-結構式模型>1.2.5 結構式模型<a hidden class=anchor aria-hidden=true href=#125-結構式模型>#</a></h3><ul><li>Structure Level</li><li>引用硬體模組的模式</li><li>類似邏輯閘層次模型</li><li>支援階層式設計法<ul><li>將複雜電路分為層狀結構</li><li>架構上類似樹狀結構<ul><li>Bottom-up：元件→子模組→設計目標</li><li>Top-Down：設計目標→子模組→元件</li><li>Mixed：設計目標→子模組←元件(常用於大型複雜系統)<ul><li>\(
\boxed{\text{Full Adder}}
\begin{cases}
\boxed{\text{Half Adder}}
\begin{cases}
\boxed{\text{XOR}}\\
\boxed{\text{AND}}
\end{cases}\\
\boxed{\text{Half Adder}}
\begin{cases}
\boxed{\text{XOR}}\\
\boxed{\text{AND}}
\end{cases}\\
\boxed{\text{OR}}
\end{cases}\\
\text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件}
\)</li></ul></li></ul></li></ul></li></ul><h2 id=13-verilog-語法詞彙>1.3 Verilog 語法詞彙<a hidden class=anchor aria-hidden=true href=#13-verilog-語法詞彙>#</a></h2><ul><li>由一連串的標記(token)所組成<ul><li>識別字(identifiers)</li><li>關鍵字(keywords)</li><li>字串(strings)</li><li>註解(comments)</li><li>空白(whitespace)</li><li>數值(numbers)</li></ul></li></ul><h3 id=131-識別字identifiers>1.3.1 識別字(identifiers)<a hidden class=anchor aria-hidden=true href=#131-識別字identifiers>#</a></h3><ul><li>描述電路行為所使用的自訂物件<ul><li>不違反命名規則，工程師自行定義的物件名稱</li></ul></li><li>命名規則<ul><li>字母、數字、底線<code>_</code>或是錢字號<code>$</code>所組合而成。</li><li>開頭只能使用字母或底線。</li><li>識別字是有<strong>大小寫</strong>之分的。</li></ul></li><li>舉例<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Shift_reg_b         (Valid)
</span></span><span style=display:flex><span>_bus123             (Valid)
</span></span><span style=display:flex><span>$error_condition    (Invalid)
</span></span><span style=display:flex><span>NT$899              (Valid)
</span></span><span style=display:flex><span>3_bit_data          (Invalid)
</span></span></code></pre></div></li></ul><h3 id=132-關鍵字keywords>1.3.2 關鍵字(keywords)<a hidden class=anchor aria-hidden=true href=#132-關鍵字keywords>#</a></h3><ul><li>描述電路語法所保留的一組特殊名稱的標記</li><li>定義語言的結構來描述電路<ul><li>輸入(input)、輸出(output)</li><li>資料型態、電路行為</li></ul></li><li>所有關鍵字都必須使用小寫表示</li><li>不可當作識別字使用</li><li>常見關鍵字
\(\begin{array}{|l|l|l|l|l|l|}\hline
\text{always}&\text{and}&\text{assign}&\text{begin}&\text{buf}&\text{bufif0}\\\hline
\text{bufif1}&\text{case}&\text{casex}&\text{casez}&\text{cmos}&\text{default}\\\hline
\text{defparam}&\text{else}&\text{end}&\text{endcase}&\text{endfunction}&\text{endmodule}\\\hline
\text{endtask}&\text{event}&\text{for}&\text{forever}&\text{fork}&\text{function}\\\hline
\text{highz0}&\text{highz1}&\text{if}&\text{initial}&\text{inout}&\text{input}\\\hline
\text{integer}&\text{join}&\text{module}&\text{nand}&\text{negedge}&\text{nmos}\\\hline
\text{nor}&\text{not}&\text{notif0}&\text{notif1}&\text{or}&\text{output}\\\hline
\text{parameter}&\text{pmos}&\text{posedge}&\text{pull0}&\text{pull1}&\text{pulldown}\\\hline
\text{pullup}&\text{rcmos}&\text{real}&\text{realtime}&\text{reg}&\text{repeat}\\\hline
\text{rnmos}&\text{rpmos}&\text{rtran}&\text{rtranif0}&\text{rtranif1}&\text{strong0}\\\hline
\text{string1}&\text{supply0}&\text{supply1}&\text{task}&\text{time}&\text{tran}\\\hline
\text{tranif0}&\text{tranif1}&\text{tri}&\text{tri0}&\text{tri1}&\text{triand}\\\hline
\text{trior}&\text{trireg}&\text{wait}&\text{wand}&\text{weak0}&\text{weak1}\\\hline
\text{while}&\text{wire}&\text{wor}&\text{xnor}&\text{xor}\\\hline
\end{array}\)</li></ul><h3 id=133-字串strings>1.3.3 字串(strings)<a hidden class=anchor aria-hidden=true href=#133-字串strings>#</a></h3><ul><li>一連串字元(character)組成的單一個體</li><li>可含有字母、數字、及一些特殊字元</li><li>字串的所有字元必須在同一行上，並在<strong>雙引號</strong>之間</li></ul><h3 id=134-註解comments>1.3.4 註解(comments)<a hidden class=anchor aria-hidden=true href=#134-註解comments>#</a></h3><ul><li>程式碼中加入說明文字<ul><li>可讀性(readability)</li><li>文件化(documentation)</li><li>版權宣告(license declaration)</li></ul></li><li>以<code>//</code>開頭的單行註解(one-line comment)</li><li>以<code>/*</code>為開頭，並以<code>*/</code>為結尾的多行註解(multiple-line comment)</li><li>多行註解不支援巢狀結構</li></ul><h3 id=135-空白whitespace>1.3.5 空白(whitespace)<a hidden class=anchor aria-hidden=true href=#135-空白whitespace>#</a></h3><ul><li>區隔不同物件</li><li>空格(blank spaces，\b)</li><li>欄位(tabs，\t)</li><li>換行(newlines，\n)</li><li>除字串內空白，註解與空白在編譯與合成時會被忽略</li></ul><h3 id=136-數值numbers>1.3.6 數值(numbers)<a hidden class=anchor aria-hidden=true href=#136-數值numbers>#</a></h3><ul><li>Verilog 有兩種數值表示法<ul><li>固定長度(sized): 定義位元寬度<ul><li><code>&lt;size>'&lt;bsase format>&lt;number></code><ul><li><code>&lt;size></code>：十進位來表示此數的位元數(bits)</li><li><code>&lt;base format></code>：定義進制<ul><li><code>'H</code>|<code>'h</code>：十六進制</li><li><code>'D</code>|<code>'d</code>：十進制</li><li><code>'O</code>|<code>'p</code>：八進制</li><li><code>'B</code>|<code>'b</code>：二進制</li></ul></li><li><code>&lt;number></code>：用<code>&lt;base format></code>來表示數值</li><li>若為負號，將<code>-</code>放在<code>&lt;size></code>前面</li></ul></li><li>舉例：<ul><li><code>18'h47CB</code>：18 bits 的十六進位數 47CB</li><li><code>13'h47CB</code>：13 bits 的十六進位數(因未給定高位元自動補0) 7CB</li><li><code>12'd1023</code>：12 bits 的十進位數 1023</li><li><code>9'o723</code>：9 bits 的八進位數 723</li><li><code>5'b11101</code>：5bits 的二進位數 11101</li><li><code>5'b1xx01</code>：含有 unknown values 的表示法</li></ul></li></ul></li><li>不定長度(unsized): 未定義位元寬度<ul><li>&lsquo;<code>&lt;base format>&lt;number</code><ul><li>不使用<code>&lt;size></code>規定位元長度</li><li>使用 HDL 編譯器內定的長度(32bit的寬度)</li><li>沒有寫明<code>&lt;base format></code>，則<strong>內定為十進制</strong></li></ul></li><li>舉例：<ul><li><code>'h47CB</code>：32 bits 的十六進位數 47CB</li><li><code>1023</code>：32 bits 的十進位數 1023</li><li><code>'o723</code>：32 bits 的八進位數 723</li><li><code>'b11101</code>：32 bits 的二進位數 11101</li></ul></li></ul></li></ul></li><li>Verilog 有四種數值位準(value level)<ul><li>\(\begin{array}{|c|l|}\hline
\text{數值位準}&\text{實際電路狀態}\\\hline
\text{0}&\text{邏輯0，假(false)，接地}\\\hline
\text{1}&\text{邏輯1，真(true)，接壓電源}\\\hline
\text{x}&\text{不確定值(unknown value)}\\\hline
\text{z}&\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\hline
\end{array}
\)</li></ul></li></ul><h2 id=14-verilog-資料物件與型態>1.4 Verilog 資料物件與型態<a hidden class=anchor aria-hidden=true href=#14-verilog-資料物件與型態>#</a></h2><ul><li>資料物件(data objects)<ul><li>描述行為過程中所使用的訊號載具</li><li>一個物件經過處理再傳到另一個物件</li></ul></li><li>資料型態(data type)<ul><li>定義資料物件的類型</li><li>接線、暫存器、參數等</li></ul></li></ul><h3 id=141-接線nets>1.4.1 接線(Nets)<a hidden class=anchor aria-hidden=true href=#141-接線nets>#</a></h3><ul><li>接線(nets)是連接實體元件的連接線</li><li>要被驅動才能改變其內部的值</li><li>最主要的關鍵字是 <code>wire</code><ul><li>一個位元的純量(scalar)</li><li>多位元長度的向量(vector)</li><li>內定值為 <code>z</code>(高阻抗、浮接)</li></ul></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>wire</span> w;         <span style=color:#75715e>// 宣告一條接線，命名為w，內定預設值為z
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>wire</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>;  <span style=color:#75715e>// 宣告一條接線，命名為x，並指定x為邏輯0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>wire</span> a, b, c    <span style=color:#75715e>// 宣告三條接線，命名為a, b, c
</span></span></span></code></pre></div></li></ul><h3 id=142-暫存器registers>1.4.2 暫存器(Registers)<a hidden class=anchor aria-hidden=true href=#142-暫存器registers>#</a></h3><ul><li>抽象的資料儲存物件(有別於實體暫存器 D flip-flop)</li><li>保留一個數值直到下一次指定新值為止</li><li>觀念類似 C 語言中的變數</li><li>主要的關鍵字是 <code>reg</code><ul><li>一個位元的純量(scalar)</li><li>多位元長度的向量(vector)</li><li>內定值為 <code>x</code>(未知)</li></ul></li><li>\(\begin{array}{|l|l|}\hline
\text{reg}&\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\hline
\text{integer}&\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\
&\text{算術運算產生2補數結果(2&rsquo;s complement results))}\\\hline
\text{real}&\text{雙倍精確度之有號浮點數}\\
&\text{(signed floating-point variable with double precision)}\\\hline
\text{time}&\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\hline
\end{array}\)<ul><li>設計電路請以<code>reg</code>為主，其他類型合成器可能不支援。</li></ul></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>reg</span> a;          <span style=color:#75715e>// 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> x, y;       <span style=color:#75715e>// 宣告 2 個宣存器，命名為 x, y
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>integer</span> count;  <span style=color:#75715e>// 宣告 1 個整數為 count，值可以為正負
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>real</span> fraction;  <span style=color:#75715e>// 宣告 1 個浮點數為 fraction，值含小數點
</span></span></span></code></pre></div></li></ul><h3 id=143-純量與向量scalar-and-vector>1.4.3 純量與向量(scalar and vector)<a hidden class=anchor aria-hidden=true href=#143-純量與向量scalar-and-vector>#</a></h3><ul><li>純量(scalar)<ul><li>一個位元的物件</li></ul></li><li>向量(vector)<ul><li>多個位元的物件</li></ul></li><li>接線(ex. wire) 與 reg<ul><li>內定一位元</li><li><code>[大數字:小數字]</code>、<code>[小數字:大數字]</code>→<code>[MSB:LSB]</code></li></ul></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>wire</span> a;         <span style=color:#75715e>// 宣告 1 個 1-bits 接線
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] x;   <span style=color:#75715e>// 宣告 1 個 5-bits 接線
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> b;          <span style=color:#75715e>// 宣告 1 個 1-bits 暫存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>0</span><span style=color:#f92672>:</span><span style=color:#ae81ff>7</span>] y;    <span style=color:#75715e>// 宣告 1 個 8-bits 暫存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] z;   <span style=color:#75715e>// 宣告 1 個 32-bits 暫存器
</span></span></span></code></pre></div></li></ul><h3 id=144-陣列array>1.4.4 陣列(Array)<a hidden class=anchor aria-hidden=true href=#144-陣列array>#</a></h3><ul><li>多個暫存器、接線的聚合體</li><li>索引值(index)定義聚合體中的個別物件</li><li>支援多維度的陣列</li><li>記憶體(memory)、暫存器檔案(register file)</li><li>陣列中暫存器、接線的個數<ul><li><code>[大數字:小數字]</code>、<code>[小數字:大數字]</code></li></ul></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#75715e>// mem_block 是一個包含 128 個暫存器的陣列，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 每個暫存器皆為 32 位元寬
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] mem_block [<span style=color:#ae81ff>127</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span><span style=color:#75715e>// mem_2D 是一個 2 維 4x64 的暫存器陣列，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 每個暫存器皆為 8 位元寬
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] mem_2D [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>63</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span></code></pre></div></li></ul><h2 id=145-參數parameter>1.4.5 參數(parameter)<a hidden class=anchor aria-hidden=true href=#145-參數parameter>#</a></h2><ul><li>定義編譯合成電路時的常數</li><li>每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路</li><li>重複使用</li><li>關鍵字 <code>parameter</code></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>parameter</span> width <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>wire</span> [width<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b;  <span style=color:#75715e>// 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [width<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] y;      <span style=color:#75715e>// 暫存器 y 的位元寬度，會隨著參數值的改變而變動
</span></span></span></code></pre></div></li></ul><h2 id=15-模組module埠port>1.5 模組(Module)、埠(Port)<a hidden class=anchor aria-hidden=true href=#15-模組module埠port>#</a></h2><h3 id=151-模組module>1.5.1 模組(Module)<a hidden class=anchor aria-hidden=true href=#151-模組module>#</a></h3><ul><li>一個電路區塊、可以由其他模組組成</li><li>連接模組時<ul><li>考慮模組的輸入與輸出介面</li><li>不需要考慮模組內部的詳細電路</li></ul></li><li>電路設計時<ul><li>只修改模組內部電路</li><li>不會改變電路外部及周遭的模組</li></ul></li><li>模組內部的電路描述可包含<ul><li>訊號資料型態宣告</li><li>引用其他模組(邏輯閘)</li><li><code>assign</code> 資料處理模型之描述</li><li><code>always</code> 行為模型之描述</li><li><strong>函數(function)</strong> 與 <strong>任務(task)</strong></li><li>除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為</li></ul></li><li>模組宣告<ul><li>以關鍵字 <code>module</code> 為開頭，在其後加一個識別用的模組名稱(module name)</li><li>再來是<strong>輸入與輸出埠列</strong>(module terminal list)和埠列宣告，接著是模組內部關於電路的描述</li><li>以關鍵字 <code>endmodule</code> 做為模組結尾</li><li>支援階層`式的設計概念</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> module_name(terminal_list)
</span></span><span style=display:flex><span>port_declaration(...)
</span></span><span style=display:flex><span>param_declaration(optional)
</span></span><span style=display:flex><span>data_type_declaration(<span style=color:#66d9ef>wire</span>, <span style=color:#66d9ef>reg</span>)
</span></span><span style=display:flex><span>other_module(logic_gate)
</span></span><span style=display:flex><span><span style=color:#66d9ef>assign</span> data_flow_model
</span></span><span style=display:flex><span><span style=color:#66d9ef>always</span> behavior_model
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span>, <span style=color:#66d9ef>task</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div></li></ul><h3 id=152-埠port>1.5.2 埠(port)<a hidden class=anchor aria-hidden=true href=#152-埠port>#</a></h3><ul><li>終端點、模組與外界溝通的介面接點(門)</li><li>一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通</li><li>若模組與外界不需要溝通，則埠列也就不存在(封閉系統)<ul><li>測試環境(test bench)</li></ul></li><li>埠的宣告<ul><li>埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。</li><li>埠的宣告型態內定為接線(net)的 <code>wire</code>，若需要將訊號儲存起來則埠號型態須宣告成暫存器 <code>reg</code>。</li><li>輸入埠和雙向埠只能是接線(net)，<strong>不可宣告成暫存器</strong>。</li><li>輸出埠可以宣告成接線(net)或暫存器。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> full_adder(a, b, carry, sum);    <span style=color:#75715e>// 埠列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>input</span>  [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b;                      <span style=color:#75715e>// 輸入埠(4位元向量)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>input</span>  carry                            <span style=color:#75715e>// 輸入埠(1位元純量)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum;                       <span style=color:#75715e>// 輸出埠(5位元向量)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span>    [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum;                       <span style=color:#75715e>// 因輸出sum需儲存資料，故宣告成暫存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div></li></ul><h2 id=16-邏輯閘層次模型>1.6 邏輯閘層次模型<a hidden class=anchor aria-hidden=true href=#16-邏輯閘層次模型>#</a></h2><ul><li>利用關鍵字即可引用基本的邏輯閘元件</li><li>基本的邏輯閘關鍵字<ul><li><code>and</code></li><li><code>nand</code></li><li><code>or</code></li><li><code>nor</code></li><li><code>not</code></li><li><code>xor</code></li><li><code>xnor</code></li></ul></li></ul><h3 id=161-多個輸入邏輯閘multiple-input-gates>1.6.1 多個輸入邏輯閘(Multiple-Input Gates)<a hidden class=anchor aria-hidden=true href=#161-多個輸入邏輯閘multiple-input-gates>#</a></h3><ul><li><code>and</code>、<code>nand</code>、<code>or</code>、<code>nor</code>、<code>xor</code>、<code>xnor</code></li><li>具有多個純量(scalar)的輸入，但是只有一個純量的輸出</li><li><strong>多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面</strong>
輸出必須透過接線(wire)連接，輸入無規定</li><li>多個輸入邏輯閘的別名可以加或是不加</li><li>使用方法<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span>gate_type instance(out, in_1, in_2, in_3, ..., in_n);
</span></span><span style=display:flex><span>gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n),
</span></span><span style=display:flex><span>          inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n),
</span></span><span style=display:flex><span>          inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n),
</span></span><span style=display:flex><span>          ...
</span></span><span style=display:flex><span>          inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn);
</span></span></code></pre></div></li><li>\(\begin{array}{ccc}
\underbrace{\text{a, b, c, d}}_{\text{輸入}}
\rightarrow
\boxed{\text{Multiple-Input Gate}}
\rightarrow
\underbrace{\text{e}} _{\text{輸出}}
\end{array}
\)</li><li>\(\text{and\quad a1(}
\underbrace{\text{e}}_{\text{輸出}}
\text{, }
\underbrace{\text{a, b, c, d}} _{\text{輸入}}
\text{);}
\)</li></ul><h3 id=162-多個輸出邏輯閘multiple-output-gates>1.6.2 多個輸出邏輯閘(Multiple-Output Gates)<a hidden class=anchor aria-hidden=true href=#162-多個輸出邏輯閘multiple-output-gates>#</a></h3><ul><li><p><code>not</code>、<code>buf</code></p></li><li><p>具有一個或是多個純量(scalar)的輸出，但是只有一個純量的輸入</p></li><li><p><strong>多個輸出邏輯閘的輸出是放在埠列(port list)的前面位置，而輸入則是放在列後面位置</strong></p><ul><li>輸出必須透過接線(wire)連接，輸入無規定</li></ul></li><li><p>多個輸出邏輯閘的別名可以加或是不加</p></li><li><p>使用方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span>gate_type instance(out_1, out_2, out_3, ..., out_n, in);
</span></span><span style=display:flex><span>gate_type inst_1(out1_1, out1_2, out1_3, ..., out1_n, in1),
</span></span><span style=display:flex><span>          inst_2(out2_1, out2_2, out2_3, ..., out2_n, in2),
</span></span><span style=display:flex><span>          inst_3(out3_1, out3_2, out3_3, ..., out3_n, in3),
</span></span><span style=display:flex><span>          ...
</span></span><span style=display:flex><span>          inst_m(out_m1, out_m2, out_m3, ..., out_mn, in_m);
</span></span></code></pre></div></li><li><p>\(\begin{array}{ccc}
\underbrace{\text{d}}_{\text{輸入}}
\rightarrow
\boxed{\text{Multiple-Output Gate}}
\rightarrow
\underbrace{\text{a, b, c}} _{\text{輸出}}
\end{array}
\)</p></li><li><p>\(\text{not\quad n1(}
\underbrace{\text{a, b, c}}_{\text{輸出}}
\text{, }
\underbrace{\text{d}} _{\text{輸入}}
\text{);}
\)</p></li><li><p>邏輯閘層次模型範例</p><ul><li><img alt=sample1 loading=lazy src=/Verilog/images/sample1.png><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> and_or_gate(in1, in2, in3, in4, out;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>input</span>  in1, in2, in3, in4;
</span></span><span style=display:flex><span><span style=color:#66d9ef>output</span> out;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>wire</span>   w1, w2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>and</span> a1(w1, in1, in2);
</span></span><span style=display:flex><span><span style=color:#66d9ef>and</span> a2(w2, in3, in4);
</span></span><span style=display:flex><span><span style=color:#66d9ef>or</span>  o1(out, w1, w2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div></li></ul></li></ul><h1 id=2-實作>2 實作<a hidden class=anchor aria-hidden=true href=#2-實作>#</a></h1><p><a href=https://github.com/intervalrain/Verilog>Implementation in Github</a></p><h3 id=1-hdlbits>1. <a href=/verilog/hdlbits1/>HDLbits</a><a hidden class=anchor aria-hidden=true href=#1-hdlbits>#</a></h3><h3 id=2-verilog>2. <a href=/verilog/hdlbits2/>Verilog</a><a hidden class=anchor aria-hidden=true href=#2-verilog>#</a></h3><h3 id=3-circuits>3. <a href=/verilog/hdlbits3/>Circuits</a><a hidden class=anchor aria-hidden=true href=#3-circuits>#</a></h3><h3 id=4-verification-reading-simulations>4. <a href=/verilog/hdlbits4/>Verification: Reading Simulations</a><a hidden class=anchor aria-hidden=true href=#4-verification-reading-simulations>#</a></h3><h3 id=5-verification-writing-testbenches>5. <a href=/verilog/hdlbits5/>Verification: Writing Testbenches</a><a hidden class=anchor aria-hidden=true href=#5-verification-writing-testbenches>#</a></h3><h3 id=6-cs450>6. <a href=/verilog/hdlbits6/>CS450</a><a hidden class=anchor aria-hidden=true href=#6-cs450>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/vhdl/>VHDL</a></li><li><a href=https://intervalrain.github.io/tags/programming/>Programming</a></li><li><a href=https://intervalrain.github.io/tags/verilog/>Verilog</a></li><li><a href=https://intervalrain.github.io/tags/logic-design/>Logic Design</a></li></ul></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>