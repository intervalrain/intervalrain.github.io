<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VHDL] HDLbits 3 - Circuits | Rain Hu's Workspace</title><meta name=keywords content="VHDL,Programming,Verilog,HDLbits"><meta name=description content="Verilog tutorial"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="[VHDL] HDLbits 3 - Circuits"><meta property="og:description" content="Verilog tutorial"><meta property="og:type" content="article"><meta property="og:url" content="https://intervalrain.github.io/posts/verilog/hdlbits3/"><meta property="og:image" content="https://intervalrain.github.io/images/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-28T00:10:20+08:00"><meta property="article:modified_time" content="2022-05-28T00:10:20+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[VHDL] HDLbits 3 - Circuits"><meta name=twitter:description content="Verilog tutorial"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[VHDL] HDLbits 3 - Circuits","item":"https://intervalrain.github.io/posts/verilog/hdlbits3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VHDL] HDLbits 3 - Circuits","name":"[VHDL] HDLbits 3 - Circuits","description":"Verilog tutorial","keywords":["VHDL","Programming","Verilog","HDLbits"],"articleBody":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates Wire module top_module ( input in, output out); assign out = in; endmodule GND module top_module ( output out); assign out = 1'b0; endmodule NOR module top_module ( input in1, input in2, output out); assign out = ~(in1|in2); endmodule Another Gate module top_module ( input in1, input in2, output out); assign out = in1 \u0026 (~in2); endmodule Two gates module top_module ( input in1, input in2, input in3, output out); wire w1; assign w1 = ~(in1^in2); assign out = w1^in3; endmodule More logic gates module top_module( input a, b, output out_and, output out_or, output out_xor, output out_nand, output out_nor, output out_xnor, output out_anotb ); assign out_and = a \u0026 b; assign out_or = a | b; assign out_xor = a ^ b; assign out_nand = ~(a \u0026 b); assign out_nor = ~(a | b); assign out_xnor = ~(a ^ b); assign out_anotb = a \u0026 (~b); // and(out_and, a, b); // or(out_or, a, b); // xor(out_xor, a, b); // nand(out_nand, a, b); // nor(out_nor, a, b); // xnor(out_xnor, a, b); // and(out_anotb, a , ~b); endmodule 7420 chip module top_module ( input p1a, p1b, p1c, p1d, output p1y, input p2a, p2b, p2c, p2d, output p2y ); assign p1y = ~(p1a \u0026 p1b \u0026 p1c \u0026 p1d); assign p2y = ~(p2a \u0026 p2b \u0026 p2c \u0026 p2d); endmodule\\ Truth tables \\(\\begin{array}{|c|ccc|c|}\\hline \\text{Row}\u0026\u0026\\text{Inputs}\u0026\u0026\\text{Outputs}\\\\\\hline \\text{number}\u0026\\text{x3}\u0026\\text{x2}\u0026\\text{x1}\u0026\\text{f}\\\\\\hline 0\u00260\u00260\u00260\u00260\\\\\\hline 1\u00260\u00260\u00261\u00260\\\\\\hline 2\u00260\u00261\u00260\u00261\\\\\\hline 3\u00260\u00261\u00261\u00261\\\\\\hline 4\u00261\u00260\u00260\u00260\\\\\\hline 5\u00261\u00260\u00261\u00261\\\\\\hline 6\u00261\u00261\u00260\u00260\\\\\\hline 7\u00261\u00261\u00261\u00261\\\\\\hline \\end{array module top_module( input x3, input x2, input x1, output f ); assign f = ((~x3)\u0026x2)|(x3\u0026x1); endmodule Two-bit equality Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0. module top_module ( input [1:0] A, input [1:0] B, output z ); assign z = (A == B); endmodule Simple circuit A module top_module (input x, input y, output z); assign z = (x^y) \u0026x; endmodule Simple circuit B module top_module ( input x, input y, output z ); assign z = (x==y); // assign z = ~(x ^ y); endmodule Combine circuits A and B module top_module (input x, input y, output z); wire o1, o2, o3, o4; A ia1(x,y,o1); B ib1(x,y,o2); A ia2(x,y,o3); B ib2(x,y,o4); assign z = (o1|o2)^(o3\u0026o4); endmodule module A( input x, y, output z); assign z = (x ^ y) \u0026 x; endmodule module B( input x, y, output z); assign z = x ~^ y; endmodule Ringer Suppose you are designing a circuit to control a cellphone’s ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. Design hint: When designing circuits, one often has to think of the problem “backwards”, starting from the outputs then working backwards towards the inputs. This is often the opposite of how one would think about a (sequential, imperative) programming problem, where one would look at the inputs first then decide on an action (or output). For sequential programs, one would often think “If (inputs are ___ ) then (output should be ___ )”. On the other hand, hardware designers often think “The (output should be ___ ) when (inputs are ___ )”. The above problem description is written in an imperative form suitable for software programming (if ring then do this), so you must convert it to a more declarative form suitable for hardware implementation (assign ringer = ___). Being able to think in, and translate between, both styles is one of the most important skills needed for hardware design. module top_module ( input ring, input vibrate_mode, output ringer, // Make sound output motor // Vibrate ); assign ringer = ring \u0026 (~vibrate_mode); assign motor = ring \u0026 (vibrate_mode); endmodule Thermostat A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. 畫出真值表\n\\(\\begin{array}{|cccc|ccc|}\\hline \\text{mode}\u0026\\text{too\\_cold}\u0026\\text{too\\_hot}\u0026\\text{fan on}\u0026\\text{heater}\u0026\\text{aircon}\u0026\\text{fan}\\\\\\hline 0\u00260\u00260\u00260\u00260\u00260\u00260\\\\\\hline 0\u00260\u00260\u00261\u00260\u00260\u00261\\\\\\hline 0\u00260\u00261\u00260\u00260\u00261\u00261\\\\\\hline 0\u00260\u00261\u00261\u00260\u00261\u00261\\\\\\hline 0\u00261\u00260\u00260\u00260\u00260\u00260\\\\\\hline 0\u00261\u00260\u00261\u00260\u00260\u00261\\\\\\hline 0\u00261\u00261\u00260\u00260\u00261\u00261\\\\\\hline 0\u00261\u00261\u00261\u00260\u00261\u00261\\\\\\hline 1\u00260\u00260\u00260\u00260\u00260\u00260\\\\\\hline 1\u00260\u00260\u00261\u00260\u00260\u00261\\\\\\hline 1\u00260\u00261\u00260\u00260\u00260\u00260\\\\\\hline 1\u00260\u00261\u00261\u00260\u00260\u00261\\\\\\hline 1\u00261\u00260\u00260\u00261\u00260\u00261\\\\\\hline 1\u00261\u00260\u00261\u00261\u00260\u00261\\\\\\hline 1\u00261\u00261\u00260\u00261\u00260\u00261\\\\\\hline 1\u00261\u00261\u00261\u00261\u00260\u00261\\\\\\hline \\end{array}\\) module top_module ( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan); assign heater = mode \u0026 too_cold; assign aircon = (~mode) \u0026 too_hot; assign fan = heater|aircon|fan_on; endmodule 3-bit population count A “population count” circuit counts the number of ‘1’s in an input vector. Build a population count circuit for a 3-bit input vector. module top_module( input [2:0] in, output [1:0] out ); always @(*) begin out = 0; for (int i = 0; i \u003c= 2; i++) begin out += in[i]; end end endmodule 此解會產生鎖存器，不建議使用。 Gates and vectors You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are ‘1’. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don’t need to know out_both[3]. out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are ‘1’. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don’t need to know out_any[0]. out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]’s neighbour to the left is in[0]. module top_module( input [3:0] in, output [2:0] out_both, output [3:1] out_any, output [3:0] out_different ); assign out_both[2:0] = in[2:0] \u0026 in[3:1]; assign out_any[3:1] = in[3:1] | in[2:0]; assign out_different[3:0] = in[3:0] ^ {in[0], in[3:1]}; // always @(*) begin // out_different[3] = (in[3] != in[0]); // for (int i = 0; i \u003c= 2; i++) begin // out_both[i] = in[i] \u0026 in[i+1]; // out_any[i+1] = in[i+1] | in[i]; // out_different[i] = (in[i] != in[i+1]); // end // end endmodule Even longer vectors You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are ‘1’. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don’t need to know out_both[99]. out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are ‘1’. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don’t need to know out_any[0]. out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]’s neighbour to the left is in[0]. module top_module( input [99:0] in, output [98:0] out_both, output [99:1] out_any, output [99:0] out_different ); assign out_both[98:0] = in[98:0] \u0026 in[99:1]; assign out_any[99:1] = in[99:1] | in[98:0]; assign out_different[99:0] = in[99:0] ^ {in[0], in[99:1]}; endmodule 3.1.2 Multiplexers 2-to-1 multiplexer Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b. module top_module( input a, b, sel, output out ); assign out = sel ? b : a; endmodule 2-to-1 bus multiplexer Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b. module top_module( input [99:0] a, b, input sel, output [99:0] out ); assign out = sel ? b : a; endmodule 9-to-1 multiplexer Create a 16-bit 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to ‘1’. module top_module( input [15:0] a, b, c, d, e, f, g, h, i, input [3:0] sel, output [15:0] out ); always @(*) begin case(sel) 4'd0: out = a; 4'd1: out = b; 4'd2: out = c; 4'd3: out = d; 4'd4: out = e; 4'd5: out = f; 4'd6: out = g; 4'd7: out = h; 4'd8: out = i; default: out = '1; // special literal syntax with all bits set to 1 endcase end endmodule 256-to-1 multiplexer Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should be select in[0], sel1 selectes bits in[1], sel=2 selects bits in[2], etc. module top_module( input [255:0] in, input [7:0] sel, output out ); assign out = in[sel]; endmodule 256-to-1 4-bit multiplexer Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0],sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc. module top_module( input [1023:0] in, input [7:0] sel, output [3:0] out ); assign out = in[sel*4+:4]; // special syntax // assign out = in[sel*4+3-:4]; // assign out = {in[sel*4+3],in[sel*4+2],in[sel*4+1],in[sel*4+0]}; endmodule 3.1.3 Arithmetic Circuits Half adder Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out. module top_module( input a, b, output cout, sum ); assign {cout, sum} = a + b; endmodule Full adder Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and a carry-out. module top_module( input a, b, cin, output cout, sum ); assign {cout, sum} = a + b + cin; endmodule 3-bit binary adder Now that you know how to build a full adder, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see. module top_module( input [2:0] a, b, input cin, output [2:0] cout, output [2:0] sum ); fulladder f1(a[0], b[0], cin, cout[0], sum[0]); fulladder f2(a[1], b[1], cout[0], cout[1], sum[1]); fulladder f3(a[2], b[2], cout[1], cout[2], sum[2]); endmodule module fulladder( input a, b, cin, output cout, sum); assign {cout, sum} = a + b + cin; endmodule Adder Implement the following circuit: module top_module ( input [3:0] x, input [3:0] y, output [4:0] sum); // assign sum = x + y; wire [2:0] cout; FA f1(x[0], y[0], 0, cout[0], sum[0]); FA f2(x[1], y[1], cout[0], cout[1], sum[1]); FA f3(x[2], y[2], cout[1], cout[2], sum[2]); FA f4(x[3], y[3], cout[2], sum[4], sum[3]); endmodule module FA ( input a, b, cin, output cout, sum); assign {cout, sum} = a + b + cin; endmodule Signed addition overflow Assume that you have two 8-bit 2’s complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred. module top_module ( input [7:0] a, input [7:0] b, output [7:0] s, output overflow ); assign s = a + b; assign overflow = (a[7] == b[7] \u0026\u0026 a[7] != s[7]) ? 1 : 0; endmodule 100-bit binary adder Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. module top_module( input [99:0] a, b, input cin, output cout, output [99:0] sum); assign {cout, sum} = cin + a + b; endmodule 4-digit BCD adder You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out. module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.\nmodule top_module ( input [15:0] a, b, input cin, output cout, output [15:0] sum ); wire [2:0] wl; bcd_fadd u0 (a[ 3: 0], b[ 3: 0], cin, wl[0], sum[ 3: 0]); bcd_fadd u1 (a[ 7: 4], b[ 7: 4], wl[0], wl[1], sum[ 7: 4]); bcd_fadd u2 (a[11: 8], b[11: 8], wl[1], wl[2], sum[11: 8]); bcd_fadd u3 (a[15:12], b[15:12], wl[2], cout, sum[15:12]); endmodule 3.1.4 Karnaugh Map to Circuit Kmap1 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, output out ); assign out = a | b | c; endmodule Kmap2 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); // a'd' + b'c' + acd + a'bc wire w1, w2, w3, w4; assign w1 = (~a)\u0026(~d); assign w2 = (~b)\u0026(~c); assign w3 = a\u0026c\u0026d; assign w4 = (~a)\u0026b\u0026c; assign out = w1|w2|w3|w4; endmodule Kmap3 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); // a + b'c assign out = a | (~b\u0026c); endmodule Kmap4 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); always @(*) begin if (a == b \u0026\u0026 c != d) out = 1; else if (a != b \u0026\u0026 c == d) out = 1; else out = 0; end endmodule Minimum SOP and POS A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form. module top_module ( input a, input b, input c, input d, output out_sop, output out_pos ); // f = d3 + m7 + d11 + m15 + m2 // f = cd + a'b'c assign out_sop = (c \u0026 d) | (~a \u0026 ~b \u0026 c); // f' = m0 + m1 + m4 + m5 + m6 + d8 + m9 + m10 + d11 + d12 + m13 + m14 // f' = c' + ab' + bd' // f = (c)(a'+b)(b'+d) assign out_pos = c \u0026 (~a | b) \u0026 (~b | d); endmodule Karnaugh map Consider the function f shown in the Karnaugh map below. Implement this function. d is don’t-care, which means you may choose to output whatever value is convenient. module top_module ( input [4:1] x, output f ); // x[2]x[4] + x[1]'x[3] assign f = (x[2] \u0026 x[4]) | (~x[1] \u0026 x[3]); endmodule Karnaugh map Consider the function f shown in the Karnaugh map below. Implement this function. (The original exam question asked for simplified SOP and POS forms of the function.) module top_module ( input [4:1] x, output f ); // x[2]'x[4]' + x[1]'x[3] + x[2]x[3]x[4] assign f = (~x[2] \u0026 ~x[4]) | (~x[1] \u0026 x[3]) | (x[2] \u0026 x[3] \u0026 x[4]); endmodule K-map implemented with a multiplexer For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below. You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map. (The requirement to use only 2-to-1 multiplexers exists because the original exam question also wanted to test logic function simplification using K-maps and how to synthesize logic functions using only multiplexers. If you wish to treat this as purely a Verilog exercise, you may ignore this constraint and write the module any way you wish.) module top_module ( input c, input d, output [3:0] mux_in ); assign mux_in[0] = c|d; // 0111 assign mux_in[1] = 1'b0; // 0000 assign mux_in[2] = ~d; // 1001 assign mux_in[3] = c\u0026d; // 0010 endmodule 3.2 Sequential Logic 3.2.1 Latches and Flip-Flops D flip-flop A D flip-flop is a circuit that stores a bit and is updated periodically, at the (usually) positive edge of a clock signal. D flip-flops are created by the logic synthesizer when a clocked always block is used (See alwaysblock2). A D + flip-flop is the simplest form of “blob of combinational logic followed by a flip-flop” where the combinational logic portion is just a wire. Create a single D flip-flop. module top_module ( input clk, // Clocks are used in sequential circuits input d, output reg q ); always @(posedge clk) begin q \u003c= d; end endmodule D flip-flops Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input [7:0] d, output [7:0] q ); always @(posedge clk) begin q \u003c= d; end endmodule DFF with reset Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input reset, // Synchronous reset input [7:0] d, output [7:0] q ); always @(posedge clk) begin if (reset) begin q \u003c= 8'b0; end else begin q \u003c= d; end end endmodule DFF with reset value Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk. module top_module ( input clk, input reset, input [7:0] d, output [7:0] q ); always @(negedge clk) begin if (reset) begin q \u003c= 8'h34; end else begin q \u003c= d; end end endmodule DFF with asynchronous reset Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input areset, // active high asynchronous reset input [7:0] d, output [7:0] q ); always @(posedge clk or posedge areset) if (areset) q \u003c= 0; else q \u003c= d; endmodule In Verilog, the sensity list looks strange. The FF’s reset is sensitive to the level of areset, so why does using “posedge areset” work? To see why it works, consider the truth table for all events that change the input signals, assuming clk and areset do not swith at precisely the same time.\n\\(\\begin{array}{|c|c|c|l|}\\hline \\text{clk}\u0026\\text{areset}\u0026\\text{output}\u0026\\text{comment}\\\\\\hline \\text{x}\u0026\\text{0}\\rightarrow\\text{1}\u0026\\text{q}\\leftarrow{0;}\u0026\\text{because areset = 1}\\\\\\hline \\text{x}\u0026\\text{1}\\rightarrow\\text{0}\u0026\\text{no change}\u0026\\text{always block not triggered}\\\\\\hline \\text{0}\\rightarrow\\text{1}\u0026\\text{0}\u0026\\text{q}\\leftarrow{d;}\u0026\\text{not resetting}\\\\\\hline \\text{0}\\rightarrow\\text{1}\u0026\\text{1}\u0026\\text{q}\\leftarrow{0;}\u0026\\text{still resetting, q was 0 before too}\\\\\\hline \\text{1}\\rightarrow\\text{0}\u0026\\text{x}\u0026\\text{no change}\u0026\\text{always block not triggered}\\\\\\hline \\end{array}\\) DFF with byte enable Create 16 D flip-flops. It’s sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input resetn, input [1:0] byteena, input [15:0] d, output [15:0] q ); always @(posedge clk) begin if (resetn == 1'b0) begin q \u003c= 16'd0; end else begin case(byteena) 0: q \u003c= q; 1: q \u003c= {q[15:8], d[7:0]}; 2: q \u003c= {d[15:8], q[7:0]}; 3: q \u003c= d; endcase end end endmodule D Latch Implement the following circuit: Note that this is a latch, so a Quartus warning about hvaing inferred a latch is expected. 對於組合邏輯，if 若沒有補全 else，case 條件不完全，可能會產生 latch。但是如果中間的信號有初值，就不會產生 latch。所以要盡量避免 latch 的產生，避免對時序的危害很大。 module top_module ( input d, input ena, output q); always @(*) begin if (ena == 1'b1) q = d; end endmodule DFFAR Implement the following circuit: module top_module ( input clk, input d, input ar, // asynchronous reset output q); always@(posedge clk or posedge ar) begin if (ar == 1) q \u003c= 0; else q \u003c= d; end endmodule DFFR Implement the following circuit: module top_module ( input clk, input d, input r, // synchronous reset output q); always@(posedge clk) begin if (r == 1) begin q \u003c= 0; end else begin q \u003c= d; end end endmodule DFF+gate Implement the following circuit: module top_module ( input clk, input in, output reg out); always@(posedge clk) begin out \u003c= out ^ in; end endmodule 注意 output 需為 reg 型別。 Mux and DFF Consider the sequential circuit below: Assume that you want to implement hierarchical Verilog code for this circuit, using three instantiations of a submodule that has a flip-flop and multiplexer in it. Write a Verilog module (containing one flip-flop and multiplexer) named top_module for this submodule. module top_module ( input clk, input L, input r_in, input q_in, output reg Q); always@(posedge clk) begin if (L) Q \u003c= r_in; else Q \u003c= q_in; end endmodule Mux and DFF DFF+gate Mux and DFF Mux and DFF DFFs and gates Create circuit from truth table Detect an edge Detect both edges Edge capture register Dual-edge triggered flip-flop 3.2.2 Counters 3.2.3 Shift Registers 3.2.4 More Circuits 3.2.5 Finite State Machines 3.3 Building Larger Circuits ","wordCount":"3743","inLanguage":"en","image":"https://intervalrain.github.io/images/cover.jpg","datePublished":"2022-05-28T00:10:20+08:00","dateModified":"2022-05-28T00:10:20+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/posts/verilog/hdlbits3/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/posts/csharp/csharp title=Csharp><span>Csharp</span></a></li><li><a href=https://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[VHDL] HDLbits 3 - Circuits</h1><div class=post-description>Verilog tutorial</div><div class=post-meta><span title='2022-05-28 00:10:20 +0800 +0800'>May 28, 2022</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/Verilog/HDLbits3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#3-circuits aria-label="3 Circuits">3 Circuits</a><ul><li><a href=#31-combinational-logic aria-label="3.1 Combinational Logic">3.1 Combinational Logic</a><ul><li><a href=#311-basic-gates aria-label="3.1.1 Basic Gates">3.1.1 Basic Gates</a><ul><li><a href=#wire aria-label=Wire>Wire</a></li><li><a href=#gnd aria-label=GND>GND</a></li><li><a href=#nor aria-label=NOR>NOR</a></li><li><a href=#another-gate aria-label="Another Gate">Another Gate</a></li><li><a href=#two-gates aria-label="Two gates">Two gates</a></li><li><a href=#more-logic-gates aria-label="More logic gates">More logic gates</a></li><li><a href=#7420-chip aria-label="7420 chip">7420 chip</a></li><li><a href=#truth-tables aria-label="Truth tables">Truth tables</a></li><li><a href=#two-bit-equality aria-label="Two-bit equality">Two-bit equality</a></li><li><a href=#simple-circuit-a aria-label="Simple circuit A">Simple circuit A</a></li><li><a href=#simple-circuit-b aria-label="Simple circuit B">Simple circuit B</a></li><li><a href=#combine-circuits-a-and-b aria-label="Combine circuits A and B">Combine circuits A and B</a></li><li><a href=#ringer aria-label=Ringer>Ringer</a></li><li><a href=#thermostat aria-label=Thermostat>Thermostat</a></li><li><a href=#3-bit-population-count aria-label="3-bit population count">3-bit population count</a></li><li><a href=#gates-and-vectors aria-label="Gates and vectors">Gates and vectors</a></li><li><a href=#even-longer-vectors aria-label="Even longer vectors">Even longer vectors</a></li></ul></li><li><a href=#312-multiplexers aria-label="3.1.2 Multiplexers">3.1.2 Multiplexers</a><ul><li><a href=#2-to-1-multiplexer aria-label="2-to-1 multiplexer">2-to-1 multiplexer</a></li><li><a href=#2-to-1-bus-multiplexer aria-label="2-to-1 bus multiplexer">2-to-1 bus multiplexer</a></li><li><a href=#9-to-1-multiplexer aria-label="9-to-1 multiplexer">9-to-1 multiplexer</a></li><li><a href=#256-to-1-multiplexer aria-label="256-to-1 multiplexer">256-to-1 multiplexer</a></li><li><a href=#256-to-1-4-bit-multiplexer aria-label="256-to-1 4-bit multiplexer">256-to-1 4-bit multiplexer</a></li></ul></li><li><a href=#313-arithmetic-circuits aria-label="3.1.3 Arithmetic Circuits">3.1.3 Arithmetic Circuits</a><ul><li><a href=#half-adder aria-label="Half adder">Half adder</a></li><li><a href=#full-adder aria-label="Full adder">Full adder</a></li><li><a href=#3-bit-binary-adder aria-label="3-bit binary adder">3-bit binary adder</a></li><li><a href=#adder aria-label=Adder>Adder</a></li><li><a href=#signed-addition-overflow aria-label="Signed addition overflow">Signed addition overflow</a></li><li><a href=#100-bit-binary-adder aria-label="100-bit binary adder">100-bit binary adder</a></li><li><a href=#4-digit-bcd-adder aria-label="4-digit BCD adder">4-digit BCD adder</a></li></ul></li><li><a href=#314-karnaugh-map-to-circuit aria-label="3.1.4 Karnaugh Map to Circuit">3.1.4 Karnaugh Map to Circuit</a><ul><li><a href=#kmap1 aria-label=Kmap1>Kmap1</a></li><li><a href=#kmap2 aria-label=Kmap2>Kmap2</a></li><li><a href=#kmap3 aria-label=Kmap3>Kmap3</a></li><li><a href=#kmap4 aria-label=Kmap4>Kmap4</a></li><li><a href=#minimum-sop-and-pos aria-label="Minimum SOP and POS">Minimum SOP and POS</a></li><li><a href=#karnaugh-map aria-label="Karnaugh map">Karnaugh map</a></li><li><a href=#karnaugh-map-1 aria-label="Karnaugh map">Karnaugh map</a></li><li><a href=#k-map-implemented-with-a-multiplexer aria-label="K-map implemented with a multiplexer">K-map implemented with a multiplexer</a></li></ul></li></ul></li><li><a href=#32-sequential-logic aria-label="3.2 Sequential Logic">3.2 Sequential Logic</a><ul><li><a href=#321-latches-and-flip-flops aria-label="3.2.1 Latches and Flip-Flops">3.2.1 Latches and Flip-Flops</a><ul><li><a href=#d-flip-flop aria-label="D flip-flop">D flip-flop</a></li><li><a href=#d-flip-flops aria-label="D flip-flops">D flip-flops</a></li><li><a href=#dff-with-reset aria-label="DFF with reset">DFF with reset</a></li><li><a href=#dff-with-reset-value aria-label="DFF with reset value">DFF with reset value</a></li><li><a href=#dff-with-asynchronous-reset aria-label="DFF with asynchronous reset">DFF with asynchronous reset</a></li><li><a href=#dff-with-byte-enable aria-label="DFF with byte enable">DFF with byte enable</a></li><li><a href=#d-latch aria-label="D Latch">D Latch</a></li><li><a href=#dffar aria-label=DFFAR>DFFAR</a></li><li><a href=#dffr aria-label=DFFR>DFFR</a></li><li><a href=#dffgate aria-label=DFF+gate>DFF+gate</a></li><li><a href=#mux-and-dff aria-label="Mux and DFF">Mux and DFF</a></li><li><a href=#mux-and-dff-1 aria-label="Mux and DFF">Mux and DFF</a></li><li><a href=#dffgate-1 aria-label=DFF+gate>DFF+gate</a></li><li><a href=#mux-and-dff-2 aria-label="Mux and DFF">Mux and DFF</a></li><li><a href=#mux-and-dff-3 aria-label="Mux and DFF">Mux and DFF</a></li><li><a href=#dffs-and-gates aria-label="DFFs and gates">DFFs and gates</a></li><li><a href=#create-circuit-from-truth-table aria-label="Create circuit from truth table">Create circuit from truth table</a></li><li><a href=#detect-an-edge aria-label="Detect an edge">Detect an edge</a></li><li><a href=#detect-both-edges aria-label="Detect both edges">Detect both edges</a></li><li><a href=#edge-capture-register aria-label="Edge capture register">Edge capture register</a></li><li><a href=#dual-edge-triggered-flip-flop aria-label="Dual-edge triggered flip-flop">Dual-edge triggered flip-flop</a></li></ul></li><li><a href=#322-counters aria-label="3.2.2 Counters">3.2.2 Counters</a></li><li><a href=#323-shift-registers aria-label="3.2.3 Shift Registers">3.2.3 Shift Registers</a></li><li><a href=#324-more-circuits aria-label="3.2.4 More Circuits">3.2.4 More Circuits</a></li><li><a href=#325-finite-state-machines aria-label="3.2.5 Finite State Machines">3.2.5 Finite State Machines</a></li></ul></li><li><a href=#33-building-larger-circuits aria-label="3.3 Building Larger Circuits">3.3 Building Larger Circuits</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><a href=/posts/verilog/hdlbits1/#1-getting-started>1. Getting Started</a><br><a href=/posts/verilog/hdlbits2/#2-verilog-language>2. Verilog Language</a><br><a href=/posts/verilog/hdlbits3/#3-circuits>3. Circuits</a><br><a href=/posts/verilog/hdlbits4/#4-getting-started>4. Verification: Reading Simulations</a><br><a href=/posts/verilog/hdlbits5/#5-verification---writing-testbenches>5. Verification: Writing Testbenches</a><br><a href=/posts/verilog/hdlbits6/#6-cs450>6. CS450</a></p><h1 id=3-circuits>3 Circuits<a hidden class=anchor aria-hidden=true href=#3-circuits>#</a></h1><h2 id=31-combinational-logic>3.1 Combinational Logic<a hidden class=anchor aria-hidden=true href=#31-combinational-logic>#</a></h2><h3 id=311-basic-gates>3.1.1 Basic Gates<a hidden class=anchor aria-hidden=true href=#311-basic-gates>#</a></h3><h4 id=wire>Wire<a hidden class=anchor aria-hidden=true href=#wire>#</a></h4><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/d/d7/Exams_m2014q4h.png alt=q4h></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=gnd>GND<a hidden class=anchor aria-hidden=true href=#gnd>#</a></h4><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/5/54/Exams_m2014q4i.png alt=GND></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=nor>NOR<a hidden class=anchor aria-hidden=true href=#nor>#</a></h4><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/e/e9/Exams_m2014q4e.png alt=NOR></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(in1<span style=color:#f92672>|</span>in2);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=another-gate>Another Gate<a hidden class=anchor aria-hidden=true href=#another-gate>#</a></h4><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/b/b6/Exams_m2014q4f.png alt=AnotherGate></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in1 <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>in2);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=two-gates>Two gates<a hidden class=anchor aria-hidden=true href=#two-gates>#</a></h4><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/e/e6/Exams_m2014q4g.png alt=TwoGates></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in3,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> w1;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1 <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(in1<span style=color:#f92672>^</span>in2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> w1<span style=color:#f92672>^</span>in3;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=more-logic-gates>More logic gates<a hidden class=anchor aria-hidden=true href=#more-logic-gates>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_and,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_or,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_xor,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_nand,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_nor,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_xnor,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_anotb
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_and <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or <span style=color:#f92672>=</span> a <span style=color:#f92672>|</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_xor <span style=color:#f92672>=</span> a <span style=color:#f92672>^</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_nand <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a <span style=color:#f92672>&amp;</span> b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_nor <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a <span style=color:#f92672>|</span> b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_xnor <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a <span style=color:#f92672>^</span> b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_anotb <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>b);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#75715e>//    and(out_and, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    or(out_or, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    xor(out_xor, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    nand(out_nand, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    nor(out_nor, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    xnor(out_xnor, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    and(out_anotb, a , ~b);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=7420-chip>7420 chip<a hidden class=anchor aria-hidden=true href=#7420-chip>#</a></h4><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/4/48/7420.png alt=7420></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> p1a, p1b, p1c, p1d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> p1y,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> p2a, p2b, p2c, p2d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> p2y );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> p1y <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(p1a <span style=color:#f92672>&amp;</span> p1b <span style=color:#f92672>&amp;</span> p1c <span style=color:#f92672>&amp;</span> p1d);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> p2y <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(p2a <span style=color:#f92672>&amp;</span> p2b <span style=color:#f92672>&amp;</span> p2c <span style=color:#f92672>&amp;</span> p2d);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>\
</span></span></code></pre></div><hr><h4 id=truth-tables>Truth tables<a hidden class=anchor aria-hidden=true href=#truth-tables>#</a></h4><p>\(\begin{array}{|c|ccc|c|}\hline
\text{Row}&&\text{Inputs}&&\text{Outputs}\\\hline
\text{number}&\text{x3}&\text{x2}&\text{x1}&\text{f}\\\hline
0&0&0&0&0\\\hline
1&0&0&1&0\\\hline
2&0&1&0&1\\\hline
3&0&1&1&1\\\hline
4&1&0&0&0\\\hline
5&1&0&1&1\\\hline
6&1&1&0&0\\\hline
7&1&1&1&1\\\hline
\end{array
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/f/f6/Truthtable1.png alt=truthtable1></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x3,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> f );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> f <span style=color:#f92672>=</span> ((<span style=color:#f92672>~</span>x3)<span style=color:#f92672>&amp;</span>x2)<span style=color:#f92672>|</span>(x3<span style=color:#f92672>&amp;</span>x1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=two-bit-equality>Two-bit equality<a hidden class=anchor aria-hidden=true href=#two-bit-equality>#</a></h4><ul><li>Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] A, <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] B, <span style=color:#66d9ef>output</span> z ); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (A <span style=color:#f92672>==</span> B);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=simple-circuit-a>Simple circuit A<a hidden class=anchor aria-hidden=true href=#simple-circuit-a>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (<span style=color:#66d9ef>input</span> x, <span style=color:#66d9ef>input</span> y, <span style=color:#66d9ef>output</span> z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (x<span style=color:#f92672>^</span>y) <span style=color:#f92672>&amp;</span>x;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=simple-circuit-b>Simple circuit B<a hidden class=anchor aria-hidden=true href=#simple-circuit-b>#</a></h4><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/6/6a/Mt2015_q4b.png alt=q4b></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( <span style=color:#66d9ef>input</span> x, <span style=color:#66d9ef>input</span> y, <span style=color:#66d9ef>output</span> z );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (x<span style=color:#f92672>==</span>y);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assign z = ~(x ^ y);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=combine-circuits-a-and-b>Combine circuits A and B<a hidden class=anchor aria-hidden=true href=#combine-circuits-a-and-b>#</a></h4><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/f/f5/Mt2015_q4.png alt=q4></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (<span style=color:#66d9ef>input</span> x, <span style=color:#66d9ef>input</span> y, <span style=color:#66d9ef>output</span> z);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> o1, o2, o3, o4;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    A ia1(x,y,o1);
</span></span><span style=display:flex><span>    B ib1(x,y,o2);
</span></span><span style=display:flex><span>    A ia2(x,y,o3);
</span></span><span style=display:flex><span>    B ib2(x,y,o4);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (o1<span style=color:#f92672>|</span>o2)<span style=color:#f92672>^</span>(o3<span style=color:#f92672>&amp;</span>o4);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> A(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x, y,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> z);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (x <span style=color:#f92672>^</span> y) <span style=color:#f92672>&amp;</span> x; 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> B(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x, y,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> z);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> x <span style=color:#f92672>~^</span> y;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=ringer>Ringer<a hidden class=anchor aria-hidden=true href=#ringer>#</a></h4><ul><li>Suppose you are designing a circuit to control a cellphone&rsquo;s ringer and vibration motor. Whenever the phone needs to ring from an incoming call (<code>input ring</code>), your circuit must either turn on the ringer (<code>output ringer = 1</code>) or the motor (<code>output motor = 1</code>), but not both. If the phone is in vibrate mode (<code>input vibrate_mode = 1</code>), turn on the motor. Otherwise, turn on the ringer.</li><li>Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.</li><li><strong>Design hint</strong>: When designing circuits, one often has to think of the problem &ldquo;backwards&rdquo;, starting from the outputs then working backwards towards the inputs. This is often the opposite of how one would think about a (sequential, imperative) programming problem, where one would look at the inputs first then decide on an action (or output). For sequential programs, one would often think &ldquo;If (inputs are ___ ) then (output should be ___ )&rdquo;. On the other hand, hardware designers often think &ldquo;The (output should be ___ ) when (inputs are ___ )&rdquo;.</li><li>The above problem description is written in an imperative form suitable for software programming (<em>if ring then do this</em>), so you must convert it to a more declarative form suitable for hardware implementation (<code>assign ringer = ___</code>). Being able to think in, and translate between, both styles is one of the most important skills needed for hardware design.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/9/96/Ringer.png alt=ringer></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> ring,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> vibrate_mode,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> ringer,       <span style=color:#75715e>// Make sound
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span> motor         <span style=color:#75715e>// Vibrate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> ringer <span style=color:#f92672>=</span> ring <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>vibrate_mode);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> motor <span style=color:#f92672>=</span> ring <span style=color:#f92672>&amp;</span> (vibrate_mode);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=thermostat>Thermostat<a hidden class=anchor aria-hidden=true href=#thermostat>#</a></h4><ul><li>A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.</li><li>The thermostat can be in one of two modes: <strong>heating</strong> (<code>mode = 1</code>) and <strong>cooling</strong> (<code>mode = 0</code>). In heating mode, turn the heater on when it is too cold (<code>too_cold = 1</code>) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (<code>too_hot = 1</code>), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.</li><li>Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.</li><li>畫出真值表<br>\(\begin{array}{|cccc|ccc|}\hline
\text{mode}&\text{too\_cold}&\text{too\_hot}&\text{fan on}&\text{heater}&\text{aircon}&\text{fan}\\\hline
0&0&0&0&0&0&0\\\hline
0&0&0&1&0&0&1\\\hline
0&0&1&0&0&1&1\\\hline
0&0&1&1&0&1&1\\\hline
0&1&0&0&0&0&0\\\hline
0&1&0&1&0&0&1\\\hline
0&1&1&0&0&1&1\\\hline
0&1&1&1&0&1&1\\\hline
1&0&0&0&0&0&0\\\hline
1&0&0&1&0&0&1\\\hline
1&0&1&0&0&0&0\\\hline
1&0&1&1&0&0&1\\\hline
1&1&0&0&1&0&1\\\hline
1&1&0&1&1&0&1\\\hline
1&1&1&0&1&0&1\\\hline
1&1&1&1&1&0&1\\\hline
\end{array}\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> too_cold,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> too_hot,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> mode,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> fan_on,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> heater,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> aircon,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> fan);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> heater <span style=color:#f92672>=</span> mode <span style=color:#f92672>&amp;</span> too_cold;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> aircon <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>mode) <span style=color:#f92672>&amp;</span> too_hot;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> fan <span style=color:#f92672>=</span> heater<span style=color:#f92672>|</span>aircon<span style=color:#f92672>|</span>fan_on;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=3-bit-population-count>3-bit population count<a hidden class=anchor aria-hidden=true href=#3-bit-population-count>#</a></h4><ul><li>A &ldquo;population count&rdquo; circuit counts the number of &lsquo;1&rsquo;s in an input vector. Build a population count circuit for a 3-bit input vector.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        out <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>; i<span style=color:#f92672>++</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            out <span style=color:#f92672>+=</span> in[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><ul><li><em>此解會產生鎖存器，不建議使用。</em></li></ul><hr><h4 id=gates-and-vectors>Gates and vectors<a hidden class=anchor aria-hidden=true href=#gates-and-vectors>#</a></h4><ul><li>You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour:<ul><li><strong>out_both</strong>: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the <strong>left</strong> (higher index) are &lsquo;1&rsquo;. For example, <code>out_both[2]</code> should indicate if <code>in[2]</code> and <code>in[3]</code> are both 1. Since <code>in[3]</code> has no neighbour to the left, the answer is obvious so we don&rsquo;t need to know <code>out_both[3]</code>.</li><li><strong>out_any</strong>: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the <strong>right</strong> are &lsquo;1&rsquo;. For example, <code>out_any[2]</code> should indicate if either <code>in[2]</code> or <code>in[1]</code> are 1. Since <code>in[0]</code> has no neighbour to the right, the answer is obvious so we don&rsquo;t need to know <code>out_any[0]</code>.</li><li><strong>out_different</strong>: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the <strong>left</strong>. For example, <code>out_different[2]</code> should indicate if <code>in[2]</code> is different from <code>in[3]</code>. For this part, treat the vector as wrapping around, so <code>in[3]</code>&rsquo;s neighbour to the left is <code>in[0]</code>.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_both,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] out_any,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_different );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_both[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;</span> in[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_any[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>|</span> in[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_different[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>^</span> {in[<span style=color:#ae81ff>0</span>], in[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>]};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// always @(*) begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    out_different[3] = (in[3] != in[0]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    for (int i = 0; i &lt;= 2; i++) begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        out_both[i] = in[i] &amp; in[i+1];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        out_any[i+1] = in[i+1] | in[i];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        out_different[i] = (in[i] != in[i+1]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=even-longer-vectors>Even longer vectors<a hidden class=anchor aria-hidden=true href=#even-longer-vectors>#</a></h4><ul><li>You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour:<ul><li><strong>out_both</strong>: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the <strong>left</strong> are &lsquo;1&rsquo;. For example, <code>out_both[98]</code> should indicate if <code>in[98]</code> and <code>in[99]</code> are both 1. Since <code>in[99]</code> has no neighbour to the left, the answer is obvious so we don&rsquo;t need to know <code>out_both[99]</code>.</li><li><strong>out_any</strong>: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the <strong>right</strong> are &lsquo;1&rsquo;. For example, <code>out_any[2]</code> should indicate if either <code>in[2]</code> or <code>in[1]</code> are 1. Since <code>in[0]</code> has no neighbour to the right, the answer is obvious so we don&rsquo;t need to know <code>out_any[0]</code>.</li><li><strong>out_different</strong>: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the <strong>left</strong>. For example, <code>out_different[98]</code> should indicate if <code>in[98]</code> is different from <code>in[99]</code>. For this part, treat the vector as wrapping around, so <code>in[99]</code>&rsquo;s neighbour to the left is <code>in[0]</code>.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>98</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_both,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] out_any,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_different );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_both[<span style=color:#ae81ff>98</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>98</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;</span> in[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_any[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>|</span> in[<span style=color:#ae81ff>98</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_different[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>^</span> {in[<span style=color:#ae81ff>0</span>], in[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>]};    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h3 id=312-multiplexers>3.1.2 Multiplexers<a hidden class=anchor aria-hidden=true href=#312-multiplexers>#</a></h3><h4 id=2-to-1-multiplexer>2-to-1 multiplexer<a hidden class=anchor aria-hidden=true href=#2-to-1-multiplexer>#</a></h4><ul><li>Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out ); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> sel <span style=color:#f92672>?</span> b <span style=color:#f92672>:</span> a;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=2-to-1-bus-multiplexer>2-to-1 bus multiplexer<a hidden class=anchor aria-hidden=true href=#2-to-1-bus-multiplexer>#</a></h4><ul><li>Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> sel <span style=color:#f92672>?</span> b <span style=color:#f92672>:</span> a;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=9-to-1-multiplexer>9-to-1 multiplexer<a hidden class=anchor aria-hidden=true href=#9-to-1-multiplexer>#</a></h4><ul><li>Create a 16-bit 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to &lsquo;1&rsquo;.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b, c, d, e, f, g, h, i,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span>(sel)
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d0</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d1</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d2</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d3</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d4</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d5</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> f;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d6</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> g;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d7</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> h;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d8</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> <span style=color:#ae81ff>&#39;1</span>;  <span style=color:#75715e>// special literal syntax with all bits set to 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=256-to-1-multiplexer>256-to-1 multiplexer<a hidden class=anchor aria-hidden=true href=#256-to-1-multiplexer>#</a></h4><ul><li>Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should be select <code>in[0]</code>, sel1 selectes bits <code>in[1]</code>, sel=2 selects bits <code>in[2]</code>, etc.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>255</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in[sel];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=256-to-1-4-bit-multiplexer>256-to-1 4-bit multiplexer<a hidden class=anchor aria-hidden=true href=#256-to-1-4-bit-multiplexer>#</a></h4><ul><li>Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits <code>in[3:0]</code>,sel=1 selects bits <code>in[7:4]</code>, sel=2 selects bits <code>in[11:8]</code>, etc.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>1023</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in[sel<span style=color:#f92672>*</span><span style=color:#ae81ff>4</span><span style=color:#f92672>+:</span><span style=color:#ae81ff>4</span>];  <span style=color:#75715e>// special syntax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// assign out = in[sel*4+3-:4];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// assign out = {in[sel*4+3],in[sel*4+2],in[sel*4+1],in[sel*4+0]};
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h3 id=313-arithmetic-circuits>3.1.3 Arithmetic Circuits<a hidden class=anchor aria-hidden=true href=#313-arithmetic-circuits>#</a></h3><h4 id=half-adder>Half adder<a hidden class=anchor aria-hidden=true href=#half-adder>#</a></h4><ul><li>Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout, sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=full-adder>Full adder<a hidden class=anchor aria-hidden=true href=#full-adder>#</a></h4><ul><li>Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and a carry-out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout, sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> cin;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=3-bit-binary-adder>3-bit binary adder<a hidden class=anchor aria-hidden=true href=#3-bit-binary-adder>#</a></h4><ul><li>Now that you know how to build a full adder, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fulladder f1(a[<span style=color:#ae81ff>0</span>], b[<span style=color:#ae81ff>0</span>], cin,     cout[<span style=color:#ae81ff>0</span>], sum[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    fulladder f2(a[<span style=color:#ae81ff>1</span>], b[<span style=color:#ae81ff>1</span>], cout[<span style=color:#ae81ff>0</span>], cout[<span style=color:#ae81ff>1</span>], sum[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    fulladder f3(a[<span style=color:#ae81ff>2</span>], b[<span style=color:#ae81ff>2</span>], cout[<span style=color:#ae81ff>1</span>], cout[<span style=color:#ae81ff>2</span>], sum[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> fulladder(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout, sum);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> cin;
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=adder>Adder<a hidden class=anchor aria-hidden=true href=#adder>#</a></h4><ul><li>Implement the following circuit:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/d/d2/Exams_m2014q4j.png alt=Adder></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] x,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] y, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assign sum = x + y;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    FA f1(x[<span style=color:#ae81ff>0</span>], y[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>0</span>,       cout[<span style=color:#ae81ff>0</span>], sum[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    FA f2(x[<span style=color:#ae81ff>1</span>], y[<span style=color:#ae81ff>1</span>], cout[<span style=color:#ae81ff>0</span>], cout[<span style=color:#ae81ff>1</span>], sum[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    FA f3(x[<span style=color:#ae81ff>2</span>], y[<span style=color:#ae81ff>2</span>], cout[<span style=color:#ae81ff>1</span>], cout[<span style=color:#ae81ff>2</span>], sum[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    FA f4(x[<span style=color:#ae81ff>3</span>], y[<span style=color:#ae81ff>3</span>], cout[<span style=color:#ae81ff>2</span>], sum[<span style=color:#ae81ff>4</span>],  sum[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> FA (
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>input</span> a, b, cin,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>output</span> cout, sum);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> cin;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=signed-addition-overflow>Signed addition overflow<a hidden class=anchor aria-hidden=true href=#signed-addition-overflow>#</a></h4><ul><li>Assume that you have two 8-bit 2&rsquo;s complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] s,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> overflow
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> s <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> overflow <span style=color:#f92672>=</span> (a[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>==</span> b[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>&amp;&amp;</span> a[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>!=</span> s[<span style=color:#ae81ff>7</span>]) <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=100-bit-binary-adder>100-bit binary adder<a hidden class=anchor aria-hidden=true href=#100-bit-binary-adder>#</a></h4><ul><li>Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> cin <span style=color:#f92672>+</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=4-digit-bcd-adder>4-digit BCD adder<a hidden class=anchor aria-hidden=true href=#4-digit-bcd-adder>#</a></h4><ul><li>You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> bcd_fadd (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>     cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span>   cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span></code></pre></div><p>Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] wl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bcd_fadd u0 (a[ <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>], b[ <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>],   cin, wl[<span style=color:#ae81ff>0</span>], sum[ <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    bcd_fadd u1 (a[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span>], b[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span>], wl[<span style=color:#ae81ff>0</span>], wl[<span style=color:#ae81ff>1</span>], sum[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span>]);
</span></span><span style=display:flex><span>    bcd_fadd u2 (a[<span style=color:#ae81ff>11</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>], b[<span style=color:#ae81ff>11</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>], wl[<span style=color:#ae81ff>1</span>], wl[<span style=color:#ae81ff>2</span>], sum[<span style=color:#ae81ff>11</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>]);
</span></span><span style=display:flex><span>    bcd_fadd u3 (a[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>], b[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>], wl[<span style=color:#ae81ff>2</span>],  cout, sum[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h3 id=314-karnaugh-map-to-circuit>3.1.4 Karnaugh Map to Circuit<a hidden class=anchor aria-hidden=true href=#314-karnaugh-map-to-circuit>#</a></h3><h4 id=kmap1>Kmap1<a hidden class=anchor aria-hidden=true href=#kmap1>#</a></h4><ul><li>Implement the circuit described by the Karnaugh map below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/2/20/Kmap1.png alt=kmap1></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> a <span style=color:#f92672>|</span> b <span style=color:#f92672>|</span> c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=kmap2>Kmap2<a hidden class=anchor aria-hidden=true href=#kmap2>#</a></h4><ul><li>Implement the circuit described by the Karnaugh map below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/4/4d/Kmap2.png alt=kmap2></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a&#39;d&#39; + b&#39;c&#39; + acd + a&#39;bc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>wire</span> w1, w2, w3, w4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1 <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>a)<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>~</span>d);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w2 <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>b)<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>~</span>c);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w3 <span style=color:#f92672>=</span> a<span style=color:#f92672>&amp;</span>c<span style=color:#f92672>&amp;</span>d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w4 <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>a)<span style=color:#f92672>&amp;</span>b<span style=color:#f92672>&amp;</span>c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> w1<span style=color:#f92672>|</span>w2<span style=color:#f92672>|</span>w3<span style=color:#f92672>|</span>w4;
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=kmap3>Kmap3<a hidden class=anchor aria-hidden=true href=#kmap3>#</a></h4><ul><li>Implement the circuit described by the Karnaugh map below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/1/1f/Kmap3.png alt=kmap3></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a + b&#39;c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> a <span style=color:#f92672>|</span> (<span style=color:#f92672>~</span>b<span style=color:#f92672>&amp;</span>c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=kmap4>Kmap4<a hidden class=anchor aria-hidden=true href=#kmap4>#</a></h4><ul><li>Implement the circuit described by the Karnaugh map below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/9/98/Kmap4.png alt=kmap4></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> b <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>!=</span> d)
</span></span><span style=display:flex><span>            out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>!=</span> b <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>==</span> d)
</span></span><span style=display:flex><span>            out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            out <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=minimum-sop-and-pos>Minimum SOP and POS<a hidden class=anchor aria-hidden=true href=#minimum-sop-and-pos>#</a></h4><ul><li>A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.</li><li>Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_sop,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_pos
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// f = d3 + m7 + d11 + m15 + m2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// f = cd + a&#39;b&#39;c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> out_sop <span style=color:#f92672>=</span> (c <span style=color:#f92672>&amp;</span> d) <span style=color:#f92672>|</span> (<span style=color:#f92672>~</span>a <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>b <span style=color:#f92672>&amp;</span> c);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// f&#39; = m0 + m1 + m4 + m5 + m6 + d8 + m9 + m10 + d11 + d12 + m13 + m14
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// f&#39; = c&#39; + ab&#39; + bd&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// f = (c)(a&#39;+b)(b&#39;+d)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> out_pos <span style=color:#f92672>=</span> c <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>a <span style=color:#f92672>|</span> b) <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>b <span style=color:#f92672>|</span> d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=karnaugh-map>Karnaugh map<a hidden class=anchor aria-hidden=true href=#karnaugh-map>#</a></h4><ul><li>Consider the function f shown in the Karnaugh map below.</li><li>Implement this function. <strong>d</strong> is don&rsquo;t-care, which means you may choose to output whatever value is convenient.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/a2/Exams_m2014q3.png alt=q3></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] x,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> f );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// x[2]x[4] + x[1]&#39;x[3]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> f <span style=color:#f92672>=</span> (x[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>4</span>]) <span style=color:#f92672>|</span> (<span style=color:#f92672>~</span>x[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=karnaugh-map-1>Karnaugh map<a hidden class=anchor aria-hidden=true href=#karnaugh-map-1>#</a></h4><ul><li>Consider the function f shown in the Karnaugh map below. Implement this function.
(The original exam question asked for simplified SOP and POS forms of the function.)
<img loading=lazy src="https://hdlbits.01xz.net/mw/thumb.php?f=Exams_2012q1g.png&width=195" alt=q1g></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] x,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> f
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// x[2]&#39;x[4]&#39; + x[1]&#39;x[3] + x[2]x[3]x[4]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> f <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>x[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>x[<span style=color:#ae81ff>4</span>]) <span style=color:#f92672>|</span> (<span style=color:#f92672>~</span>x[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>3</span>]) <span style=color:#f92672>|</span> (x[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>4</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=k-map-implemented-with-a-multiplexer>K-map implemented with a multiplexer<a hidden class=anchor aria-hidden=true href=#k-map-implemented-with-a-multiplexer>#</a></h4><ul><li>For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.</li><li>You are implementing just the portion labelled <strong>top_module</strong>, such that the entire circuit (including the 4-to-1 mux) implements the K-map.</li><li>(The requirement to use only 2-to-1 multiplexers exists because the original exam question also wanted to test logic function simplification using K-maps and how to synthesize logic functions using only multiplexers. If you wish to treat this as purely a Verilog exercise, you may ignore this constraint and write the module any way you wish.)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/a6/Ece241_2014_q3.png alt=q3>
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/b/bc/Ece241_2014_q3mux.png alt=q3mux></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] mux_in
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> mux_in[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> c<span style=color:#f92672>|</span>d;  <span style=color:#75715e>// 0111
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> mux_in[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>; <span style=color:#75715e>// 0000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> mux_in[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>d;   <span style=color:#75715e>// 1001
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> mux_in[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> c<span style=color:#f92672>&amp;</span>d;  <span style=color:#75715e>// 0010
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h2 id=32-sequential-logic>3.2 Sequential Logic<a hidden class=anchor aria-hidden=true href=#32-sequential-logic>#</a></h2><h3 id=321-latches-and-flip-flops>3.2.1 Latches and Flip-Flops<a hidden class=anchor aria-hidden=true href=#321-latches-and-flip-flops>#</a></h3><h4 id=d-flip-flop>D flip-flop<a hidden class=anchor aria-hidden=true href=#d-flip-flop>#</a></h4><ul><li>A D flip-flop is a circuit that stores a bit and is updated periodically, at the (usually) positive edge of a clock signal. D flip-flops are created by the logic synthesizer when a clocked always block is used (See alwaysblock2). A D + flip-flop is the simplest form of &ldquo;blob of combinational logic followed by a flip-flop&rdquo; where the combinational logic portion is just a wire.</li><li>Create a single D flip-flop.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/6/6c/Dff.png alt=dff></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,    <span style=color:#75715e>// Clocks are used in sequential circuits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> q );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#66d9ef>posedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        q <span style=color:#f92672>&lt;=</span> d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=d-flip-flops>D flip-flops<a hidden class=anchor aria-hidden=true href=#d-flip-flops>#</a></h4><ul><li>Create 8 D flip-flops. All DFFs should be triggered by the positive edge of <code>clk</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#66d9ef>posedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        q <span style=color:#f92672>&lt;=</span> d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=dff-with-reset>DFF with reset<a hidden class=anchor aria-hidden=true href=#dff-with-reset>#</a></h4><ul><li>Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of <code>clk</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> reset,            <span style=color:#75715e>// Synchronous reset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#66d9ef>posedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (reset) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>8</span><span style=color:#ae81ff>&#39;b0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> d;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=dff-with-reset-value>DFF with reset value<a hidden class=anchor aria-hidden=true href=#dff-with-reset-value>#</a></h4><ul><li>Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the <strong>negative</strong> edge of <code>clk</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> reset,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#66d9ef>negedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (reset) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>8&#39;h34</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> d;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=dff-with-asynchronous-reset>DFF with asynchronous reset<a hidden class=anchor aria-hidden=true href=#dff-with-asynchronous-reset>#</a></h4><ul><li>Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of <code>clk</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> areset,   <span style=color:#75715e>// active high asynchronous reset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#66d9ef>posedge</span> clk <span style=color:#66d9ef>or</span> <span style=color:#66d9ef>posedge</span> areset)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (areset) 
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> 
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> d;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><ul><li>In Verilog, the sensity list looks strange. The FF&rsquo;s reset is sensitive to the <strong>level</strong> of areset, so why does using &ldquo;posedge areset&rdquo; work? To see why it works, consider the truth table for all events that change the input signals, assuming clk and areset do not swith at precisely the same time.<br>\(\begin{array}{|c|c|c|l|}\hline
\text{clk}&\text{areset}&\text{output}&\text{comment}\\\hline
\text{x}&\text{0}\rightarrow\text{1}&\text{q}\leftarrow{0;}&\text{because areset = 1}\\\hline
\text{x}&\text{1}\rightarrow\text{0}&\text{no change}&\text{always block not triggered}\\\hline
\text{0}\rightarrow\text{1}&\text{0}&\text{q}\leftarrow{d;}&\text{not resetting}\\\hline
\text{0}\rightarrow\text{1}&\text{1}&\text{q}\leftarrow{0;}&\text{still resetting, q was 0 before too}\\\hline
\text{1}\rightarrow\text{0}&\text{x}&\text{no change}&\text{always block not triggered}\\\hline
\end{array}\)</li></ul><hr><h4 id=dff-with-byte-enable>DFF with byte enable<a hidden class=anchor aria-hidden=true href=#dff-with-byte-enable>#</a></h4><ul><li>Create 16 D flip-flops. It&rsquo;s sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. <code>byteena[1]</code> controls the upper byte <code>d[15:8]</code>, while <code>byteena[0]</code> controls the lower byte <code>d[7:0]</code>. <code>resetn</code> is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of <code>clk</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> resetn,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] byteena,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#66d9ef>posedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (resetn <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>16</span><span style=color:#ae81ff>&#39;d0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span>(byteena)
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> q <span style=color:#f92672>&lt;=</span> q;
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> q <span style=color:#f92672>&lt;=</span> {q[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>], d[<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]};
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> q <span style=color:#f92672>&lt;=</span> {d[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>], q[<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]};
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> q <span style=color:#f92672>&lt;=</span> d;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=d-latch>D Latch<a hidden class=anchor aria-hidden=true href=#d-latch>#</a></h4><ul><li>Implement the following circuit:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/0/03/Exams_m2014q4a.png alt=q4a></li><li>Note that this is a latch, so a Quartus warning about hvaing inferred a latch is expected.</li><li>對於組合邏輯，if 若沒有補全 else，case 條件不完全，可能會產生 latch。但是如果中間的信號有初值，就不會產生 latch。所以要盡量避免 latch 的產生，避免對時序的危害很大。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> ena,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ena <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b1</span>)
</span></span><span style=display:flex><span>            q <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=dffar>DFFAR<a hidden class=anchor aria-hidden=true href=#dffar>#</a></h4><ul><li>Implement the following circuit:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/b/b3/Exams_m2014q4b.png alt=q4b></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> ar,   <span style=color:#75715e>// asynchronous reset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span> q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span>@(<span style=color:#66d9ef>posedge</span> clk <span style=color:#66d9ef>or</span> <span style=color:#66d9ef>posedge</span> ar) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ar <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=dffr>DFFR<a hidden class=anchor aria-hidden=true href=#dffr>#</a></h4><ul><li>Implement the following circuit:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/6/6d/Exams_m2014q4c.png alt=q4c></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> r,   <span style=color:#75715e>// synchronous reset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span> q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span>@(<span style=color:#66d9ef>posedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>&lt;=</span> d;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=dffgate>DFF+gate<a hidden class=anchor aria-hidden=true href=#dffgate>#</a></h4><ul><li>Implement the following circuit:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/f/f2/Exams_m2014q4d.png alt=Dffgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span>@(<span style=color:#66d9ef>posedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        out <span style=color:#f92672>&lt;=</span> out <span style=color:#f92672>^</span> in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><ul><li>注意 <code>output</code> 需為 <code>reg</code> 型別。</li></ul><hr><h4 id=mux-and-dff>Mux and DFF<a hidden class=anchor aria-hidden=true href=#mux-and-dff>#</a></h4><ul><li>Consider the sequential circuit below:
<img loading=lazy src="https://hdlbits.01xz.net/mw/thumb.php?f=Mt2015_muxdff.png&width=800" alt=muxdff></li><li>Assume that you want to implement hierarchical Verilog code for this circuit, using three instantiations of a submodule that has a flip-flop and multiplexer in it. Write a Verilog module (containing one flip-flop and multiplexer) named top_module for this submodule.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>	  <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>	  <span style=color:#66d9ef>input</span> L,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> r_in,
</span></span><span style=display:flex><span>	  <span style=color:#66d9ef>input</span> q_in,
</span></span><span style=display:flex><span>	  <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> Q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span>@(<span style=color:#66d9ef>posedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (L)
</span></span><span style=display:flex><span>            Q <span style=color:#f92672>&lt;=</span> r_in;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            Q <span style=color:#f92672>&lt;=</span> q_in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h4 id=mux-and-dff-1>Mux and DFF<a hidden class=anchor aria-hidden=true href=#mux-and-dff-1>#</a></h4><h4 id=dffgate-1>DFF+gate<a hidden class=anchor aria-hidden=true href=#dffgate-1>#</a></h4><h4 id=mux-and-dff-2>Mux and DFF<a hidden class=anchor aria-hidden=true href=#mux-and-dff-2>#</a></h4><h4 id=mux-and-dff-3>Mux and DFF<a hidden class=anchor aria-hidden=true href=#mux-and-dff-3>#</a></h4><h4 id=dffs-and-gates>DFFs and gates<a hidden class=anchor aria-hidden=true href=#dffs-and-gates>#</a></h4><h4 id=create-circuit-from-truth-table>Create circuit from truth table<a hidden class=anchor aria-hidden=true href=#create-circuit-from-truth-table>#</a></h4><h4 id=detect-an-edge>Detect an edge<a hidden class=anchor aria-hidden=true href=#detect-an-edge>#</a></h4><h4 id=detect-both-edges>Detect both edges<a hidden class=anchor aria-hidden=true href=#detect-both-edges>#</a></h4><h4 id=edge-capture-register>Edge capture register<a hidden class=anchor aria-hidden=true href=#edge-capture-register>#</a></h4><h4 id=dual-edge-triggered-flip-flop>Dual-edge triggered flip-flop<a hidden class=anchor aria-hidden=true href=#dual-edge-triggered-flip-flop>#</a></h4><h3 id=322-counters>3.2.2 Counters<a hidden class=anchor aria-hidden=true href=#322-counters>#</a></h3><h3 id=323-shift-registers>3.2.3 Shift Registers<a hidden class=anchor aria-hidden=true href=#323-shift-registers>#</a></h3><h3 id=324-more-circuits>3.2.4 More Circuits<a hidden class=anchor aria-hidden=true href=#324-more-circuits>#</a></h3><h3 id=325-finite-state-machines>3.2.5 Finite State Machines<a hidden class=anchor aria-hidden=true href=#325-finite-state-machines>#</a></h3><h2 id=33-building-larger-circuits>3.3 Building Larger Circuits<a hidden class=anchor aria-hidden=true href=#33-building-larger-circuits>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/vhdl/>VHDL</a></li><li><a href=https://intervalrain.github.io/tags/programming/>Programming</a></li><li><a href=https://intervalrain.github.io/tags/verilog/>Verilog</a></li><li><a href=https://intervalrain.github.io/tags/hdlbits/>HDLbits</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/posts/verilog/hdlbits2/><span class=title>« Prev Page</span><br><span>[VHDL] HDLbits 2 - Verilog Language</span></a>
<a class=next href=https://intervalrain.github.io/posts/verilog/hdlbits4/><span class=title>Next Page »</span><br><span>[VHDL] HDLbits 4 - Verification: Reading Simulations</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>