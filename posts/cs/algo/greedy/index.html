<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Algo] 2-2. 貪心演算法 Greedy | Rain Hu's Workspace</title><meta name=keywords content="C++,Leetcode,Algorithm,貪心法,greedy"><meta name=description content="演算法設計，介紹什麼是貪心法，貪心法的解題思維"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="[Algo] 2-2. 貪心演算法 Greedy"><meta property="og:description" content="演算法設計，介紹什麼是貪心法，貪心法的解題思維"><meta property="og:type" content="article"><meta property="og:url" content="https://intervalrain.github.io/posts/cs/algo/greedy/"><meta property="og:image" content="https://intervalrain.github.io/images/faang.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-24T18:31:15+08:00"><meta property="article:modified_time" content="2023-01-24T18:31:15+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://intervalrain.github.io/images/faang.webp"><meta name=twitter:title content="[Algo] 2-2. 貪心演算法 Greedy"><meta name=twitter:description content="演算法設計，介紹什麼是貪心法，貪心法的解題思維"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[Algo] 2-2. 貪心演算法 Greedy","item":"https://intervalrain.github.io/posts/cs/algo/greedy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Algo] 2-2. 貪心演算法 Greedy","name":"[Algo] 2-2. 貪心演算法 Greedy","description":"演算法設計，介紹什麼是貪心法，貪心法的解題思維","keywords":["C++","Leetcode","Algorithm","貪心法","greedy"],"articleBody":"一、貪心演算法 是一種在每一步都採前當下看起來最好的選擇的一種策略。 由於是當下看起來最好的選擇，故也有可能選到錯的路線，導致最終的答案不是最佳解。 先舉個生活中常見的例子： 今天小明的撲滿裡存滿了大大小小的1塊、5塊跟10塊，今天小明打算要要幫撲滿瘦身，令它的重量降低，那麼小明可以到銀行換鈔，將幣值小、重量重的硬幣集結起來換成幣值大、重量輕的紙鈔。 用貪心演算法的思維，我們一定是從幣值大的 1000 開始換起，再來 500、100、50、10，以此類推，有多少換多少。 // vector\u0026 nums = {1000, 500, 100, 50, 10, 5, 1}; vector\u003cint\u003e coinChange(vector\u003cint\u003e\u0026 nums, int money) { vector\u003cint\u003e res(nums.size(), 0); for (int i = 0; i \u003c nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 但若我們新增了一個幣值是 23，那麼上面這個思路就有可能會導致錯誤。 貪心演算法的特點 直覺且快速 通常不是最佳的 需要會被要求證明 always stays ahead：跑者每個時間點都在第一名，最後結果會是第一名 用歸納法證明。 exchange argument 用反證法，找到原解的 inversions，並作交換，證明交換後並不影響最佳解。 二、貪心演算法的應用 0. 核心思維 貪心演算法是從某一個初始狀態出發，每次通過選取區域性最優解向目標前進，並最終期望取得整體最優解的一種演算法。由這個定義可知，貪心選擇標準就是選擇當前最好的決策，貪心演算法根據這個標準進行決策，將原問題變成一個相似但規模更小的子問題，而後每一步選出來的一定是原問題整體最優解的一部分。\n如果一個問題貪心後只剩下一個子問題且有最優子結構，那麼該問題就可以使用貪心演算法。當一個問題的整體最優解包含其子問題的最優解時，我們稱次問題具有最優子結構性質。 解題一般步驟 設計資料結構並找規律 進心貪心猜想 正確性證明(歸納法證明或是列舉反例進行反證) 實現程式碼 1. 找零錢問題(Coin Change) 先用剛剛提到的那一題來試做： 以貪心法的思維來做就是，幣值愈大先換，換到不能再換時再往次大的幣值換。 vector\u003cint\u003e coinChange(vector\u003cint\u003e\u0026 nums, int money) { vector\u003cint\u003e res(nums.size(), 0); for (int i = 0; i \u003c nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 以範例 nums = {1000, 500, 100, 50, 23, 10, 5, 1}，money = 1069 來測試看看，以上述得到的結果應該是：(參考例題Leetcode 322. Coin Change) {1000, 500, 100, 50, 23, 10, 5, 1} = {1, 0, 0, 1, 0, 1, 1, 4}，也就是說，得到的硬幣總數是 8(假設所有幣值都是硬幣)。 因為夾雜了 23，使得問題變得稍微有點不一樣，因為最佳解可以是：\n{1000, 500, 100, 50, 23, 10, 5, 1} = {1, 0, 0, 0, 3, 0, 0, 0}，總數 4。 從上面此例來觀察，貪心法是需要有適用時機的，當今天少掉 23 的時候，使用貪心法是可以得到最佳解的，因為所有數字互為因數、倍數關係，也就是說，當今天可以用 1 張 1000 解決的情況，必定可以用其它幣值用更多的代價來替換，如 2 張 500，或 10 張 100。但是 23 可以替換的是 2 個 10 塊加上 3 個 1 塊。用數字為例的話如下 \\(\\boxed{\\begin{array}{ll} 1069\u0026=1\\times1000+1\\times50+1\\times10+1\\times5+4\\times1\\\\ \u0026=1\\times(2\\times500)+1\\times50+1\\times10+1\\times5+4\\times1\\\\ \u0026=1\\times(10\\times100)+1\\times50+1\\times10+1\\times5+4\\times1\\\\ \u0026=1\\times(20\\times50)+1\\times50+1\\times10+1\\times5+4\\times1\\\\ \\end{array}} \\) 不管怎麼換，總數都是變大。 如果要解出上述的最佳解，需要做一點修正，或是使用暴力破解法，例如 bfs 來遍歷所有情形來獲得最小值。 試想要怎麼改寫可以使貪法仍然可以適用，「將23拿掉」那麼貪心法就仍可以適用，那要怎麼有技巧的將 23 拿掉呢。 23 能夠有效的替換表示我們一定會使用到 23，也就是說我們可以找到反例使 23 不能有效的替換就好了。 23 = 23*1(1) 換 10*2 + 1*3(5) 46 = 23*2(2) 換 10*4 + 5*1 + 1*1(6) 69 = 23*3(3) 換 50*1 + 10*1 + 1*4(6) 92 = 23*4(4) 換 50*1 + 10*4 + 1*2(7) 115 = 23*5(5) 換 100*1 + 10*1 + 5*1(3) 我們可以發現當 23 替換到第 5 個的時候已經不能有效的替換了，表示我們只有嘗試替換 0~4 個 23 硬幣，其餘剩下的錢用貪心法去計算，仍然可以得到有效的解。(在此只是為了展示失去「局部最佳性」的範例，不做嚴謹的數學證明) 即求 min(f(1069)+0, f(1046)+1, f(1023)+2, f(1000)+3, f(976)+4。 vector\u003cint\u003e coinChange(vector\u003cint\u003e\u0026nums, int money) { ... } // implement by greedy vector\u003cint\u003e coinChangePlus(vector\u003cint\u003e\u0026nums, int money) { vector\u003cint\u003e res; int coins = INT_MAX; for (int i = 0; i \u003c= 4; i++) { vector\u003cint\u003e tmp = coinChange(nums, money-23*i); tmp[4]+=i; int cnt = accumulate(tmp.begin(), tmp.end(), 0); if (cnt \u003c coins) { res = tmp; coins = cnt; } } return res; } 以上方法當遇到單一奇異數(無因倍數關係)的時候還可以用，但遇到多個奇異數的時候，複雜度就會明顯上升，到時後我們會遇用其它方法來解構。在後面的動態規劃篇，有深入的介紹，如何利用其它技巧達到剪枝得到最佳解。 由此可發現，貪心法不一定會得到最佳解，需要嚴格的驗證「局部最佳性」，才能保證最後的解是最佳解。 2. 背包問題(Knapsack Problem) 常見的背包問題分為分數背包問題與0-1背包問題。 今天在某個場合，你有一個載重5kg的背包，面前有3kg的金沙、3kg的銀沙與2kg的銅沙，已知金的價格比銀高，銀的價格比銅高。你可以任意決定怎麼將它們裝進背包，最後換取對應價值的獎金，試問怎麼裝可以得到最高的獎金？ 同樣的場合，金沙、銀沙、銅沙換成了金塊、銀塊、銅塊，分別也是 3kg、3kg、2kg，且不可切割，試問要怎麼裝可以得到最高的獎金？ 第1題(分數背包)，顯而易見，用貪心法來做一定是盡可能先裝滿價值高的金沙，再用剩餘的空間以此類推裝填其它的。(3kg金沙+2kg銀沙) 第2題(0-1背包)，由於拿完金塊，無法再拿銀塊，所以最佳解變成了拿金塊與銅塊。(3kg金塊+2kg銅塊) 三、例題 1. 餅乾分配問題 Leetcode 455. Assign Cookies 有若干個不同份量的餅乾，與若干個需要不同份量才能滿足的小孩，試問餅乾最多可以讓幾個小孩滿意。 把餅乾的份量從小排到大，把小孩從需求小排到需求大。 盡可能的滿足需求小的小孩。(若需求小的都滿足不了，那麼需求大的就不可能滿足了) int findContentChildren(vector\u003cint\u003e\u0026 children, vector\u003cint\u003e\u0026 cookies) { sort(children.begin(), children.end()); sort(cookies.begin(), cookies.end()); int child = 0, cookie = 0; while (child \u003c children.size() \u0026\u0026 cookie \u003c cookies.size()) { if (children[child] \u003c= cookies[cookie]) child++; cookie++; } return child; } 2. 股票買賣問題 Leetcode 122. Best Timer to Buy and Sell Stock II 有一數列為某上市公司每日的股價，若手上最多只能有一張股票，要怎麼樣買賣可以得到最高獲利。 最高獲利代表所有上升波段的總和，忽略所有下降波段。 int maxProfit(vector\u003cint\u003e\u0026 prices) { int sum = 0; int last = prices[0]; for (const auto\u0026 price : prices) { sum += (price \u003e last) ? price - last : 0; last = price } return sum; } 3. 跳躍遊戲 55. Jump Game 有一數列表示，在該 i 索引位置起，最多可以跳幾個索引長度，試問從索引值為 0 開始，可否到達索引值為 n-1。 盡可能的往前跳，不斷的更新最遠可以到達的位置。 bool canJump(vector\u003cint\u003e\u0026 nums) { int reach = nums[0]; for (int i = 0; i \u003c nums.size() \u0026\u0026 i \u003c= reach; i++) { if (i == nums.size()-1) return true; reach = max(reach, nums[i]+i); } return false; } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-1. 暴力演算法 接著閱讀：[Algo] 2-3. 分治法 ","wordCount":"490","inLanguage":"en","image":"https://intervalrain.github.io/images/faang.webp","datePublished":"2023-01-24T18:31:15+08:00","dateModified":"2023-01-24T18:31:15+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/posts/cs/algo/greedy/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/posts/csharp/csharp title=Csharp><span>Csharp</span></a></li><li><a href=https://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[Algo] 2-2. 貪心演算法 Greedy</h1><div class=post-description>演算法設計，介紹什麼是貪心法，貪心法的解題思維</div><div class=post-meta><span title='2023-01-24 18:31:15 +0800 +0800'>January 24, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/CS/algo/greedy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e8%b2%aa%e5%bf%83%e6%bc%94%e7%ae%97%e6%b3%95 aria-label=一、貪心演算法>一、貪心演算法</a></li><li><a href=#%e4%ba%8c%e8%b2%aa%e5%bf%83%e6%bc%94%e7%ae%97%e6%b3%95%e7%9a%84%e6%87%89%e7%94%a8 aria-label=二、貪心演算法的應用>二、貪心演算法的應用</a><ul><li><a href=#0-%e6%a0%b8%e5%bf%83%e6%80%9d%e7%b6%ad aria-label="0. 核心思維">0. 核心思維</a></li><li><a href=#1-%e6%89%be%e9%9b%b6%e9%8c%a2%e5%95%8f%e9%a1%8ccoin-change aria-label="1. 找零錢問題(Coin Change)">1. 找零錢問題(Coin Change)</a></li><li><a href=#2-%e8%83%8c%e5%8c%85%e5%95%8f%e9%a1%8cknapsack-problem aria-label="2. 背包問題(Knapsack Problem)">2. 背包問題(Knapsack Problem)</a></li></ul></li><li><a href=#%e4%b8%89%e4%be%8b%e9%a1%8c aria-label=三、例題>三、例題</a><ul><li><a href=#1-%e9%a4%85%e4%b9%be%e5%88%86%e9%85%8d%e5%95%8f%e9%a1%8c aria-label="1. 餅乾分配問題">1. 餅乾分配問題</a></li><li><a href=#2-%e8%82%a1%e7%a5%a8%e8%b2%b7%e8%b3%a3%e5%95%8f%e9%a1%8c aria-label="2. 股票買賣問題">2. 股票買賣問題</a></li><li><a href=#3-%e8%b7%b3%e8%ba%8d%e9%81%8a%e6%88%b2 aria-label="3. 跳躍遊戲">3. 跳躍遊戲</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=一貪心演算法>一、貪心演算法<a hidden class=anchor aria-hidden=true href=#一貪心演算法>#</a></h2><ul><li>是一種<strong>在每一步都採前當下看起來最好的選擇</strong>的一種策略。</li><li>由於是當下看起來最好的選擇，故也有可能選到錯的路線，導致最終的答案不是最佳解。</li><li>先舉個生活中常見的例子：<ul><li>今天小明的撲滿裡存滿了大大小小的1塊、5塊跟10塊，今天小明打算要要幫撲滿瘦身，令它的重量降低，那麼小明可以到銀行換鈔，將幣值小、重量重的硬幣集結起來換成幣值大、重量輕的紙鈔。</li><li>用貪心演算法的思維，我們一定是從幣值大的 1000 開始換起，再來 500、100、50、10，以此類推，有多少換多少。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// vector&lt;int&gt;&amp; nums = {1000, 500, 100, 50, 10, 5, 1};
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> coinChange(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> money) {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res(nums.size(), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> nums.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        res[i] <span style=color:#f92672>+=</span> (money <span style=color:#f92672>/</span> nums[i]);
</span></span><span style=display:flex><span>        money <span style=color:#f92672>%=</span> nums[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>但若我們新增了一個幣值是 <code>23</code>，那麼上面這個思路就有可能會導致錯誤。</li></ul></li><li>貪心演算法的特點<ul><li>直覺且快速</li><li>通常不是最佳的</li><li>需要會被要求證明<ol><li>always stays ahead：跑者每個時間點都在第一名，最後結果會是第一名<ul><li>用歸納法證明。</li></ul></li><li>exchange argument<ul><li>用反證法，找到原解的 inversions，並作交換，證明交換後並不影響最佳解。</li></ul></li></ol></li></ul></li></ul><h2 id=二貪心演算法的應用>二、貪心演算法的應用<a hidden class=anchor aria-hidden=true href=#二貪心演算法的應用>#</a></h2><h3 id=0-核心思維>0. 核心思維<a hidden class=anchor aria-hidden=true href=#0-核心思維>#</a></h3><ul><li>貪心演算法是從某一個初始狀態出發，每次通過選取區域性最優解向目標前進，並最終期望取得整體最優解的一種演算法。由這個定義可知，貪心選擇標準就是選擇<strong>當前最好</strong>的決策，貪心演算法根據這個標準進行決策，將原問題變成一個相似但規模更小的子問題，而後每一步選出來的一定是原問題整體最優解的一部分。<br>如果一個問題貪心後只剩下一個子問題且有最優子結構，那麼該問題就可以使用貪心演算法。當一個問題的整體最優解包含其子問題的最優解時，我們稱次問題具有最優子結構性質。</li><li>解題一般步驟<ol><li>設計資料結構並找規律</li><li>進心貪心猜想</li><li>正確性證明(歸納法證明或是列舉反例進行反證)</li><li>實現程式碼</li></ol></li></ul><h3 id=1-找零錢問題coin-change>1. 找零錢問題(Coin Change)<a hidden class=anchor aria-hidden=true href=#1-找零錢問題coin-change>#</a></h3><ul><li>先用剛剛提到的那一題來試做：</li><li>以貪心法的思維來做就是，幣值愈大先換，換到不能再換時再往次大的幣值換。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> coinChange(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> money) {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res(nums.size(), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> nums.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        res[i] <span style=color:#f92672>+=</span> (money <span style=color:#f92672>/</span> nums[i]);
</span></span><span style=display:flex><span>        money <span style=color:#f92672>%=</span> nums[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>以範例 <code>nums = {1000, 500, 100, 50, 23, 10, 5, 1}</code>，<code>money = 1069</code> 來測試看看，以上述得到的結果應該是：(參考例題<a href=https://leetcode.com/problems/coin-change/>Leetcode 322. Coin Change</a>)<ul><li><code>{1000, 500, 100, 50, 23, 10, 5, 1} = {1, 0, 0, 1, 0, 1, 1, 4}</code>，也就是說，得到的硬幣總數是 <code>8</code>(假設所有幣值都是硬幣)。</li><li>因為夾雜了 <code>23</code>，使得問題變得稍微有點不一樣，因為最佳解可以是：<br><code>{1000, 500, 100, 50, 23, 10, 5, 1} = {1, 0, 0, 0, 3, 0, 0, 0}</code>，總數 <code>4</code>。</li><li>從上面此例來觀察，貪心法是需要有適用時機的，當今天少掉 <code>23</code> 的時候，使用貪心法是可以得到最佳解的，因為所有數字互為因數、倍數關係，也就是說，當今天可以用 <code>1</code> 張 <code>1000</code> 解決的情況，必定可以用其它幣值用更多的代價來替換，如 <code>2</code> 張 <code>500</code>，或 <code>10</code> 張 <code>100</code>。但是 <code>23</code> 可以替換的是 <code>2</code> 個 <code>10</code> 塊加上 <code>3</code> 個 <code>1</code> 塊。用數字為例的話如下<ul><li>\(\boxed{\begin{array}{ll}
1069&=1\times1000+1\times50+1\times10+1\times5+4\times1\\
&=1\times(2\times500)+1\times50+1\times10+1\times5+4\times1\\
&=1\times(10\times100)+1\times50+1\times10+1\times5+4\times1\\
&=1\times(20\times50)+1\times50+1\times10+1\times5+4\times1\\
\end{array}}
\)</li><li>不管怎麼換，總數都是變大。</li></ul></li><li>如果要解出上述的最佳解，需要做一點修正，或是使用暴力破解法，例如 <code>bfs</code> 來遍歷所有情形來獲得最小值。<ul><li>試想要怎麼改寫可以使貪法仍然可以適用，「將23拿掉」那麼貪心法就仍可以適用，那要怎麼有技巧的將 <code>23</code> 拿掉呢。</li><li><code>23</code> 能夠有效的替換表示我們一定會使用到 <code>23</code>，也就是說我們可以找到反例使 <code>23</code> 不能有效的替換就好了。<ul><li><code>23</code> = <code>23*1(1)</code> 換 <code>10*2 + 1*3(5)</code></li><li><code>46</code> = <code>23*2(2)</code> 換 <code>10*4 + 5*1 + 1*1(6)</code></li><li><code>69</code> = <code>23*3(3)</code> 換 <code>50*1 + 10*1 + 1*4(6)</code></li><li><code>92</code> = <code>23*4(4)</code> 換 <code>50*1 + 10*4 + 1*2(7)</code></li><li><code>115</code> = <code>23*5(5)</code> 換 <code>100*1 + 10*1 + 5*1(3)</code></li></ul></li><li>我們可以發現當 <code>23</code> 替換到第 <code>5</code> 個的時候已經不能有效的替換了，表示我們只有嘗試替換 <code>0~4</code> 個 <code>23</code> 硬幣，其餘剩下的錢用貪心法去計算，仍然可以得到有效的解。(在此只是為了展示失去「局部最佳性」的範例，不做嚴謹的數學證明)</li><li>即求 <code>min(f(1069)+0, f(1046)+1, f(1023)+2, f(1000)+3, f(976)+4</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> coinChange(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span>nums, <span style=color:#66d9ef>int</span> money) { ... } <span style=color:#75715e>// implement by greedy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> coinChangePlus(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span>nums, <span style=color:#66d9ef>int</span> money) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> coins <span style=color:#f92672>=</span> INT_MAX;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> tmp <span style=color:#f92672>=</span> coinChange(nums, money<span style=color:#f92672>-</span><span style=color:#ae81ff>23</span><span style=color:#f92672>*</span>i);
</span></span><span style=display:flex><span>            tmp[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>+=</span>i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> accumulate(tmp.begin(), tmp.end(), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cnt <span style=color:#f92672>&lt;</span> coins) {
</span></span><span style=display:flex><span>                res <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>                coins <span style=color:#f92672>=</span> cnt;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></li><li>以上方法當遇到單一奇異數(無因倍數關係)的時候還可以用，但遇到多個奇異數的時候，複雜度就會明顯上升，到時後我們會遇用其它方法來解構。在後面的<a href=/posts/cs/algo/dp>動態規劃</a>篇，有深入的介紹，如何利用其它技巧達到剪枝得到最佳解。</li></ul></li><li>由此可發現，貪心法不一定會得到最佳解，需要嚴格的驗證「局部最佳性」，才能保證最後的解是最佳解。</li></ul><h3 id=2-背包問題knapsack-problem>2. 背包問題(Knapsack Problem)<a hidden class=anchor aria-hidden=true href=#2-背包問題knapsack-problem>#</a></h3><ul><li>常見的背包問題分為<strong>分數背包問題</strong>與<strong>0-1背包問題</strong>。<ul><li>今天在某個場合，你有一個載重5kg的背包，面前有3kg的金沙、3kg的銀沙與2kg的銅沙，已知金的價格比銀高，銀的價格比銅高。你可以任意決定怎麼將它們裝進背包，最後換取對應價值的獎金，試問怎麼裝可以得到最高的獎金？</li><li>同樣的場合，金沙、銀沙、銅沙換成了金塊、銀塊、銅塊，分別也是 3kg、3kg、2kg，且不可切割，試問要怎麼裝可以得到最高的獎金？<ul><li>第1題(分數背包)，顯而易見，用貪心法來做一定是盡可能先裝滿價值高的金沙，再用剩餘的空間以此類推裝填其它的。(3kg金沙+2kg銀沙)</li><li>第2題(0-1背包)，由於拿完金塊，無法再拿銀塊，所以最佳解變成了拿金塊與銅塊。(3kg金塊+2kg銅塊)</li></ul></li></ul></li></ul><h2 id=三例題>三、例題<a hidden class=anchor aria-hidden=true href=#三例題>#</a></h2><h3 id=1-餅乾分配問題>1. 餅乾分配問題<a hidden class=anchor aria-hidden=true href=#1-餅乾分配問題>#</a></h3><ul><li><a href=https://leetcode.com/problems/assign-cookies/>Leetcode 455. Assign Cookies</a></li><li>有若干個不同份量的餅乾，與若干個需要不同份量才能滿足的小孩，試問餅乾最多可以讓幾個小孩滿意。<ul><li>把餅乾的份量從小排到大，把小孩從需求小排到需求大。</li><li>盡可能的滿足需求小的小孩。(若需求小的都滿足不了，那麼需求大的就不可能滿足了)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>findContentChildren</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> children, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> cookies) {
</span></span><span style=display:flex><span>    sort(children.begin(), children.end());
</span></span><span style=display:flex><span>    sort(cookies.begin(), cookies.end());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> child <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, cookie <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (child <span style=color:#f92672>&lt;</span> children.size() <span style=color:#f92672>&amp;&amp;</span> cookie <span style=color:#f92672>&lt;</span> cookies.size()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (children[child] <span style=color:#f92672>&lt;=</span> cookies[cookie]) child<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        cookie<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> child;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=2-股票買賣問題>2. 股票買賣問題<a hidden class=anchor aria-hidden=true href=#2-股票買賣問題>#</a></h3><ul><li><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/>Leetcode 122. Best Timer to Buy and Sell Stock II</a></li><li>有一數列為某上市公司每日的股價，若手上最多只能有一張股票，要怎麼樣買賣可以得到最高獲利。<ul><li>最高獲利代表所有上升波段的總和，忽略所有下降波段。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxProfit</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> prices) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> last <span style=color:#f92672>=</span> prices[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> price : prices) {
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> (price <span style=color:#f92672>&gt;</span> last) <span style=color:#f92672>?</span> price <span style=color:#f92672>-</span> last : <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        last <span style=color:#f92672>=</span> price
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=3-跳躍遊戲>3. 跳躍遊戲<a hidden class=anchor aria-hidden=true href=#3-跳躍遊戲>#</a></h3><ul><li><a href=https://leetcode.com/problems/jump-game/>55. Jump Game</a></li><li>有一數列表示，在該 <code>i</code> 索引位置起，最多可以跳幾個索引長度，試問從索引值為 <code>0</code> 開始，可否到達索引值為 <code>n-1</code>。<ul><li>盡可能的往前跳，不斷的更新最遠可以到達的位置。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>canJump</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> reach <span style=color:#f92672>=</span> nums[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> nums.size() <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;=</span> reach; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> nums.size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        reach <span style=color:#f92672>=</span> max(reach, nums[i]<span style=color:#f92672>+</span>i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><hr><ul><li>回到目錄：<a href=/posts/cs/algo>[Algo] 演算法筆記</a></li><li>想要複習：<a href=/posts/cs/algo/brute_force>[Algo] 2-1. 暴力演算法</a></li><li>接著閱讀：<a href=/posts/cs/algo/divide_and_conquer>[Algo] 2-3. 分治法</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/cs/>CS</a></li><li><a href=https://intervalrain.github.io/tags/algo/>Algo</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/posts/cs/algo/divide_and_conquer/><span class=title>« Prev Page</span><br><span>[Algo] 2-3. 分治法 Divide and Conquer</span></a>
<a class=next href=https://intervalrain.github.io/posts/cs/algo/brute_force/><span class=title>Next Page »</span><br><span>[Algo] 2-1. 暴力演算法 Brute Force</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>