<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Algo] 2-3. 分治法 Divide and Conquer | Rain's Blog</title><meta name=keywords content="C++,Leetcode,Algorithm,分治法,divide and conquer"><meta name=description content="演算法設計，介紹什麼是分治法，分治法的核心思想與例題，與常見的一些技巧。"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="[Algo] 2-3. 分治法 Divide and Conquer"><meta property="og:description" content="演算法設計，介紹什麼是分治法，分治法的核心思想與例題，與常見的一些技巧。"><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/cs/algo/divide_and_conquer/"><meta property="og:image" content="http://intervalrain.github.io/images/faang.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-27T10:48:42+08:00"><meta property="article:modified_time" content="2023-01-27T10:48:42+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://intervalrain.github.io/images/faang.webp"><meta name=twitter:title content="[Algo] 2-3. 分治法 Divide and Conquer"><meta name=twitter:description content="演算法設計，介紹什麼是分治法，分治法的核心思想與例題，與常見的一些技巧。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[Algo] 2-3. 分治法 Divide and Conquer","item":"http://intervalrain.github.io/posts/cs/algo/divide_and_conquer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Algo] 2-3. 分治法 Divide and Conquer","name":"[Algo] 2-3. 分治法 Divide and Conquer","description":"演算法設計，介紹什麼是分治法，分治法的核心思想與例題，與常見的一些技巧。","keywords":["C++","Leetcode","Algorithm","分治法","divide and conquer"],"articleBody":"一、分治法 分治法，簡而言之就是分而治之，把複雜的問題分成兩個或更多個相似或相似的子問題，直到子問題可以直接求解，最後再將子問題的解做合併。 三步驟：Divide、Conquer、Merge 以 pseudo code 來表示大概像： void func(collection set) { // 子問題求解 if (base_case) { // 根據要求將子問題解合併成母問題解 do_something return; } // 將母問題分解成子問題 for (collection subset : set) { func(subset); } } graph LR; 母問題--\u003e子問題1; 母問題--\u003e子問題2; subgraph Divide 子問題1--\u003e最小子問題1; 子問題1--\u003e最小子問題2; 子問題2--\u003e最小子問題3; 子問題2--\u003e最小子問題4; end subgraph Conquer 最小子問題1--\u003e最小子問題解1; 最小子問題2--\u003e最小子問題解2; 最小子問題3--\u003e最小子問題解3; 最小子問題4--\u003e最小子問題解4; end subgraph Merge 最小子問題解1--\u003e合併; 最小子問題解2--\u003e合併; 最小子問題解3--\u003e合併; 最小子問題解4--\u003e合併; end 合併--\u003e母問題解 舉例說明，河內塔遊戲： 河內塔是由三根桿子以大小不同碟片所組成的遊戲，僧人一次可以從一根桿子移動一個碟片到另一根桿子，但是小的碟片若放憂大的碟片下面會使得小的碟片裂開(也就是碟片只能由上而下從小排到大)，試問將一座塔從一根桿子完整的移動到另一根桿子需要移動多少次。 思考上面的情形，以三個碟片為例，若我們要從 A 到 C 移動一座塔，我們可以將之分解成「如何把上面兩個碟片移動到 B」，因為剩下的一個大碟片，可以很簡單的從 A 移動到 C。也就是說 f3(A-\u003eC) = f2(A-\u003eB) + f1(A-\u003eC) + f2(B-\u003eC)。 再更進一步，f2(A-\u003eB) 和 f2(B-\u003eC) 其實就是移動兩個碟片到另一座塔，所以可以分解成 f2(A-\u003eC) = f1(A-\u003eB) + f1(A-\u003eC) + f1(B-\u003eC)，至此，我們已經把 f3 都分解成可以代表一次移動的最小子問題的解 f1 了： graph TD; A[f3,A-\u003eC] B[f2,A-\u003eB] C[f1,A-\u003eC] D[f2,B-\u003eC] E[f1,A-\u003eC] F[f1,A-\u003eB] G[f1,C-\u003eB] H[f1,B-\u003eA] I[f1,B-\u003eC] J[f1,A-\u003eC] A--\u003eB A---\u003eC A--\u003eD B--\u003eE B--\u003eF B--\u003eG D--\u003eH D--\u003eI D--\u003eJ 故我們可以以數學方式證明：\n\\(\\begin{array}{l} T(n)=T(n-1)+T(1)+T(n-1)=2T(n-1)+T(1)\\\\ T(n-1)=T(n-2)+T(1)+T(n-2)=2T(n-2)+T(1)\\\\ T(n)=2[2T(n-2)+T(1)]+T(1)\\\\ T(n)=2\\times2T(n-2)+(1+2)T(1)\\\\ T(n)=2^k\\times T(n-k)+(1+2+…+2^k)T(1)\\\\ 令k=n-1\\\\ T(n)=2^{n-1}\\times T(1)+(1+2+…+2^{n-1})T(1)\\\\ T(n)=2^{n-1}\\times T(1)+\\frac{2^{n-1}-1}{2-1}T(1)\\\\ T(n)=(2^n-1)\\times T(1) \\end{array}\\) 得所需要的移動次數為 \\(2^n-1\\) 次 分治法的特色 要解決的問題有一定的規模 該問題可以分解成若干個規模較小的問題 可以找到一個 base case，可以直接求解(如上述數學證明的\\(T(1)\\)) 分解出來的子問題都是相互獨立的。(若有相依性，則無法使用分治法) 分治法的時間複雜度 將規模為 n 的問題分為 k個規模為 n/m 的子問題去解，那麼可以得到\n\\(T(n)=kT(n/m)+f(n)\\) 二、分治法的應用 1. 二元搜索法 Binary Search 令有一已排序的數列，欲查找該數列中是否有數值 x。 由於該數列已經過排序，所以我們無需遍歷整個數列，我們可以選擇每次挑選數列的中間值，若目標比中間值大，則選擇大的那側再繼續做篩選，此法稱為二元搜索法，其時間複雜度可以從線性搜索法的 \\(O(n)\\) 降低到 \\(O(n\\log n)\\)。 int binarySearch(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c= right) { int mid = left + (right-left)/2; if (nums[mid] == target) return mid; else if (nums[mid] \u003c target) left = mid + 1; else if (nums[mid] \u003e target) right = mid - 1; } return -1; } 2. Strassen 矩陣乘法 試做一個矩陣\\(A\\)與矩陣\\(B\\)內積。 \\( A=\\left[\\begin{matrix}A_{11}\u0026A_{12}\\\\A_{21}\u0026A_{22}\\end{matrix}\\right], B=\\left[\\begin{matrix}B_{11}\u0026B_{12}\\\\B_{21}\u0026B_{22}\\end{matrix}\\right], C=\\left[\\begin{matrix}C_{11}\u0026C_{12}\\\\C_{21}\u0026C_{22}\\end{matrix}\\right],其中\\\\ \\left[\\begin{matrix}C_{11}\u0026C_{12}\\\\C_{21}\u0026C_{22}\\end{matrix}\\right]=\\left[\\begin{matrix}A_{11}\u0026A_{12}\\\\A_{21}\u0026A_{22}\\end{matrix}\\right]\\cdot\\left[\\begin{matrix}B_{11}\u0026B_{12}\\\\B_{21}\u0026B_{22}\\end{matrix}\\right] \\) 若通過一般展開可得\n\\( C_{11}=A_{11}\\cdot B_{11}+A_{12}\\cdot B_{21}\\\\ C_{12}=A_{11}\\cdot B_{12}+A_{12}\\cdot B_{22}\\\\ C_{21}=A_{21}\\cdot B_{11}+A_{22}\\cdot B_{21}\\\\ C_{22}=A_{21}\\cdot B_{12}+A_{22}\\cdot B_{22} \\) 從上可得計算兩個 \\(n\\cdot n\\) 的矩陣內積需要 兩個 \\(\\frac{n}{2}\\cdot\\frac{n}{2}\\) 的矩陣做 8 次的乘法加上 4 次的加法，其時間複雜度可以表示成： \\( T(n)=8T(\\frac{n}{2})+\\Theta(n^2)\\\\ T(\\frac{n}{2})=8T(\\frac{n}{4})+\\Theta({\\frac{n}{2}}^2)\\\\ T(n)=8\\left[{8T(\\frac{n}{4})+\\Theta({{(\\frac{n}{2}})}^2)}\\right]+\\Theta(n^2)\\\\ T(n)=8^2T(\\frac{n}{4})+\\Theta(n^2)+8\\Theta(\\frac{n^2}{4})=8^2T(\\frac{n}{4})+(1+2)\\Theta(n^2)\\\\ T(n)=8^kT(\\frac{n}{2^k})+(1+2+…+2^{k-1})\\Theta(n^2)\\\\ 令n=2^k\\\\ T(n)=n^3T(1)+(\\frac{n/2-1}{2-1})\\Theta(n^2)\\approx \\Theta(n^3) \\) 若使用 Strassen 演算法 同樣將矩陣\\(A,B,C\\)作分解，\\(時間\\Theta(1)\\) 創建 10 個 \\(\\frac{n}{2}\\cdot\\frac{n}{2}\\) 的矩陣 \\(S_1,S_2,…,S_{10}\\)，時間\\(\\Theta(n^2)\\)\n\\( S_1=B_{12}-B_{22}\\\\ S_2=A_{11}+A_{12}\\\\ S_3=A_{21}+A_{22}\\\\ S_4=B_{21}-B_{11}\\\\ S_5=A_{11}+A_{22}\\\\ S_6=B_{11}+B_{22}\\\\ S_7=A_{12}-A_{22}\\\\ S_8=B_{21}+B_{22}\\\\ S_9=A_{11}-A_{21}\\\\ S_{10}=B_{11}+B_{12}\\\\ \\) 遞迴的計算 7 個矩陣積 \\(P_1,P_2,…,P_7\\)，其中每個矩陣\\(P_i\\)都是\\(\\frac{n}{2}\\cdot\\frac{n}{2}\\)的。\n\\( P_1=A_{11}\\cdot S_1=A_{11}\\cdot B_{12}-A_{11}\\cdot B_{22}\\\\ P_2=S_2\\cdot B_{22}=A_{11}\\cdot B_{22}+A_{12}\\cdot B_{22}\\\\ P_3=S_3\\cdot B_{11}=A_{21}\\cdot B_{11}+A_{22}\\cdot B_{11}\\\\ P_4=A_{22}\\cdot S_4=A_{22}\\cdot B_{21}-A_{22}\\cdot B_{11}\\\\ P_5=S_5\\cdot S_6=A_{11}\\cdot B_{11}+A_{11}\\cdot B_{22}+A_{22}\\cdot B_{11}+A_{22}\\cdot B_{22}\\\\ P_6=S_7\\cdot S_8=A_{12}\\cdot B_{21}+A_{12}\\cdot B_{22}-A_{22}\\cdot B_{21}-A_{22}\\cdot B_{22}\\\\\\\\ P_7=S_9\\cdot S_{10}=A_{11}\\cdot B_{11}+A_{11}\\cdot B_{12}-A_{21}\\cdot B_{11}-A_{21}\\cdot B_{12}\\\\\\\\\\\\ \\) 藉由 \\(P_i\\) 來計算得到 矩陣 \\(C\\)：時間\\(\\Theta(n^2)\\)\n\\( C_{11}=P_5+P_4-P_2+P_6\\\\ C_{12}=P_1+P_2\\\\ C_{21}=P_3+P_4\\\\ C_{22}=P_5+P_1-P_3-P_7 \\) 綜合已上可得： \\( T(n)=\\bigg\\lbrace \\begin{array}{ll} \\Theta(1)\u0026若n=1\\\\ 7T{\\frac{n}{2}}+\\Theta(n^2)\u0026若n\u003e1 \\end{array} \\) 故時間複雜度可推得 \\(T(n)=\\Theta(n^{\\log_27})\\approx \\Theta(n^{2.807})\\) 參考來源 Wikipedia 3. 合併排序 Merge Sort 在[Algo] 0-4. 二元樹(Binary Tree)中有介紹過，合併排序跟快速排序都有著類似前序、後序的結構， 步驟： 將數列拆成若干個只有 1 個元素的子數列(因為只有一個元素，所有可以視為已排序的數列)。 將已排序的數列兩兩合併，直到所有的數列都合併完成，即完成排序。 程式碼實作：mergeSort 4. 快速排序 Quick Sort 步驟： 選定一個數當作樞紐(pivot)，將小於此數的值都放到左邊，大於此數的都放到右邊。 反覆同樣動作，直到子數列只有一個數，即完成排序。 程式碼實作：quickSort 三、例題 1. 樹類問題 樹相關的問題很常有著類似的解題結構：\n在 base state 時，直接回傳答案(base result)。 對根的節點做遞迴的處理 將遞迴過後的回傳值做處理之後回傳。 T function(TreeNode* root) { if (BASE_STATE) return BASE_RESULT; T left = function(root-\u003eleft); T right = function(root-\u003eright); T res = SOME_OPERATION(left, right, root); return res; } 1. Maxmium Binary Tree Leetcode 654. Maximum Binary Tree 給定一個數列，數列中的最大值為根，其索引值比根的索引值還小的子數列形成另一個子節，比根的索引值還大的子數列同樣形成另一個子節，以此類推。 以分治法的想法思考，我們會想得到一個函式 f(nums, s, e)，s 代表數列的最小索引值，e 代表數列的最大索引值，若 r 為該數列最大值的索引值，那麼我們應該會得到一個節點，其左子節點為 f(nums, s, r-1)，右子節點為 f(nums, r+1, e。 分治法的目標是要將問題由大化小，直到 base state 出現(即可以直接得到結果的一個狀態)，以此題而言就是當 s == e 或 s \u003c e 時， s == e 時，應該要回傳 new TreeNode(s)。 s \u003c e 時，應該要回傳 NULL。 根據上面的分析可以得到下面完整的程式碼： TreeNode* constructMaximumBinaryTree(vector\u003cint\u003e\u0026 nums) { return build(nums, 0, nums.size()-1); } TreeNode* build(vector\u003cint\u003e\u0026 nums, int start, int end) { if (start \u003e end) return nullptr; if (start == end) return new TreeNode(nums[start]); int r = start; for (int i = start; i \u003c= end; i++) { if (nums[i] \u003e nums[r]) r = i; // 找尋最大值的索引值 } TreeNode* left = build(nums, start, r-1); TreeNode* right = build(nums, r+1, end); return new TreeNode(nums[r], left, right); } 2.Balance a Binary Search Tree Leetcode 1382. Balance a Binary Search Tree 這題若想要用 rotate 的方式去思考會很難解，但若把它想成是一個已排序的數列，要進行 BST 的建樹的話，就非常簡單了。 首先我們想得到一個已排序的數列，我們可以用 inorder traversal(中序遍歷) 去收集所有的節點。 剩下的部分就跟Leetcode 108. Convert Sorted Array to Binary Search Tree一樣了，當我們將數列索引值正中間的節點擺在根節點，那麼一定會滿足其兩邊的深度差不超過 1。 用分治法的思維，我們會想得到一個函式f(vec, s, e)，s 代表數列的最小索引值，e代表數列的最大索引值，若 mid 為該數列最中間的索引值，那麼我們會得到一個節點，其左子節點為 f(vec, s, mid-1，右子節點為 f(vec, mid-1, e)。 其 base state 為 s == e 或 s \u003c e 時， s == e 時，回傳 vec[s]。 s \u003e e 時，回傳 NULL。 根據上面的分析可得完整的程式碼： TreeNode* balanceBST(TreeNode* root) { vector\u003cTreeNode*\u003e vec; collect(root, vec); return build(vec, 0, vec.size()-1); } // 中序遍歷以收集到已排序的節點數列 void collect(TreeNode* root, vector\u003cTreeNode*\u003e\u0026 vec) { if (!root) return; collect(root-\u003eleft,vec); vec.push_back(root); collect(root-\u003eright,vec); root-\u003eleft = nullptr; // 預先將節點之間的關係先清除 root-\u003eright = nullptr; } TreeNode* build(vector\u003cTreeNode*\u003e\u0026 vec, int start, int end) { if (start \u003e end) return nullptr; if (start == end) return vec[start]; int mid = start + (end-start)/2; // 求中間點 auto left = build(vec, start, mid-1); auto right = build(vec, mid+1, end); vec[mid]-\u003eleft = left; vec[mid]-\u003eright = right; return vec[mid]; } 從上面兩個範例可以發現，樹類應用分治法於建樹問題上，基本上有著分常相似的框架，基本上都是想辦法把大問題拆成若干個同質的小問題，直到拆成 base state 之後再將答案組合起來。 2. Quick Select Quick select 跟 quick sort 很類似，只是 quick select 選定一個 pivot 後，只針對一邊繼續做 select，假設每次都可以選到 median，則時間複雜度是 \\(O(n)+O(\\frac{n}{2})+O(\\frac{n}{4})+…+O(\\frac{n}{2^k})+O(1)=O(n)\\)。但也有可能每次都剛好選到最大值或最小值，則時間複雜度會退化成\\(O(n^2)\\)。 1. Kth Largest Element in an Array Leetcode 215. Kth Largest Element in an Array 這題正好可以運用上 Quick Select，若要用 C++ 中的內建函式 nth_element。 int findKthLargest(vector\u003cint\u003e\u0026 nums, int k) { k = nums.size()-k; nth_element(nums.begin(), nums.begin()+k, nums.end()); return nums[k]; } 以下為彷照其核心思想的實作： int findKthLargest(vector\u003cint\u003e\u0026 nums, int k) { return nth(nums, nums.size()-k); } int nth(vector\u003cint\u003e\u0026 nums, int k) { int left = 0; int right = nums.size()-1; while (left \u003c right) { int pivot = partition(nums, left, right); if (pivot \u003c k) { left = pivot+1; } else if (pivot \u003e k) { right = pivot-1; } else { break; } } return nums[k]; } // 避免時間複雜度退化成 O(n^2) 的方法, 確保每次選到的 pivot 都是相對中間的值 void med(vector\u003cint\u003e\u0026 nums, int left, int right) { int mid = left + (right-left)/2; if (nums[left] \u003e= nums[mid] \u0026\u0026 nums[mid] \u003e= nums[right]) { return; } else if (nums[left] \u003e= nums[mid] \u0026\u0026 nums[left] \u003e= nums[right]) { if (nums[mid] \u003e= nums[right]) { swap(nums[left], nums[mid]); } else { swap(nums[left], nums[right]); } } else if (nums[left] \u003c= nums[mid] \u0026\u0026 nums[left] \u003c= nums[right]) { if (nums[mid] \u003e= nums[right]) { swap(nums[left], nums[right]); } else { swap(nums[left], nums[mid]); } } } int partition(vector\u003cint\u003e\u0026 nums, int left, int right) { med(nums, left, right); int pivot = left; int i = left; int j = right+1; while (i \u003c j) { while (i \u003c right \u0026\u0026 nums[++i] \u003c nums[pivot]); while (j \u003e left \u0026\u0026 nums[pivot] \u003c nums[--j]); if (i \u003e= j) break; swap(nums[i], nums[j]); } swap(nums[pivot], nums[j]); return j; } 3. Binary Search 二元搜索法是經典的分治法應用之一，試想一個情景，若你有一本電話簿，已知電話簿是按照 alphabetical order 排序(按字母排序)，那麼你會使用什麼樣的策略快速的找到你想要找的人的電話號碼呢？ 假設我們要找的人叫作 Willy。 若用線性搜索法，從第一頁開始一頁一頁的找，直到找到 Willy，我們需要找完 A, B, C, ….,U, V 字首的名字才能找到 W 字首的頁面，也就是說其實 A - U 這段查找其實是多餘的，這樣的搜索法時間複雜度是 \\(O(n)\\)，寫成程式碼會是這樣： string findWilly(vector\u003cpair\u003cstring, string\u003e\u003e book) { for (int i = 0; i \u003c book.size(); i++) { if (book[i].first == \"Willy\") return book[i].second; } return \"Not Found\"; } 若用二元搜索法，我們可以任意從書的中間選一頁，若選到的字首在 W 之前，我們只需從這頁開始往後，再任選一頁；反之，若選到的字首在 W 之後，我們只需從這頁開始往前，再任選一頁，重覆上面的動作直到找到 W，再依同樣的方法，找第二個字母。這樣的搜索法，時間複雜度是 \\(O(\\log n)\\)，寫成程式碼會是這樣： string findWilly(vector\u003cpair\u003cstring, string\u003e\u003e book) { int left = 0, right = book.size()-1; while (left \u003c= right) { int mid = left + (right-left)/2; if (nums[mid].first == \"Willy\") return nums[mid].second; else if (nums[mid].first \u003c \"Willy\") left = mid + 1; else if (nums[mid].first \u003e \"Willy\") right = mid -1; } return \"Not Found\"; } + 其中 `int mid = left + (right-left)/2` 是求中間值的寫法，為什麼不寫成 `int mid = (left+right)/2` 的原因是，避免兩數相加會溢數。 遇到 strictly increase 的題目，二元搜索法的基本寫法如上，是左閉右閉的寫法，另一種常見的寫法是左閉右開的寫法。 當遇到非 strictly increase 的題型，就會伴隨著左限跟右限的題型出現，這部分的詳細內容會在之後二元搜索篇詳細介紹。 1. Binary Search 這題是最簡單的 Binary Search 實作，可以試試看。 Leetcode 704. Binary Search 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-2. 貪心演算法 接著閱讀：[Algo] 2-4. 回溯法 ","wordCount":"1083","inLanguage":"en","image":"http://intervalrain.github.io/images/faang.webp","datePublished":"2023-01-27T10:48:42+08:00","dateModified":"2023-01-27T10:48:42+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/cs/algo/divide_and_conquer/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=http://intervalrain.github.io/posts/csharp/csharp title=Csharp><span>Csharp</span></a></li><li><a href=http://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[Algo] 2-3. 分治法 Divide and Conquer</h1><div class=post-description>演算法設計，介紹什麼是分治法，分治法的核心思想與例題，與常見的一些技巧。</div><div class=post-meta><span title='2023-01-27 10:48:42 +0800 +0800'>January 27, 2023</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/CS/algo/divide_and_conquer.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e5%88%86%e6%b2%bb%e6%b3%95 aria-label=一、分治法>一、分治法</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%b2%bb%e6%b3%95%e7%9a%84%e6%87%89%e7%94%a8 aria-label=二、分治法的應用>二、分治法的應用</a><ul><li><a href=#1-%e4%ba%8c%e5%85%83%e6%90%9c%e7%b4%a2%e6%b3%95-binary-search aria-label="1. 二元搜索法 Binary Search">1. 二元搜索法 Binary Search</a></li><li><a href=#2-strassen-%e7%9f%a9%e9%99%a3%e4%b9%98%e6%b3%95 aria-label="2. Strassen 矩陣乘法">2. Strassen 矩陣乘法</a></li><li><a href=#3-%e5%90%88%e4%bd%b5%e6%8e%92%e5%ba%8f-merge-sort aria-label="3. 合併排序 Merge Sort">3. 合併排序 Merge Sort</a></li><li><a href=#4-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f-quick-sort aria-label="4. 快速排序 Quick Sort">4. 快速排序 Quick Sort</a></li></ul></li><li><a href=#%e4%b8%89%e4%be%8b%e9%a1%8c aria-label=三、例題>三、例題</a><ul><li><a href=#1-%e6%a8%b9%e9%a1%9e%e5%95%8f%e9%a1%8c aria-label="1. 樹類問題">1. 樹類問題</a><ul><li><a href=#1-maxmium-binary-tree aria-label="1. Maxmium Binary Tree">1. Maxmium Binary Tree</a></li><li><a href=#2balance-a-binary-search-tree aria-label="2.Balance a Binary Search Tree">2.Balance a Binary Search Tree</a></li></ul></li><li><a href=#2-quick-select aria-label="2. Quick Select">2. Quick Select</a><ul><li><a href=#1-kth-largest-element-in-an-array aria-label="1. Kth Largest Element in an Array">1. Kth Largest Element in an Array</a></li></ul></li><li><a href=#3-binary-search aria-label="3. Binary Search">3. Binary Search</a><ul><li><a href=#1-binary-search aria-label="1. Binary Search">1. Binary Search</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=一分治法>一、分治法<a hidden class=anchor aria-hidden=true href=#一分治法>#</a></h2><ul><li>分治法，簡而言之就是分而治之，把複雜的問題分成兩個或更多個相似或相似的子問題，直到子問題可以直接求解，最後再將子問題的解做合併。</li><li>三步驟：<code>Divide</code>、<code>Conquer</code>、<code>Merge</code></li><li>以 pseudo code 來表示大概像：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(collection set) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 子問題求解
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (base_case) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根據要求將子問題解合併成母問題解
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        do_something
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 將母問題分解成子問題
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (collection subset : set) {
</span></span><span style=display:flex><span>        func(subset);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><div class=mermaid>graph LR;
母問題-->子問題1;
母問題-->子問題2;
subgraph Divide
子問題1-->最小子問題1;
子問題1-->最小子問題2;
子問題2-->最小子問題3;
子問題2-->最小子問題4;
end
subgraph Conquer
最小子問題1-->最小子問題解1;
最小子問題2-->最小子問題解2;
最小子問題3-->最小子問題解3;
最小子問題4-->最小子問題解4;
end
subgraph Merge
最小子問題解1-->合併;
最小子問題解2-->合併;
最小子問題解3-->合併;
最小子問題解4-->合併;
end
合併-->母問題解</div><ul><li>舉例說明，河內塔遊戲：
<img loading=lazy src=https://pic3.zhimg.com/v2-62f8246d7a1c955f1b7206171cca14ce_r.jpg alt=hanoi><ul><li>河內塔是由三根桿子以大小不同碟片所組成的遊戲，僧人一次可以從一根桿子移動一個碟片到另一根桿子，但是小的碟片若放憂大的碟片下面會使得小的碟片裂開(也就是碟片只能由上而下從小排到大)，試問將一座塔從一根桿子完整的移動到另一根桿子需要移動多少次。
<img loading=lazy src=http://notepad.yehyeh.net/Content/DS/CH02/img/TowerOfHanoiStep.png alt=solve></li><li>思考上面的情形，以三個碟片為例，若我們要從 <code>A</code> 到 <code>C</code> 移動一座塔，我們可以將之分解成「如何把上面兩個碟片移動到 <code>B</code>」，因為剩下的一個大碟片，可以很簡單的從 <code>A</code> 移動到 <code>C</code>。也就是說 <code>f3(A->C) = f2(A->B) + f1(A->C) + f2(B->C)</code>。</li><li>再更進一步，<code>f2(A->B)</code> 和 <code>f2(B->C)</code> 其實就是移動兩個碟片到另一座塔，所以可以分解成 <code>f2(A->C) = f1(A->B) + f1(A->C) + f1(B->C)</code>，至此，我們已經把 <code>f3</code> 都分解成可以代表<strong>一次移動</strong>的最小子問題的解 <code>f1</code> 了：<div class=mermaid>graph TD;
A[f3,A->C]
B[f2,A->B]
C[f1,A->C]
D[f2,B->C]
E[f1,A->C]
F[f1,A->B]
G[f1,C->B]
H[f1,B->A]
I[f1,B->C]
J[f1,A->C]
A-->B
A--->C
A-->D
B-->E
B-->F
B-->G
D-->H
D-->I
D-->J</div></li><li>故我們可以以數學方式證明：<br>\(\begin{array}{l}
T(n)=T(n-1)+T(1)+T(n-1)=2T(n-1)+T(1)\\
T(n-1)=T(n-2)+T(1)+T(n-2)=2T(n-2)+T(1)\\
T(n)=2[2T(n-2)+T(1)]+T(1)\\
T(n)=2\times2T(n-2)+(1+2)T(1)\\
T(n)=2^k\times T(n-k)+(1+2+&mldr;+2^k)T(1)\\
令k=n-1\\
T(n)=2^{n-1}\times T(1)+(1+2+&mldr;+2^{n-1})T(1)\\
T(n)=2^{n-1}\times T(1)+\frac{2^{n-1}-1}{2-1}T(1)\\
T(n)=(2^n-1)\times T(1)
\end{array}\)</li><li>得所需要的移動次數為 \(2^n-1\) 次</li></ul></li><li>分治法的特色<ol><li>要解決的問題有一定的規模</li><li>該問題可以分解成若干個規模較小的問題</li><li>可以找到一個 base case，可以直接求解(如上述數學證明的\(T(1)\))</li><li>分解出來的子問題都是相互獨立的。(若有相依性，則無法使用分治法)</li></ol></li><li>分治法的時間複雜度<ul><li>將規模為 <code>n</code> 的問題分為 <code>k</code>個規模為 <code>n/m</code> 的子問題去解，那麼可以得到<br>\(T(n)=kT(n/m)+f(n)\)</li></ul></li></ul><h2 id=二分治法的應用>二、分治法的應用<a hidden class=anchor aria-hidden=true href=#二分治法的應用>#</a></h2><h3 id=1-二元搜索法-binary-search>1. 二元搜索法 Binary Search<a hidden class=anchor aria-hidden=true href=#1-二元搜索法-binary-search>#</a></h3><ul><li>令有一<strong>已排序</strong>的數列，欲查找該數列中是否有數值 <code>x</code>。<ul><li>由於該數列已經過排序，所以我們無需遍歷整個數列，我們可以選擇每次挑選數列的中間值，若目標比中間值大，則選擇大的那側再繼續做篩選，此法稱為二元搜索法，其時間複雜度可以從線性搜索法的 \(O(n)\) 降低到 \(O(n\log n)\)。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>binarySearch</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, right <span style=color:#f92672>=</span> nums.size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right<span style=color:#f92672>-</span>left)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nums[mid] <span style=color:#f92672>==</span> target)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> mid;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nums[mid] <span style=color:#f92672>&lt;</span> target) 
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nums[mid] <span style=color:#f92672>&gt;</span> target)
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=2-strassen-矩陣乘法>2. Strassen 矩陣乘法<a hidden class=anchor aria-hidden=true href=#2-strassen-矩陣乘法>#</a></h3><ul><li>試做一個矩陣\(A\)與矩陣\(B\)內積。<ul><li>\(
A=\left[\begin{matrix}A_{11}&A_{12}\\A_{21}&A_{22}\end{matrix}\right],
B=\left[\begin{matrix}B_{11}&B_{12}\\B_{21}&B_{22}\end{matrix}\right],
C=\left[\begin{matrix}C_{11}&C_{12}\\C_{21}&C_{22}\end{matrix}\right],其中\\
\left[\begin{matrix}C_{11}&C_{12}\\C_{21}&C_{22}\end{matrix}\right]=\left[\begin{matrix}A_{11}&A_{12}\\A_{21}&A_{22}\end{matrix}\right]\cdot\left[\begin{matrix}B_{11}&B_{12}\\B_{21}&B_{22}\end{matrix}\right]
\)</li><li>若通過一般展開可得<br>\(
C_{11}=A_{11}\cdot B_{11}+A_{12}\cdot B_{21}\\
C_{12}=A_{11}\cdot B_{12}+A_{12}\cdot B_{22}\\
C_{21}=A_{21}\cdot B_{11}+A_{22}\cdot B_{21}\\
C_{22}=A_{21}\cdot B_{12}+A_{22}\cdot B_{22}
\)</li><li>從上可得計算兩個 \(n\cdot n\) 的矩陣內積需要 兩個 \(\frac{n}{2}\cdot\frac{n}{2}\) 的矩陣做 8 次的乘法加上 4 次的加法，其時間複雜度可以表示成：<ul><li>\(
T(n)=8T(\frac{n}{2})+\Theta(n^2)\\
T(\frac{n}{2})=8T(\frac{n}{4})+\Theta({\frac{n}{2}}^2)\\
T(n)=8\left[{8T(\frac{n}{4})+\Theta({{(\frac{n}{2}})}^2)}\right]+\Theta(n^2)\\
T(n)=8^2T(\frac{n}{4})+\Theta(n^2)+8\Theta(\frac{n^2}{4})=8^2T(\frac{n}{4})+(1+2)\Theta(n^2)\\
T(n)=8^kT(\frac{n}{2^k})+(1+2+&mldr;+2^{k-1})\Theta(n^2)\\
令n=2^k\\
T(n)=n^3T(1)+(\frac{n/2-1}{2-1})\Theta(n^2)\approx \Theta(n^3)
\)</li></ul></li><li>若使用 Strassen 演算法<ol><li>同樣將矩陣\(A,B,C\)作分解，\(時間\Theta(1)\)</li><li>創建 10 個 \(\frac{n}{2}\cdot\frac{n}{2}\) 的矩陣 \(S_1,S_2,&mldr;,S_{10}\)，時間\(\Theta(n^2)\)<br>\(
S_1=B_{12}-B_{22}\\
S_2=A_{11}+A_{12}\\
S_3=A_{21}+A_{22}\\
S_4=B_{21}-B_{11}\\
S_5=A_{11}+A_{22}\\
S_6=B_{11}+B_{22}\\
S_7=A_{12}-A_{22}\\
S_8=B_{21}+B_{22}\\
S_9=A_{11}-A_{21}\\
S_{10}=B_{11}+B_{12}\\
\)</li><li>遞迴的計算 7 個矩陣積 \(P_1,P_2,&mldr;,P_7\)，其中每個矩陣\(P_i\)都是\(\frac{n}{2}\cdot\frac{n}{2}\)的。<br>\(
P_1=A_{11}\cdot S_1=A_{11}\cdot B_{12}-A_{11}\cdot B_{22}\\
P_2=S_2\cdot B_{22}=A_{11}\cdot B_{22}+A_{12}\cdot B_{22}\\
P_3=S_3\cdot B_{11}=A_{21}\cdot B_{11}+A_{22}\cdot B_{11}\\
P_4=A_{22}\cdot S_4=A_{22}\cdot B_{21}-A_{22}\cdot B_{11}\\
P_5=S_5\cdot S_6=A_{11}\cdot B_{11}+A_{11}\cdot B_{22}+A_{22}\cdot B_{11}+A_{22}\cdot B_{22}\\
P_6=S_7\cdot S_8=A_{12}\cdot B_{21}+A_{12}\cdot B_{22}-A_{22}\cdot B_{21}-A_{22}\cdot B_{22}\\\\
P_7=S_9\cdot S_{10}=A_{11}\cdot B_{11}+A_{11}\cdot B_{12}-A_{21}\cdot B_{11}-A_{21}\cdot B_{12}\\\\\\
\)</li><li>藉由 \(P_i\) 來計算得到 矩陣 \(C\)：時間\(\Theta(n^2)\)<br>\(
C_{11}=P_5+P_4-P_2+P_6\\
C_{12}=P_1+P_2\\
C_{21}=P_3+P_4\\
C_{22}=P_5+P_1-P_3-P_7
\)</li></ol><ul><li>綜合已上可得：<ul><li>\(
T(n)=\bigg\lbrace
\begin{array}{ll}
\Theta(1)&若n=1\\
7T{\frac{n}{2}}+\Theta(n^2)&若n>1
\end{array}
\)</li><li>故時間複雜度可推得 \(T(n)=\Theta(n^{\log_27})\approx \Theta(n^{2.807})\)</li></ul></li><li>參考來源 <a href=https://zh.wikipedia.org/wiki/%E6%96%BD%E7%89%B9%E6%8B%89%E6%A3%AE%E6%BC%94%E7%AE%97%E6%B3%95>Wikipedia</a></li></ul></li></ul></li></ul><h3 id=3-合併排序-merge-sort>3. 合併排序 Merge Sort<a hidden class=anchor aria-hidden=true href=#3-合併排序-merge-sort>#</a></h3><ul><li>在<a href=/posts/cs/algo/binary_tree>[Algo] 0-4. 二元樹(Binary Tree)</a>中有介紹過，<strong>合併排序</strong>跟<strong>快速排序</strong>都有著類似前序、後序的結構，</li><li>步驟：<ol><li>將數列拆成若干個只有 1 個元素的子數列(因為只有一個元素，所有可以視為已排序的數列)。</li><li>將已排序的數列兩兩合併，直到所有的數列都合併完成，即完成排序。</li></ol></li><li>程式碼實作：<a href=https://github.com/intervalrain/Cpp/blob/main/algo/sorting/mergeSort.cpp>mergeSort</a></li></ul><h3 id=4-快速排序-quick-sort>4. 快速排序 Quick Sort<a hidden class=anchor aria-hidden=true href=#4-快速排序-quick-sort>#</a></h3><ul><li>步驟：<ol><li>選定一個數當作樞紐(pivot)，將小於此數的值都放到左邊，大於此數的都放到右邊。</li><li>反覆同樣動作，直到子數列只有一個數，即完成排序。</li></ol></li><li>程式碼實作：<a href=https://github.com/intervalrain/Cpp/blob/main/algo/sorting/quickSort.cpp>quickSort</a></li></ul><h2 id=三例題>三、例題<a hidden class=anchor aria-hidden=true href=#三例題>#</a></h2><h3 id=1-樹類問題>1. 樹類問題<a hidden class=anchor aria-hidden=true href=#1-樹類問題>#</a></h3><ul><li><p>樹相關的問題很常有著類似的解題結構：</p><ul><li>在 <strong>base state</strong> 時，直接回傳答案(<strong>base result</strong>)。</li><li>對根的節點做遞迴的處理</li><li>將遞迴過後的回傳值做處理之後回傳。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>T <span style=color:#a6e22e>function</span>(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (BASE_STATE) <span style=color:#66d9ef>return</span> BASE_RESULT;
</span></span><span style=display:flex><span>    T left <span style=color:#f92672>=</span> function(root<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>    T right <span style=color:#f92672>=</span> function(root<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>    T res <span style=color:#f92672>=</span> SOME_OPERATION(left, right, root);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=1-maxmium-binary-tree>1. Maxmium Binary Tree<a hidden class=anchor aria-hidden=true href=#1-maxmium-binary-tree>#</a></h4><ul><li><a href=https://leetcode.com/problems/maximum-binary-tree/>Leetcode 654. Maximum Binary Tree</a></li><li>給定一個數列，數列中的最大值為根，其索引值比根的索引值還小的子數列形成另一個子節，比根的索引值還大的子數列同樣形成另一個子節，以此類推。
<img loading=lazy src=https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg alt="max barytree"><ul><li>以分治法的想法思考，我們會想得到一個函式 <code>f(nums, s, e)</code>，<code>s</code> 代表數列的最小索引值，<code>e</code> 代表數列的最大索引值，若 <code>r</code> 為該數列最大值的索引值，那麼我們應該會得到一個節點，其左子節點為 <code>f(nums, s, r-1)</code>，右子節點為 <code>f(nums, r+1, e</code>。</li><li>分治法的目標是要將問題由大化小，直到 <strong>base state</strong> 出現(即可以直接得到結果的一個狀態)，以此題而言就是當 <code>s == e</code> 或 <code>s &lt; e</code> 時，<ul><li><code>s == e</code> 時，應該要回傳 <code>new TreeNode(s)</code>。</li><li><code>s &lt; e</code> 時，應該要回傳 <code>NULL</code>。</li></ul></li><li>根據上面的分析可以得到下面完整的程式碼：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>TreeNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>constructMaximumBinaryTree</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> build(nums, <span style=color:#ae81ff>0</span>, nums.size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>TreeNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> start, <span style=color:#66d9ef>int</span> end) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (start <span style=color:#f92672>&gt;</span> end) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (start <span style=color:#f92672>==</span> end) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> TreeNode(nums[start]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> start;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> start; i <span style=color:#f92672>&lt;=</span> end; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nums[i] <span style=color:#f92672>&gt;</span> nums[r]) r <span style=color:#f92672>=</span> i;       <span style=color:#75715e>// 找尋最大值的索引值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    TreeNode<span style=color:#f92672>*</span> left <span style=color:#f92672>=</span> build(nums, start, r<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    TreeNode<span style=color:#f92672>*</span> right <span style=color:#f92672>=</span> build(nums, r<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, end);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> TreeNode(nums[r], left, right);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h4 id=2balance-a-binary-search-tree>2.Balance a Binary Search Tree<a hidden class=anchor aria-hidden=true href=#2balance-a-binary-search-tree>#</a></h4><ul><li><a href=https://leetcode.com/problems/balance-a-binary-search-tree/>Leetcode 1382. Balance a Binary Search Tree</a>
<img loading=lazy src=https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg alt="balance BST"></li><li>這題若想要用 rotate 的方式去思考會很難解，但若把它想成是一個已排序的數列，要進行 BST 的建樹的話，就非常簡單了。</li><li>首先我們想得到一個已排序的數列，我們可以用 <code>inorder traversal(中序遍歷)</code> 去收集所有的節點。</li><li>剩下的部分就跟<a href=https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree>Leetcode 108. Convert Sorted Array to Binary Search Tree</a>一樣了，當我們將數列索引值正中間的節點擺在根節點，那麼一定會滿足其兩邊的深度差不超過 1。</li><li>用分治法的思維，我們會想得到一個函式<code>f(vec, s, e)</code>，<code>s</code> 代表數列的最小索引值，<code>e</code>代表數列的最大索引值，若 <code>mid</code> 為該數列最中間的索引值，那麼我們會得到一個節點，其左子節點為 <code>f(vec, s, mid-1</code>，右子節點為 <code>f(vec, mid-1, e)</code>。</li><li>其 <strong>base state</strong> 為 <code>s == e</code> 或 <code>s &lt; e</code> 時，<ul><li><code>s == e</code> 時，回傳 <code>vec[s]</code>。</li><li><code>s > e</code> 時，回傳 <code>NULL</code>。</li></ul></li><li>根據上面的分析可得完整的程式碼：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>    TreeNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>balanceBST</span>(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>*&gt;</span> vec;
</span></span><span style=display:flex><span>    collect(root, vec);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> build(vec, <span style=color:#ae81ff>0</span>, vec.size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 中序遍歷以收集到已排序的節點數列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>collect</span>(TreeNode<span style=color:#f92672>*</span> root, vector<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>*&gt;&amp;</span> vec) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    collect(root<span style=color:#f92672>-&gt;</span>left,vec);
</span></span><span style=display:flex><span>    vec.push_back(root);
</span></span><span style=display:flex><span>    collect(root<span style=color:#f92672>-&gt;</span>right,vec);
</span></span><span style=display:flex><span>    root<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;   <span style=color:#75715e>// 預先將節點之間的關係先清除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    root<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>TreeNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>build</span>(vector<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>*&gt;&amp;</span> vec, <span style=color:#66d9ef>int</span> start, <span style=color:#66d9ef>int</span> end) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (start <span style=color:#f92672>&gt;</span> end) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (start <span style=color:#f92672>==</span> end) <span style=color:#66d9ef>return</span> vec[start];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> start <span style=color:#f92672>+</span> (end<span style=color:#f92672>-</span>start)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;        <span style=color:#75715e>// 求中間點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>auto</span> left <span style=color:#f92672>=</span> build(vec, start, mid<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> right <span style=color:#f92672>=</span> build(vec, mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, end);
</span></span><span style=display:flex><span>    vec[mid]<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>=</span> left;
</span></span><span style=display:flex><span>    vec[mid]<span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>=</span> right;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> vec[mid];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>從上面兩個範例可以發現，樹類應用分治法於建樹問題上，基本上有著分常相似的框架，基本上都是想辦法把大問題拆成若干個同質的小問題，直到拆成 <strong>base state</strong> 之後再將答案組合起來。</li></ul></li></ul><h3 id=2-quick-select>2. Quick Select<a hidden class=anchor aria-hidden=true href=#2-quick-select>#</a></h3><ul><li>Quick select 跟 quick sort 很類似，只是 quick select 選定一個 pivot 後，只針對一邊繼續做 select，假設每次都可以選到 median，則時間複雜度是 \(O(n)+O(\frac{n}{2})+O(\frac{n}{4})+&mldr;+O(\frac{n}{2^k})+O(1)=O(n)\)。但也有可能每次都剛好選到最大值或最小值，則時間複雜度會退化成\(O(n^2)\)。<h4 id=1-kth-largest-element-in-an-array>1. Kth Largest Element in an Array<a hidden class=anchor aria-hidden=true href=#1-kth-largest-element-in-an-array>#</a></h4><ul><li><a href=https://leetcode.com/problems/kth-largest-element-in-an-array/>Leetcode 215. Kth Largest Element in an Array</a></li><li>這題正好可以運用上 Quick Select，若要用 C++ 中的內建函式 <code>nth_element</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>findKthLargest</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>k <span style=color:#f92672>=</span> nums.size()<span style=color:#f92672>-</span>k;
</span></span><span style=display:flex><span>nth_element(nums.begin(), nums.begin()<span style=color:#f92672>+</span>k, nums.end());
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> nums[k];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>以下為彷照其核心思想的實作：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>findKthLargest</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> nth(nums, nums.size()<span style=color:#f92672>-</span>k);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>nth</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> nums.size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&lt;</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> partition(nums, left, right);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pivot <span style=color:#f92672>&lt;</span> k) {
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> pivot<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pivot <span style=color:#f92672>&gt;</span> k) {
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> pivot<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> nums[k];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 避免時間複雜度退化成 O(n^2) 的方法, 確保每次選到的 pivot 都是相對中間的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>med</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right<span style=color:#f92672>-</span>left)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (nums[left] <span style=color:#f92672>&gt;=</span> nums[mid] <span style=color:#f92672>&amp;&amp;</span> nums[mid] <span style=color:#f92672>&gt;=</span> nums[right]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nums[left] <span style=color:#f92672>&gt;=</span> nums[mid] <span style=color:#f92672>&amp;&amp;</span> nums[left] <span style=color:#f92672>&gt;=</span> nums[right]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nums[mid] <span style=color:#f92672>&gt;=</span> nums[right]) {
</span></span><span style=display:flex><span>            swap(nums[left], nums[mid]);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            swap(nums[left], nums[right]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nums[left] <span style=color:#f92672>&lt;=</span> nums[mid] <span style=color:#f92672>&amp;&amp;</span> nums[left] <span style=color:#f92672>&lt;=</span> nums[right]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nums[mid] <span style=color:#f92672>&gt;=</span> nums[right]) {
</span></span><span style=display:flex><span>            swap(nums[left], nums[right]);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            swap(nums[left], nums[mid]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>    med(nums, left, right);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> left;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> right<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> right <span style=color:#f92672>&amp;&amp;</span> nums[<span style=color:#f92672>++</span>i] <span style=color:#f92672>&lt;</span> nums[pivot]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (j <span style=color:#f92672>&gt;</span> left <span style=color:#f92672>&amp;&amp;</span> nums[pivot] <span style=color:#f92672>&lt;</span> nums[<span style=color:#f92672>--</span>j]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> j) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        swap(nums[i], nums[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    swap(nums[pivot], nums[j]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> j;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=3-binary-search>3. Binary Search<a hidden class=anchor aria-hidden=true href=#3-binary-search>#</a></h3><ul><li>二元搜索法是經典的分治法應用之一，試想一個情景，若你有一本電話簿，已知電話簿是按照 alphabetical order 排序(按字母排序)，那麼你會使用什麼樣的策略快速的找到你想要找的人的電話號碼呢？<ul><li>假設我們要找的人叫作 Willy。</li><li>若用線性搜索法，從第一頁開始一頁一頁的找，直到找到 Willy，我們需要找完 A, B, C, &mldr;.,U, V 字首的名字才能找到 W 字首的頁面，也就是說其實 A - U 這段查找其實是多餘的，這樣的搜索法時間複雜度是 \(O(n)\)，寫成程式碼會是這樣：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>string <span style=color:#a6e22e>findWilly</span>(vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>string, string<span style=color:#f92672>&gt;&gt;</span> book) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> book.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (book[i].first <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Willy&#34;</span>) <span style=color:#66d9ef>return</span> book[i].second;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Not Found&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>若用二元搜索法，我們可以任意從書的中間選一頁，若選到的字首在 W 之前，我們只需從這頁開始往後，再任選一頁；反之，若選到的字首在 W 之後，我們只需從這頁開始往前，再任選一頁，重覆上面的動作直到找到 W，再依同樣的方法，找第二個字母。這樣的搜索法，時間複雜度是 \(O(\log n)\)，寫成程式碼會是這樣：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>string <span style=color:#a6e22e>findWilly</span>(vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>string, string<span style=color:#f92672>&gt;&gt;</span> book) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, right <span style=color:#f92672>=</span> book.size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&lt;=</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right<span style=color:#f92672>-</span>left)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nums[mid].first <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Willy&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> nums[mid].second;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nums[mid].first <span style=color:#f92672>&lt;</span> <span style=color:#e6db74>&#34;Willy&#34;</span>)
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nums[mid].first <span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;Willy&#34;</span>)
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Not Found&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre><code>  + 其中 `int mid = left + (right-left)/2` 是求中間值的寫法，為什麼不寫成 `int mid = (left+right)/2` 的原因是，避免兩數相加會溢數。
</code></pre><ul><li>遇到 strictly increase 的題目，二元搜索法的基本寫法如上，是左閉右閉的寫法，另一種常見的寫法是左閉右開的寫法。</li><li>當遇到非 strictly increase 的題型，就會伴隨著左限跟右限的題型出現，這部分的詳細內容會在之後二元搜索篇詳細介紹。</li></ul><h4 id=1-binary-search>1. Binary Search<a hidden class=anchor aria-hidden=true href=#1-binary-search>#</a></h4><ul><li>這題是最簡單的 Binary Search 實作，可以試試看。</li><li><a href=https://leetcode.com/problems/binary-search/>Leetcode 704. Binary Search</a></li></ul></li></ul><hr><ul><li>回到目錄：<a href=/posts/cs/algo>[Algo] 演算法筆記</a></li><li>想要複習：<a href=/posts/cs/algo/greedy>[Algo] 2-2. 貪心演算法</a></li><li>接著閱讀：<a href=/posts/cs/algo/backtracking>[Algo] 2-4. 回溯法</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/cs/>CS</a></li><li><a href=http://intervalrain.github.io/tags/algo/>Algo</a></li></ul><nav class=paginav><a class=prev href=http://intervalrain.github.io/posts/cs/algo/backtracking/><span class=title>« Prev Page</span><br><span>[Algo] 2-4. 回溯法 Backtracking</span></a>
<a class=next href=http://intervalrain.github.io/posts/cs/algo/greedy/><span class=title>Next Page »</span><br><span>[Algo] 2-2. 貪心演算法 Greedy</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>