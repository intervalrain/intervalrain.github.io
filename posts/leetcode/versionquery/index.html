<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Problem] Version Query | Rain's Blog</title><meta name=keywords content="Algorithm"><meta name=description content="Version Query
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.
The given apk_info structure is given as below.
struct apk_info {
int apk_version;
int min_version = 1;
int max_version = INT_MAX;
}"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="[Problem] Version Query"><meta property="og:description" content="Version Query
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.
The given apk_info structure is given as below.
struct apk_info {
int apk_version;
int min_version = 1;
int max_version = INT_MAX;
}"><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/leetcode/versionquery/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-20T22:29:15+08:00"><meta property="article:modified_time" content="2022-10-20T22:29:15+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[Problem] Version Query"><meta name=twitter:description content="Version Query
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.
The given apk_info structure is given as below.
struct apk_info {
int apk_version;
int min_version = 1;
int max_version = INT_MAX;
}"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[Problem] Version Query","item":"http://intervalrain.github.io/posts/leetcode/versionquery/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Problem] Version Query","name":"[Problem] Version Query","description":"Version Query\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.\nThe given apk_info structure is given as below.\nstruct apk_info {\nint apk_version;\nint min_version = 1;\nint max_version = INT_MAX;\n}","keywords":["Algorithm"],"articleBody":"Version Query\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.\nThe given apk_info structure is given as below.\nstruct apk_info {\nint apk_version;\nint min_version = 1;\nint max_version = INT_MAX;\n}\nExample 1:\n\\(\\begin{array}{|l|}\\hline \\text{Input: }\\\\ \\begin{array}{|c|c|c|}\\hline \\text{apk version}\u0026\\text{min OS version}\u0026\\text{max OS version}\\\\\\hline \\text{1}\u0026\\text{14}\u0026\\text{}\\\\\\hline \\text{2}\u0026\\text{}\u0026\\text{8}\\\\\\hline \\text{3}\u0026\\text{12}\u0026\\text{16}\\\\\\hline \\end{array}\\\\ \\text{OS version query = [18,4,14,10]}\\\\\\\\ \\text{Output:}\\\\\\text{apk version = [1,2,3,0]}(0 \\text{ means not found})\\\\\\hline \\end{array}\\)\nConstraints:\n\\(\\begin{array}{|l|}\\hline \\text{1. 1} \\le \\text{Apk version \u003c } 10^{31}\\\\ \\text{2. 1} \\le \\text{OS version \u003c } 10^{31}\\\\ \\text{3. 1} \\le \\text{Query times \u003c } 10^{31}\\\\\\hline \\end{array}\\)\n二、分析 重點其實就是區間求極值，所以筆者最先開始想到的是線段樹，線段樹的介紹可參考這裡：Segment Tree 線段樹 爾後才想到這題其實概念上很接近 Leetcode 218. The Skyline Problem 上這張題後就懂了，把 apk version 看成建築的高度， min OS version 與 max OS version 看成建築的 x 座標，就變成一樣的題目了，差別在於把 skyline 建成之後，再對其作 binary search。 三、解題 Priority Queue struct apk_info{ int apk_version; int min_version = 1; int max_version = INT_MAX; apk_info(int ver, int mn, int mx){ this-\u003eapk_version = ver; this-\u003emin_version = mn; this-\u003emax_version = mx; } }; class Solution { public: unordered_map\u003cint, int\u003e waitList; void remove(priority_queue\u003cint\u003e\u0026 pq, int item){ if (pq.top() == item) { // 若 pq 的頂是要移除的對象，則直接移除 pq.pop(); while (waitList.find(pq.top()) != waitList.end() \u0026\u0026 waitList[pq.top()] \u003e 0) { waitList[pq.top()]--; pq.pop(); } } else { waitList[item]++; // 若 pq 的頂非要移除的對象，則加入 waitList，待之後再移除 } } vector\u003cpair\u003cint,int\u003e\u003e getRangeMax(vector\u003capk_info*\u003e infos) { vector\u003cpair\u003cint,int\u003e\u003e rangeMax, osVers; for (const auto\u0026 info : infos) { osVers.push_back({info-\u003emin_version, -info-\u003eapk_version}); // 以負值代表 skyline 的開始 osVers.push_back({info-\u003emax_version, info-\u003eapk_version}); // 以正值代表 skyline 的結束 } sort(osVers.begin(), osVers.end()); // 以 x 值(os_version) 進行排序 priority_queue\u003cint\u003e pq; pq.push(0); // not found 時，預設回傳 0 int prev = 0; // 在還沒插入 item 前一開始的最大值就是 0 for (const auto\u0026 osVer : osVers) { if (osVer.second \u003c 0){ // 開始 pq.push(-osVer.second); } else { // 結束，需移除該點 remove(pq, osVer.second); } int curr = pq.top(); if (prev != curr) { // 若最大值有變，則需把 skyline 記錄下來 if (prev \u003c curr || osVer.first == INT_MAX) rangeMax.push_back({osVer.first, curr}); // x 軸為 os version，y 軸為 apk version else // 為做成 [a, b) 左閉右開的區間，若 skyline 往下，x 軸的點位置需加 1 (版本以大的為主) rangeMax.push_back({osVer.first+1, curr}); prev = curr; } } return rangeMax; } public: vector\u003cint\u003e findOSVersion(vector\u003capk_info*\u003e infos, vector\u003cint\u003e queries) { vector\u003cpair\u003cint,int\u003e\u003e rangeMax = getRangeMax(infos); // 以範例來說會回傳 [[1,2],[9,0],[12,3],[17,1],[INT_MAX, 0]] vector\u003cint\u003e res; for (const int\u0026 q : queries){ auto it = upper_bound(rangeMax.begin(), rangeMax.end(), make_pair(q, INT_MAX)); // 開區間找上限後，往前推一位 it--; res.push_back(it-\u003esecond); } return res; } }; // test case int main(){ apk_info* a1 = new apk_info(1, 14, INT_MAX); apk_info* a2 = new apk_info(2, 1, 8); apk_info* a3 = new apk_info(3, 12, 16); vector\u003capk_info*\u003e infos = {a1, a2, a3}; vector\u003cint\u003e queries = {18,4,14,10}; // 1, 2, 3, 0 Solution* sol = new Solution(); vector\u003cint\u003e res = sol-\u003efindOSVersion(infos, queries); for (int i = 0; i \u003c res.size(); i++){ cout \u003c\u003c res[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; return 0; } 補充(segment tree) 用segment tree 來解區域更新的題目時，若把每個子葉點退化到單點的話，其空間複雜度會太高，可以用兩個 map 由左到右將 x 軸從小到大帶入，每個索引值 i 對應到一個有使用到的 x 軸座標。然後用左閉右開(\\([a,b)\\))的方式去維護區間的值。 在用segment tree 做區域更新時，若每次都對所有子葉做更新的話，其時間複雜度會拉高到\\(O(k)\\)，\\(k\\) 為線段長。其下 slash 掉的部分，在 the skyline problem 中會造成 TLE，所以我們每次只對其必要的點做更新，待全部資料輸入完後，再一次從上而下做更新(renew)。其時間複雜度雜到\\(O(klogk+n)\\)，\\(n\\) 為 x 軸的個數。 區域查詢也可以用差不多的概念完成。 class Solution { class Tree { vector\u003cint\u003e arr; int m, n; public: Tree (int sz) { n = sz; for (m=1; m \u003c n; m\u003c\u003c=1); arr.assign(2*m, 0); } // void update(int b, int e, int val) { // int i = b+m, j = e+m; // for (; i \u0026\u0026 j \u0026\u0026 i \u003c= j; i \u003e\u003e= 1, j \u003e\u003e= 1){ // for (int k = i; k \u003c= j; k++){ // arr[k] = max(arr[k], val); // } // } // } // void renew(){} void update(int b, int e, int val){ for (b+=m, e+=m; b \u003c= e; b\u003e\u003e=1, e\u003e\u003e=1) { if (b\u00261) arr[b++] = max(arr[b], val); if (!(e\u00261)) arr[e--] = max(arr[e], val); } } void renew() { for (int i = 1; i \u003c m; i++) { arr[i\u003c\u003c1] = max(arr[i\u003c\u003c1], arr[i]); arr[i\u003c\u003c1|1] = max(arr[i\u003c\u003c1|1], arr[i]); } } int query(int i) { return arr[i+m]; } }; unordered_map\u003cint,int\u003e i2x, x2i; public: int mapping(vector\u003cvector\u003cint\u003e\u003e\u0026 buildings) { set\u003cint\u003e sets; for (const auto\u0026 building : buildings) { sets.insert(building[0]); sets.insert(building[1]); } int cnt = 0; for (const auto\u0026 x : sets){ i2x[cnt] = x; x2i[x] = cnt++; } return cnt; } vector\u003cvector\u003cint\u003e\u003e getSkyline(vector\u003cvector\u003cint\u003e\u003e\u0026 buildings) { int n = mapping(buildings); Tree* root = new Tree(n); for (const auto\u0026 building : buildings) { int b = x2i[building[0]]; int e = x2i[building[1]]; root-\u003eupdate(b, e-1, building[2]); } root-\u003erenew(); vector\u003cvector\u003cint\u003e\u003e res; int prev = 0; for (int i = 0; i \u003c n; i++){ int x = i2x[i]; int y = root-\u003equery(i); if (prev != y) { res.push_back({x, y}); prev = y; } } return res; } }; ","wordCount":"755","inLanguage":"en","datePublished":"2022-10-20T22:29:15+08:00","dateModified":"2022-10-20T22:29:15+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/leetcode/versionquery/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[Problem] Version Query</h1><div class=post-meta><span title='2022-10-20 22:29:15 +0800 +0800'>October 20, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/leetcode/VersionQuery.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#priority-queue aria-label="Priority Queue">Priority Queue</a></li><li><a href=#%e8%a3%9c%e5%85%85segment-tree aria-label="補充(segment tree)">補充(segment tree)</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>Version Query</strong></p><ul><li>Hardness: \(\color{red}\textsf{Hard}\)</li><li>Ralated Topics: <code>Binary Search</code>、<code>Segment Tree</code>、<code>Heap (Priority Queue</code>、<code>Hash Table</code></li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.<br>The given apk_info structure is given as below.<br><strong>struct apk_info {</strong><br>　　<strong>int apk_version;</strong><br>　　<strong>int min_version = 1;</strong><br>　　<strong>int max_version = INT_MAX;</strong><br><strong>}</strong></p><p><strong>Example 1:</strong><br>\(\begin{array}{|l|}\hline
\text{Input: }\\
\begin{array}{|c|c|c|}\hline
\text{apk version}&\text{min OS version}&\text{max OS version}\\\hline
\text{1}&\text{14}&\text{}\\\hline
\text{2}&\text{}&\text{8}\\\hline
\text{3}&\text{12}&\text{16}\\\hline
\end{array}\\
\text{OS version query = [18,4,14,10]}\\\\
\text{Output:}\\\text{apk version = [1,2,3,0]}(0 \text{ means not found})\\\hline
\end{array}\)</p><p><strong>Constraints:</strong><br>\(\begin{array}{|l|}\hline
\text{1. 1} \le \text{Apk version &lt; } 10^{31}\\
\text{2. 1} \le \text{OS version &lt; } 10^{31}\\
\text{3. 1} \le \text{Query times &lt; } 10^{31}\\\hline
\end{array}\)</p><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>重點其實就是區間求極值，所以筆者最先開始想到的是線段樹，線段樹的介紹可參考這裡：<a href=/posts/c++/segtree>Segment Tree 線段樹</a></li><li>爾後才想到這題其實概念上很接近 <a href=https://leetcode.com/problems/the-skyline-problem/>Leetcode 218. The Skyline Problem</a></li><li>上這張題後就懂了，把 apk version 看成建築的高度， min OS version 與 max OS version 看成建築的 x 座標，就變成一樣的題目了，差別在於把 skyline 建成之後，再對其作 binary search。
<img loading=lazy src=https://assets.leetcode.com/uploads/2020/12/01/merged.jpg alt=skyline></li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=priority-queue>Priority Queue<a hidden class=anchor aria-hidden=true href=#priority-queue>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>apk_info</span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> apk_version;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> min_version <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> max_version <span style=color:#f92672>=</span> INT_MAX;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    apk_info(<span style=color:#66d9ef>int</span> ver, <span style=color:#66d9ef>int</span> mn, <span style=color:#66d9ef>int</span> mx){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>apk_version <span style=color:#f92672>=</span> ver;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>min_version <span style=color:#f92672>=</span> mn;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>max_version <span style=color:#f92672>=</span> mx;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> waitList;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove</span>(priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> pq, <span style=color:#66d9ef>int</span> item){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pq.top() <span style=color:#f92672>==</span> item) {      <span style=color:#75715e>// 若 pq 的頂是要移除的對象，則直接移除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            pq.pop();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (waitList.find(pq.top()) <span style=color:#f92672>!=</span> waitList.end()  <span style=color:#f92672>&amp;&amp;</span> waitList[pq.top()] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                waitList[pq.top()]<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                pq.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            waitList[item]<span style=color:#f92672>++</span>;       <span style=color:#75715e>// 若 pq 的頂非要移除的對象，則加入 waitList，待之後再移除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> getRangeMax(vector<span style=color:#f92672>&lt;</span>apk_info<span style=color:#f92672>*&gt;</span> infos) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> rangeMax, osVers;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> info : infos) {
</span></span><span style=display:flex><span>            osVers.push_back({info<span style=color:#f92672>-&gt;</span>min_version, <span style=color:#f92672>-</span>info<span style=color:#f92672>-&gt;</span>apk_version});   <span style=color:#75715e>// 以負值代表 skyline 的開始
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            osVers.push_back({info<span style=color:#f92672>-&gt;</span>max_version,  info<span style=color:#f92672>-&gt;</span>apk_version});   <span style=color:#75715e>// 以正值代表 skyline 的結束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        sort(osVers.begin(), osVers.end());     <span style=color:#75715e>// 以 x 值(os_version) 進行排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span>        pq.push(<span style=color:#ae81ff>0</span>);                 <span style=color:#75715e>// not found 時，預設回傳 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> prev <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;               <span style=color:#75715e>// 在還沒插入 item 前一開始的最大值就是 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> osVer : osVers) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (osVer.second <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>){      <span style=color:#75715e>// 開始
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                pq.push(<span style=color:#f92672>-</span>osVer.second);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {                    <span style=color:#75715e>// 結束，需移除該點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                remove(pq, osVer.second);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> curr <span style=color:#f92672>=</span> pq.top();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (prev <span style=color:#f92672>!=</span> curr) {         <span style=color:#75715e>// 若最大值有變，則需把 skyline 記錄下來
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (prev <span style=color:#f92672>&lt;</span> curr <span style=color:#f92672>||</span> osVer.first <span style=color:#f92672>==</span> INT_MAX)
</span></span><span style=display:flex><span>                    rangeMax.push_back({osVer.first, curr});    <span style=color:#75715e>// x 軸為 os version，y 軸為 apk version
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>else</span>                    <span style=color:#75715e>// 為做成 [a, b) 左閉右開的區間，若 skyline 往下，x 軸的點位置需加 1 (版本以大的為主)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    rangeMax.push_back({osVer.first<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, curr});
</span></span><span style=display:flex><span>                prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> rangeMax;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> findOSVersion(vector<span style=color:#f92672>&lt;</span>apk_info<span style=color:#f92672>*&gt;</span> infos, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> queries) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> rangeMax <span style=color:#f92672>=</span> getRangeMax(infos);    <span style=color:#75715e>// 以範例來說會回傳 [[1,2],[9,0],[12,3],[17,1],[INT_MAX, 0]]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> q : queries){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> upper_bound(rangeMax.begin(), rangeMax.end(), make_pair(q, INT_MAX));     <span style=color:#75715e>// 開區間找上限後，往前推一位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            it<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            res.push_back(it<span style=color:#f92672>-&gt;</span>second);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// test case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    apk_info<span style=color:#f92672>*</span> a1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> apk_info(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>14</span>, INT_MAX);
</span></span><span style=display:flex><span>    apk_info<span style=color:#f92672>*</span> a2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> apk_info(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    apk_info<span style=color:#f92672>*</span> a3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> apk_info(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>apk_info<span style=color:#f92672>*&gt;</span> infos <span style=color:#f92672>=</span> {a1, a2, a3};
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> queries <span style=color:#f92672>=</span> {<span style=color:#ae81ff>18</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>14</span>,<span style=color:#ae81ff>10</span>};    <span style=color:#75715e>// 1, 2, 3, 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Solution<span style=color:#f92672>*</span> sol <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Solution();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res <span style=color:#f92672>=</span> sol<span style=color:#f92672>-&gt;</span>findOSVersion(infos, queries);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> res.size(); i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> res[i] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=補充segment-tree>補充(segment tree)<a hidden class=anchor aria-hidden=true href=#補充segment-tree>#</a></h4><ul><li>用segment tree 來解區域更新的題目時，若把每個子葉點退化到單點的話，其空間複雜度會太高，可以用兩個 map 由左到右將 x 軸從小到大帶入，每個索引值 i 對應到一個有使用到的 x 軸座標。然後用左閉右開(\([a,b)\))的方式去維護區間的值。</li><li>在用segment tree 做區域更新時，若每次都對所有子葉做更新的話，其時間複雜度會拉高到\(O(k)\)，\(k\) 為線段長。其下 slash 掉的部分，在 the skyline problem 中會造成 TLE，所以我們每次只對其必要的點做更新，待全部資料輸入完後，再一次從上而下做更新(renew)。其時間複雜度雜到\(O(klogk+n)\)，\(n\) 為 x 軸的個數。</li><li>區域查詢也可以用差不多的概念完成。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tree</span> {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> arr;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> m, n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        Tree (<span style=color:#66d9ef>int</span> sz) {
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> sz;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (m<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>; m <span style=color:#f92672>&lt;</span> n; m<span style=color:#f92672>&lt;&lt;=</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            arr.assign(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>m, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// void update(int b, int e, int val) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     int i = b+m, j = e+m;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     for (; i &amp;&amp; j &amp;&amp; i &lt;= j; i &gt;&gt;= 1, j &gt;&gt;= 1){
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//         for (int k = i; k &lt;= j; k++){
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//             arr[k] = max(arr[k], val);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//         }    
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//     }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// void renew(){}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> e, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (b<span style=color:#f92672>+=</span>m, e<span style=color:#f92672>+=</span>m; b <span style=color:#f92672>&lt;=</span> e; b<span style=color:#f92672>&gt;&gt;=</span><span style=color:#ae81ff>1</span>, e<span style=color:#f92672>&gt;&gt;=</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (b<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>) arr[b<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> max(arr[b], val);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(e<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>)) arr[e<span style=color:#f92672>--</span>] <span style=color:#f92672>=</span> max(arr[e], val);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>renew</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> max(arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>], arr[i]);
</span></span><span style=display:flex><span>                arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> max(arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span>], arr[i]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> arr[i<span style=color:#f92672>+</span>m];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }; 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> i2x, x2i;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mapping(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> buildings) {
</span></span><span style=display:flex><span>        set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> sets;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> building : buildings) {
</span></span><span style=display:flex><span>            sets.insert(building[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>            sets.insert(building[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> x : sets){
</span></span><span style=display:flex><span>            i2x[cnt] <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>            x2i[x] <span style=color:#f92672>=</span> cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cnt;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> getSkyline(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> buildings) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> mapping(buildings);
</span></span><span style=display:flex><span>        Tree<span style=color:#f92672>*</span> root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Tree(n);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> building : buildings) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> x2i[building[<span style=color:#ae81ff>0</span>]];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> e <span style=color:#f92672>=</span> x2i[building[<span style=color:#ae81ff>1</span>]];
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            root<span style=color:#f92672>-&gt;</span>update(b, e<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, building[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        root<span style=color:#f92672>-&gt;</span>renew();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> prev <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> i2x[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> root<span style=color:#f92672>-&gt;</span>query(i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (prev <span style=color:#f92672>!=</span> y) {
</span></span><span style=display:flex><span>                res.push_back({x, y});
</span></span><span style=display:flex><span>                prev <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=http://intervalrain.github.io/posts/leetcode/><span class=title>« Prev Page</span><br><span>[LeetCode] Catalog</span></a>
<a class=next href=http://intervalrain.github.io/posts/c++/segtree/><span class=title>Next Page »</span><br><span>[C++] Segment Tree</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>