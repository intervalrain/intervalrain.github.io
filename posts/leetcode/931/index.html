<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 931. Minimum Falling Path Sum | Rain's Blog</title><meta name=keywords content="Leetcode"><meta name=description content="931. Minimum Falling Path Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.
A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1)."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="[LeetCode] 931. Minimum Falling Path Sum"><meta property="og:description" content="931. Minimum Falling Path Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.
A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1)."><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/leetcode/931/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-13T21:53:27+08:00"><meta property="article:modified_time" content="2022-12-13T21:53:27+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 931. Minimum Falling Path Sum"><meta name=twitter:description content="931. Minimum Falling Path Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.
A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[LeetCode] 931. Minimum Falling Path Sum","item":"http://intervalrain.github.io/posts/leetcode/931/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 931. Minimum Falling Path Sum","name":"[LeetCode] 931. Minimum Falling Path Sum","description":"931. Minimum Falling Path Sum\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).","keywords":["Leetcode"],"articleBody":"931. Minimum Falling Path Sum\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\nExample 1:\nInput: matrix = [[2,1,3],[6,5,4],[7,8,9]] Output: 13 Explanation: There are two falling paths with a minimum sum as shown. Example 2:\nInput: matrix = [[-19,57],[-40,-5]] Output: -59 Explanation: The falling path with a minimum sum is shown. Constraints:\nn == matrix.length == matrix[i].length 1 \u003c= n \u003c= 100 -100 \u003c= matrix[i][j] \u003c= 100 二、分析 這題也是典型的動態規劃問題，每一層可能的最小值，會影響到下一層的最小值，所以我們只需記錄每一層的狀態再將狀態往下一層推移即可。 定義 dp[m][n] 為第 m 層，第 n 欄的累計最小值。 轉移方程式為 dp[m][n] = min({dp[m-1][n-1], dp[m-1][n], dp[m-1][n+1]}) + row[m][n]。 但要注意最左邊跟最右邊要另外處理以避免出界。 從轉移方程式可以注意到，狀態的轉移只跟上一層有關係，故可以做空間壓縮，就空間複雜度壓到 \\(O(n)\\) 三、解題 1. DP Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(m\\times n)\\) int minFallingPathSum(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { int m = matrix.size(), n = matrix[0].size(); if (m == 1) return matrix[0][0]; vector\u003cvector\u003cint\u003e\u003e dp(m+1, vector\u003cint\u003e(n)); for (int i = 0; i \u003c m; i++) { vector\u003cint\u003e\u0026 row = matrix[i]; dp[i+1][0] = min(dp[i][0], dp[i][1]) + row[0]; dp[i+1][n-1] = min(dp[i][n-1], dp[i][n-2]) + row[n-1]; for (int j = 1; j \u003c n-1; j++) { dp[i+1][j] = min({dp[i][j-1], dp[i][j], dp[i][j+1]}) + row[j]; } } int res = INT_MAX; for (int j = 0; j \u003c n; j++) { res = min(res, dp[m][j]); } return res; } 2. DP space-optimized Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(n)\\) int minFallingPathSum(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { int m = matrix.size(), n = matrix[0].size(); if (m == 1) return matrix[0][0]; // 利用奇數層跟偶數層做切換 vector\u003cvector\u003cint\u003e\u003e dp(2, vector\u003cint\u003e(n)); for (int i = 0; i \u003c m-1; i++) { vector\u003cint\u003e\u0026 row = matrix[i]; dp[i%2][0] = min(dp[(i+1)%2][0], dp[(i+1)%2][1]) + row[0]; dp[i%2][n-1] = min(dp[(i+1)%2][n-1], dp[(i+1)%2][n-2]) + row[n-1]; for (int j = 1; j \u003c matrix[0].size()-1; j++) { dp[i%2][j] = min({dp[(i+1)%2][j-1], dp[(i+1)%2][j], dp[(i+1)%2][j+1]}) + row[j]; } } int res = INT_MAX; dp[(m-1)%2][0] = min(dp[m%2][0], dp[m%2][1]) + matrix[m-1][0]; dp[(m-1)%2][n-1] = min(dp[m%2][n-1], dp[m%2][n-2]) + matrix[m-1][n-1]; res = min({res, dp[(m-1)%2][0], dp[(m-1)%2][n-1]}); for (int j = 1; j \u003c matrix[0].size()-1; j++) { dp[(m-1)%2][j] = min({dp[m%2][j-1], dp[m%2][j], dp[m%2][j+1]}) + matrix[m-1][j]; res = min(res, dp[(m-1)%2][j]); } return res; } 回目錄 Catalog\n","wordCount":"382","inLanguage":"en","datePublished":"2022-12-13T21:53:27+08:00","dateModified":"2022-12-13T21:53:27+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/leetcode/931/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=http://intervalrain.github.io/posts/csharp/csharp title=Csharp><span>Csharp</span></a></li><li><a href=http://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[LeetCode] 931. Minimum Falling Path Sum</h1><div class=post-meta><span title='2022-12-13 21:53:27 +0800 +0800'>December 13, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/leetcode/931.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-dp aria-label="1. DP">1. DP</a></li><li><a href=#2-dp-space-optimized aria-label="2. DP space-optimized">2. DP space-optimized</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>931. Minimum Falling Path Sum</strong></p><ul><li>Hardness: \(\color{orange}\textsf{Medium}\)</li><li>Ralated Topics: <code>Array</code>、<code>Dynamic Programming</code>、<code>Matrix</code></li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>Given an <code>n x n</code> array of integers <code>matrix</code>, return <em>the <strong>minimum sum</strong> of any <strong>falling path</strong> through</em> <code>matrix</code>.<br>A <strong>falling path</strong> starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position <code>(row, col)</code> will be <code>(row + 1, col - 1)</code>, <code>(row + 1, col)</code>, or <code>(row + 1, col + 1)</code>.</p><p><strong>Example 1:</strong><br><img loading=lazy src=https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg alt=falling1-grid></p><ul><li><strong>Input:</strong> matrix = [[2,1,3],[6,5,4],[7,8,9]]</li><li><strong>Output:</strong> 13</li><li><strong>Explanation:</strong> There are two falling paths with a minimum sum as shown.</li></ul><p><img loading=lazy src=https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg alt=falling2-grid>
<strong>Example 2:</strong></p><ul><li><strong>Input:</strong> matrix = [[-19,57],[-40,-5]]</li><li><strong>Output:</strong> -59</li><li><strong>Explanation:</strong> The falling path with a minimum sum is shown.</li></ul><p><strong>Constraints:</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>這題也是典型的動態規劃問題，每一層可能的最小值，會影響到下一層的最小值，所以我們只需記錄每一層的狀態再將狀態往下一層推移即可。</li><li>定義 <code>dp[m][n]</code> 為第 <code>m</code> 層，第 <code>n</code> 欄的累計最小值。</li><li>轉移方程式為 <code>dp[m][n] = min({dp[m-1][n-1], dp[m-1][n], dp[m-1][n+1]}) + row[m][n]</code>。<ul><li>但要注意最左邊跟最右邊要另外處理以避免出界。</li></ul></li><li>從轉移方程式可以注意到，狀態的轉移只跟上一層有關係，故可以做空間壓縮，就空間複雜度壓到 \(O(n)\)</li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-dp>1. DP<a hidden class=anchor aria-hidden=true href=#1-dp>#</a></h4><ul><li>Time complexity: \(O(m\times n)\)</li><li>Space complexity: \(O(m\times n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>minFallingPathSum</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> matrix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> matrix.size(), n <span style=color:#f92672>=</span> matrix[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> matrix[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> row <span style=color:#f92672>=</span> matrix[i];
</span></span><span style=display:flex><span>        dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> min(dp[i][<span style=color:#ae81ff>0</span>], dp[i][<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>+</span> row[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> min(dp[i][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], dp[i][n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]) <span style=color:#f92672>+</span> row[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            dp[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>=</span> min({dp[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], dp[i][j], dp[i][j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]}) <span style=color:#f92672>+</span> row[j];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> INT_MAX;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> min(res, dp[m][j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=2-dp-space-optimized>2. DP space-optimized<a hidden class=anchor aria-hidden=true href=#2-dp-space-optimized>#</a></h4><ul><li>Time complexity: \(O(m\times n)\)</li><li>Space complexity: \(O(n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>minFallingPathSum</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> matrix) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> matrix.size(), n <span style=color:#f92672>=</span> matrix[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> matrix[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 利用奇數層跟偶數層做切換
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> dp(<span style=color:#ae81ff>2</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> row <span style=color:#f92672>=</span> matrix[i];
</span></span><span style=display:flex><span>        dp[i<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> min(dp[(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], dp[(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>+</span> row[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        dp[i<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> min(dp[(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], dp[(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]) <span style=color:#f92672>+</span> row[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> matrix[<span style=color:#ae81ff>0</span>].size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            dp[i<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j] <span style=color:#f92672>=</span> min({dp[(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], dp[(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j], dp[(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]}) <span style=color:#f92672>+</span> row[j];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> INT_MAX;
</span></span><span style=display:flex><span>    dp[(m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> min(dp[m<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], dp[m<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>+</span> matrix[m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    dp[(m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> min(dp[m<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], dp[m<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]) <span style=color:#f92672>+</span> matrix[m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> min({res, dp[(m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>], dp[(m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]});
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> matrix[<span style=color:#ae81ff>0</span>].size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        dp[(m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j] <span style=color:#f92672>=</span> min({dp[m<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], dp[m<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j], dp[m<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]}) <span style=color:#f92672>+</span> matrix[m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j];
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> min(res, dp[(m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span>][j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=/posts/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=http://intervalrain.github.io/posts/leetcode/24/><span class=title>« Prev Page</span><br><span>[LeetCode] 24. Swap Nodes in Pairs</span></a>
<a class=next href=http://intervalrain.github.io/posts/leetcode/70/><span class=title>Next Page »</span><br><span>[LeetCode] 70. Climbing Stairs</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>