<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 1235. Maximum Profit in Job Scheduling | Rain's Blog</title><meta name=keywords content="Leetcode"><meta name=description content="1235. Maximum Profit in Job Scheduling
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="[LeetCode] 1235. Maximum Profit in Job Scheduling"><meta property="og:description" content="1235. Maximum Profit in Job Scheduling
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X."><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/leetcode/1235/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-26T14:09:56+08:00"><meta property="article:modified_time" content="2022-11-26T14:09:56+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 1235. Maximum Profit in Job Scheduling"><meta name=twitter:description content="1235. Maximum Profit in Job Scheduling
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[LeetCode] 1235. Maximum Profit in Job Scheduling","item":"http://intervalrain.github.io/posts/leetcode/1235/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 1235. Maximum Profit in Job Scheduling","name":"[LeetCode] 1235. Maximum Profit in Job Scheduling","description":"1235. Maximum Profit in Job Scheduling\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou\u0026rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.","keywords":["Leetcode"],"articleBody":"1235. Maximum Profit in Job Scheduling\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou’re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\nExample 1:\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] Output: 120 Explanation: The subset chosen is the first and fourth job.\nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70. Example 2: Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] Output: 150 Explanation: The subset chosen is the first, fourth and fifth job.\nProfit obtained 150 = 20 + 70 + 60. Example 3: Input: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60. Output: 6 Constraints:\n1 \u003c= startTime.length == endTime.length == profit.length \u003c= 5 * 10^4 1 \u003c= startTime[i] \u003c endTime[i] \u003c= 10^9 1 \u003c= profit[i] \u003c= 10^4 二、分析 在思考這一題，首先要先有 coin change 的思維，也就是動態規劃： 我們將 dp[n] 定義為在時間 n 時的最大利益。 所以當時間點 i 的最大利益會等於 max(dp[i-1], dp[i - time_cost] + profit 以範例 1 為例即： dp[0] = 0 dp[1] = 0 dp[2] = 0 dp[3] = 50 = max(dp[1]+50, dp[2]) dp[4] = 50 = dp[3] dp[5] = 90 = max(dp[3]+40, dp[4]) … 其中我們可以發現，有可能發生改變的時間點都是在每一個工作的 endTime，也就是說我們只要針對每個 endTime 去記錄即可，其中我們可將 dp[i - time_cost] 改為搜尋小於 startTime 的最大值，即： dp[0] = 0 dp[3] = 50 = max(dp[0], dp[3]) dp[4] = 10 = max(dp[0]+10, dp[4]) 我們只記錄當下最大利益，故不記錄 dp[5] = 90 = max(dp[3]+40, dp[5]) dp[6] = 120 = max(dp[3]+70, dp[6] 我們可以使用 map 這個資料結構，將所有 trigger point 依 endTime 排序後，逐步更新。 其中注意 upper_bound(x) 這個函式，會找大於 x 的位子，而且我們要找的是比小於等於當前 startTime 的資料，故我們找的是 upper_bound(x)-1。 由於時間 t = 0 時不會有收益，我們可以加入 {0,0}，這樣可以省去解決 iterator out of range(it 指向 -1) 的情形。 三、解題 1. DP + Binary Search Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) int jobScheduling(vector\u003cint\u003e\u0026 startTime, vector\u003cint\u003e\u0026 endTime, vector\u003cint\u003e\u0026 profit) { map\u003cint,int\u003e dp; vector\u003cvector\u003cint\u003e\u003e job; int n = startTime.size(); for (int i = 0; i \u003c n; i++) { job.push_back({endTime[i], startTime[i], profit[i]}); } sort(job.begin(), job.end()); // sort by endTime dp.insert({0,0}); // 省去處理 out of range int res = 0; for (int i = 0; i \u003c n; i++) { auto it = dp.upper_bound(job[i][1]); // \u003e startTime it--; // \u003c= startTime int last = it-\u003esecond; int val = last + job[i][2]; // 由當前最大收益往上累積 int pos = job[i][0]; if (val \u003c res) continue; // 若當前最大收益比歷史最大收益還小，則跳過不記錄 dp[pos] = max(dp[pos], val); // 更新當前最大收益 res = max(dp[pos], res); // 更新歷史最大收益 } return res; } 回目錄 Catalog\n","wordCount":"443","inLanguage":"en","datePublished":"2022-11-26T14:09:56+08:00","dateModified":"2022-11-26T14:09:56+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/leetcode/1235/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=http://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[LeetCode] 1235. Maximum Profit in Job Scheduling</h1><div class=post-meta><span title='2022-11-26 14:09:56 +0800 +0800'>November 26, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/leetcode/1235.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-dp--binary-search aria-label="1. DP + Binary Search">1. DP + Binary Search</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>1235. Maximum Profit in Job Scheduling</strong></p><ul><li>Hardness: \(\color{red}\textsf{Hard}\)</li><li>Ralated Topics: <code>Array</code>、<code>Binary Search</code>、<code>Dynamic Programming</code>、<code>Sorting</code></li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>We have <code>n</code> jobs, where every job is scheduled to be done from <code>startTime[i]</code> to <code>endTime[i]</code>, obtaining a profit of <code>profit[i]</code>.<br>You&rsquo;re given the <code>startTime</code>, <code>endTime</code> and <code>profit</code> arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.<br>If you choose a job that ends at time <code>X</code> you will be able to start another job that starts at time <code>X</code>.</p><p><strong>Example 1:</strong><br><img loading=lazy src=https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png alt=smaple1></p><ul><li><strong>Input:</strong> startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]</li><li><strong>Output:</strong> 120</li><li><strong>Explanation:</strong> The subset chosen is the first and fourth job.<br>Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.</li></ul><p><strong>Example 2:</strong>
<img loading=lazy src=https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png alt=sample2></p><ul><li><strong>Input:</strong> startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]</li><li><strong>Output:</strong> 150</li><li><strong>Explanation:</strong> The subset chosen is the first, fourth and fifth job.<br>Profit obtained 150 = 20 + 70 + 60.</li></ul><p><strong>Example 3:</strong>
<img loading=lazy src=https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png alt=sample3></p><ul><li><strong>Input:</strong> The subset chosen is the first, fourth and fifth job.
Profit obtained 150 = 20 + 70 + 60.</li><li><strong>Output:</strong> 6</li></ul><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10^4</code></li><li><code>1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10^9</code></li><li><code>1 &lt;= profit[i] &lt;= 10^4</code></li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>在思考這一題，首先要先有 <code>coin change</code> 的思維，也就是動態規劃：<ul><li>我們將 <code>dp[n]</code> 定義為在時間 <code>n</code> 時的最大利益。</li><li>所以當時間點 <code>i</code> 的最大利益會等於 <code>max(dp[i-1], dp[i - time_cost] + profit</code></li><li>以範例 1 為例即：<ul><li><code>dp[0] = 0</code></li><li><code>dp[1] = 0</code></li><li><code>dp[2] = 0</code></li><li><code>dp[3] = 50 = max(dp[1]+50, dp[2])</code></li><li><code>dp[4] = 50 = dp[3]</code></li><li><code>dp[5] = 90 = max(dp[3]+40, dp[4])</code></li><li>&mldr;</li></ul></li><li>其中我們可以發現，有可能發生改變的時間點都是在每一個工作的 <code>endTime</code>，也就是說我們只要針對每個 <code>endTime</code> 去記錄即可，其中我們可將 <code>dp[i - time_cost]</code> 改為搜尋小於 <code>startTime</code> 的最大值，即：<ul><li><code>dp[0] = 0</code></li><li><code>dp[3] = 50 = max(dp[0], dp[3])</code></li><li><code>dp[4] = 10 = max(dp[0]+10, dp[4])</code> 我們只記錄當下最大利益，故不記錄</li><li><code>dp[5] = 90 = max(dp[3]+40, dp[5])</code></li><li><code>dp[6] = 120 = max(dp[3]+70, dp[6]</code></li></ul></li></ul></li><li>我們可以使用 <code>map</code> 這個資料結構，將所有 <code>trigger point</code> 依 <code>endTime</code> 排序後，逐步更新。<ul><li>其中注意 <code>upper_bound(x)</code> 這個函式，會找大於 <code>x</code> 的位子，而且我們要找的是比小於等於當前 <code>startTime</code> 的資料，故我們找的是 <code>upper_bound(x)-1</code>。</li><li>由於時間 <code>t = 0</code> 時不會有收益，我們可以加入 <code>{0,0}</code>，這樣可以省去解決 <strong>iterator out of range</strong>(it 指向 -1) 的情形。</li></ul></li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-dp--binary-search>1. DP + Binary Search<a hidden class=anchor aria-hidden=true href=#1-dp--binary-search>#</a></h4><ul><li>Time complexity: \(O(n\log n)\)</li><li>Space complexity: \(O(n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>jobScheduling</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> startTime, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> endTime, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> profit) {
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> job;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> startTime.size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        job.push_back({endTime[i], startTime[i], profit[i]});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    sort(job.begin(), job.end());   <span style=color:#75715e>// sort by endTime
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    dp.insert({<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>});               <span style=color:#75715e>// 省去處理 out of range
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> dp.upper_bound(job[i][<span style=color:#ae81ff>1</span>]);    <span style=color:#75715e>// &gt; startTime
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        it<span style=color:#f92672>--</span>;                                   <span style=color:#75715e>// &lt;= startTime
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> last <span style=color:#f92672>=</span> it<span style=color:#f92672>-&gt;</span>second;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> val <span style=color:#f92672>=</span> last <span style=color:#f92672>+</span> job[i][<span style=color:#ae81ff>2</span>];             <span style=color:#75715e>// 由當前最大收益往上累積
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> pos <span style=color:#f92672>=</span> job[i][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (val <span style=color:#f92672>&lt;</span> res) <span style=color:#66d9ef>continue</span>;  <span style=color:#75715e>// 若當前最大收益比歷史最大收益還小，則跳過不記錄
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        dp[pos] <span style=color:#f92672>=</span> max(dp[pos], val);            <span style=color:#75715e>// 更新當前最大收益
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        res <span style=color:#f92672>=</span> max(dp[pos], res);                <span style=color:#75715e>// 更新歷史最大收益
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=/posts/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=next href=http://intervalrain.github.io/posts/leetcode/1143/><span class=title>Next Page »</span><br><span>[LeetCode] 1143. Longest Common Subsequence</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>