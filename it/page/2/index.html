<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ITs | Rain Hu's Workspace</title><meta name=keywords content><meta name=description content="ITs - Rain Hu's Workspace"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/it/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/it/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/it/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/it/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="ITs"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="ITs"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ITs","item":"https://intervalrain.github.io/it/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a></div><h1>ITs</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[IT] CORS 跨原始來源要求</h2></header><div class=entry-content><p>TL;DR CORS (Cross-Origin Resource Sharing)
是一個支援安全跨源請求和資料傳輸的機制，用於在瀏覽器和伺服器之間進行跨源請求。
這是一個 W3C 標準，可讓伺服器放寬相同原始來源原則。 不是安全性功能，CORS 會放寬安全性。 允許 CORS 並不會增強 API 的安全性。CORS 的運作方式 允許伺服器明確允許某些跨原始來源要求，同時拒絕其他要求。 比舊版技術 (例如：JSONP) 更安全且更有彈性。 何謂相同原始來源 如果兩個 URL 具有相同的配置、主機和連接埠，則其原始來源相同 (RFC 6454)。 這兩個 URL 具有相同的原始來源： https://example.com/foo.html https://example.com/bar.html 這些 URL 的原始來源與前兩個 URL 不同： https://example.net：不同的網域 https://www.example.com/foo.html：不同的子網域 http://example.com/foo.html：不同的配置 https://example.com:9000/foo.html：不同的連接埠 如何啟動 CORS 有三種方式可以啟用 CORS：
在中介軟體中，使用具名原則或預設原則。 使用端點路由。 使用 [EnableCors] 屬性。 搭配具名原則使用 [EnableCors] 屬性能夠以最精細的程度來控制對於支援 CORS 之端點的限制。 ...</p></div><footer class=entry-footer><span title='2024-01-19 00:41:51 +0800 +0800'>January 19, 2024</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] CORS 跨原始來源要求" href=https://intervalrain.github.io/it/cors/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[IT] 事件總線 EventBus</h2></header><div class=entry-content><p>EventBus EventBus 用於維護一個事件源與事件處理的映射字典 通過 Singleton，確保 EventBus 的唯一入口 利用反射完成事件源與件事處理的初始化綁定 提供統一的事件注冊(register)、取消注冊(unsubscribe)和觸發(trigger)。 Interfaces IEventData public interface IEventData { DateTime EventTime { get; set; } object EventSource {get; set; } } IEventHandler public interface IEventHandler { } IEventHandler`1 public interface IEventHandler&lt;TEventData> : IEventHandler where TEventData : IEventData { void HandlerEvent(TEventData eventData); } base class EventData public class EventData : IEventData { public DateTime EventTIme { get; set; } object EventSource { get; set; } public EventData() { EventTime = DateTime.Now; } } Domain FishType public enum FishType { None, 鯽魚, 鯉魚, 黑魚, 青魚, 草魚, 鱸魚 } FishingEventData : EventData public class FishingEventData : EventData { public FishType FishType { get; set; } public FishingMan FishingMan { get; set; } } FishingEventHandler : IEventHandler public class FishingEventHandler : IEventHandler&lt;FishingEventData> { public void HandleEvent(FishingEventData eventData) { var type = eventData.FishType; var fishMan = eventData.FishingMan; var Name = fishMan.Name; if (type == FishType.None) { fishMan.Message = string.Format("{0}: 沒有釣到魚, 累計釣了{1}條魚", Name, fishMan.FishCount); } else { fishMan.FishCount++; fishMan.Message = string.Format("{0}: 釣到一條[{2}], 累計釣了{1}條魚", Name, fishMan.FishCount, type); } } } FishingMan public class FishingMan { public string Name { get; set; } public int FishCount { get; set; } public FishingRod FishingRod { get; set; } public string Message { get; set; } public FishingMan(string name) { Name = name; FishCount = 0; } public void Fishing() { FishingRod.ThrowHook(this); } } FishingRod 用反射註冊事件 public class FishingRod { public string Message { get; private set; } public FishingRod() { } public void ThrowHook(FishingMan man) { if (new Random().Next() % 2 == 0) { var type = (FishType)(new Random().Next(0, 5) + 1); Message = ("魚兒上鉤了!"); if (FishingEvent != null) { var eventData = new FishingEventData { FishingMan = man, FishType = type }; EventBus.Default.Trigger&lt;FishingEventData>(eventData); } } else { var type = FishType.None; Message = ("可惜了!"); if (FishingEvent != null) { var eventData = new FishingEventData { FishingMan = man, FishType = type }; EventBus.Default.Trigger&lt;FishingEventData>(eventData); } } } } EventBus 實作 用一個靜態單例來統一管理事件 public class EventBus { public static EventBus Default => new EventBus(); private readonly ConcurrentDictionary&lt;Type, List&lt;Type>> _eventAndHandlerMapping; private EventBus() { _eventAndHandlerMapping = new ConcurrentDictionary&lt;Type, List&lt;Type>>(); MapEventToHandler(); } private void MapEventToHandler() { Assembly assembly = Assembly.GetEntryAssembly(); foreach (var type in assembly.GetTypes()) { if (typeof(IEventHandler).IsAssignableFrom(type)) { Type handlerInterface = type.GetInterface("IEventHandler`1"); if (handlerInterface == null) continue; Type eventDataType = handlerInterface.GetGenericArguments()[0]; if (_eventAndHandlerMapping.ContainsKey(eventDataType)) { List&lt;Type> handlerTypes = _eventAndHandlerMapping[eventDataType]; handlerTypes.Add(type); _eventAndHandlerMapping[eventDataType] = handlerTypes; } else { var handlerTypes = new List&lt;Type> { type }; _eventAndHandlerMapping[eventDataType] = handlerTypes; } } } } public void Register&lt;TEventData>(Type eventHandler) { List&lt;Type> handlerTypes = _eventAndHandlerMapping[typeof(TEventData)]; if (!handlerTypes.Contains(eventHandler)) { handlerTypes.Add(eventHandler); _eventAndHandlerMapping[typeof(TEventData)] = handlerTypes; } } public void Unsubscribe&lt;TEventData>(Type eventHandler) { List&lt;Type> handlerTypes = _eventAndHandlerMapping[typeof(TEventData)]; if (!handlerTypes.Contains(eventHandler)) { handlerTypes.Remove(eventHandler); _eventAndHandlerMapping[typeof(TEventData)] = handlerTypes; } } public void Trigger&lt;TEventData>(TEventData eventData) where TEventData : IEventData { List&lt;Type> handlers = _eventAndHandlerMapping[eventData.GetType()]; if (handlers != null && handlers.Count > 0) { foreach (var handler in handlers) { MethodInfo methodInfo = handler.GetMethod("HandleEvent"); if (methodInfo != null) { object obj = Activator.CreateInstance(handler); methodInfo.Invoke(obj, new object[] { eventData }); } } } } } demo MacOs Cocoa Project public partial class ViewController : NSViewController { public ViewController (IntPtr handle) : base (handle) { } public override void ViewDidLoad () { base.ViewDidLoad (); jeff = new FishingMan("Jeff"); rod = new FishingRod(); jeff.FishingRod = rod; EventBus eventBus = EventBus.Default; eventBus.Register&lt;FishingEventData>(typeof(FishingEventHandler)); } FishingMan jeff; FishingRod rod; public override NSObject RepresentedObject { get { return base.RepresentedObject; } set { base.RepresentedObject = value; } } partial void Button_Click(NSButton sender) { jeff.Fishing(); TextLabel.StringValue = rod.Message; TextLabel2.StringValue = jeff.Message ?? ""; } }</p></div><footer class=entry-footer><span title='2023-09-25 23:50:02 +0800 +0800'>September 25, 2023</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] 事件總線 EventBus" href=https://intervalrain.github.io/it/eventbus/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[IT] Clean Architecture - 重點整理</h2></header><div class=entry-content><p>乾淨架構(Clean Architecture) 筆記 分層 乾淨架構中從外而內依序為 Framework Layer Interface Adapter Layer Application Layer Domain Layer Models 一般來說會有四個 Models View Model(給前端) App Model(App Layer 隔離 Domain Layer 所用，aka DTO) Domain Model Data Model(for DBMS) Usecase App Layer 中的 Usecase 做四件事： 查 改 存 推 單向依賴原則 依賴的方向必為單向且為
\(\boxed{\text{Interface Adapter}} \rightarrow \boxed{\text{Application Layer}} \rightarrow \boxed{\text{Domain Layer}}\) Repository Application Layer 為了遵守單向依賴，與 ORM 解耦會做一次依賴反轉，翠取 Repository 介面。 套用乾淨架構的效益衡量 Model Mapping 的成本 vs. 獨立出「領域模型」的價值 省下更換技術的成本(migration cost) 「領域層」的部分通常會結合 DDD</p></div><footer class=entry-footer><span title='2023-09-23 20:03:55 +0800 +0800'>September 23, 2023</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] Clean Architecture - 重點整理" href=https://intervalrain.github.io/it/ca/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[IT] LINQ: IQueryable Provider</h2></header><div class=entry-content><p>可重複使用的 IQueryable 基類 IQueryable 簡介 在 C# 最新版本中的 IQueryable 已經不再是一個介面，而是分為兩個部分： IQueryable 與 IQueryProvider。在開始實作之前，我們必須先了解一下這兩個介面。
public interface IQuerable : IEnumerable { Type ElementType { get; } Expression Expression { get; } IQueryProvider Provider { get; } } public interface IQueryable&lt;T> : IEnumerable&lt;T>, IQueryable, IEnumerable { } IQueryable 有三個唯讀屬性：
ElementType 代表了元素的類型 (或等於 IQueryable&lt;T> 中的 T) Expression 代表了查詢對應的表達式。這是 IQueryable 存在的核心要素。在 IQueryable 的內部，實際上是一個表示查詢的表達式，它將查詢表示為 LINQ 查詢運算子/方法調用的樹狀結構。如果進一步看，你會發現，IQueryable 或是 Queryable 都只是在提供一個自動構建表達式樹節點 (expression tree nodes) 的機制。當我們對 IQeuryable 使用 Where 方法時，它只是回傳一個新的 IQueryable，並且在進行調用的樹頂添加一個方法表達式樹節點。 Provider 作為真正的「提供者」，它負責原先所有 IQueryable 的執行方法。 IQueryProvider 簡介 public interface IQueryProvider { IQueryable CreateQuery(Expression expression); IQueryable&lt;TElement> CreateQuery&lt;TElement>(Expression expression); object Execute(Expression expression); TResult Execute&lt;TResult>(Expression expression); } 當我們進一步觀察 IQueryProvider，會發現它事實上只有兩個操作：CreateQuery、Execute，只是各有一個泛型與非泛型的方法。一般我們會使用泛型的方法，因為它可以避免使用反射來建構實例，從而提高性能。
...</p></div><footer class=entry-footer><span title='2023-09-21 11:34:15 +0800 +0800'>September 21, 2023</span>&nbsp;·&nbsp;19 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] LINQ: IQueryable Provider" href=https://intervalrain.github.io/it/iq1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[IT] 關聯模式的五大鍵 Super key、Candidate Key、Primary Key、Alternate Key、Foreign Key</h2></header><div class=entry-content><p>關聯模式的條件 關聯模式可以比實體關係模式(ERM)更精準的描述資料，他有幾個條件必須滿足： 定義域限制: 指資料庫的關聯中的每個屬性質，必須符合該屬性的定義，例如產品名稱必須是字串，薪水必須是整數數字等。 關聯鍵限制: 指資料庫的關聯中必須有關聯鍵的定義，也就是Super key、Candidate Key、Primary Key、Alternate Key、Foreign Key。這些定義我們稍後再來解釋。 實體完整限制: 如果關聯存在主鍵(Primary Key)，則不能為空。因為如果為空值，無法得知其相關的屬性值到底是描述哪一個實體。 參考完整限制: 如果關聯存在外鍵(Foreign Key)為非空值，必須有可以參考的主鍵(Primary Key)。因為如果外鍵存在，而無法關連到其他表格的主鍵，這個關聯存在就沒有意義。 語意完整限制: 這個限制不是必須的，但是可以更完備的描述實體世界的資料。例如交易金額高於100元才可以使用信用卡付款等。 關聯模式的五大鍵 Super key 超鍵: 符合唯一性的關聯鍵。 Candidate Key 候選鍵: 符合唯一性以及最小性的關聯鍵。 Primary Key 主鍵: 從候選鍵中，挑選出其中一個關聯鍵，也就是最具識別意義的關聯鍵。 Alternate Key 次要鍵: 沒有被選為主鍵的其他候選鍵。 Foreign Key 外鍵/外部鍵: 關聯中被用來參考到其他表格主鍵的關聯鍵，就是外鍵。 例如學生資料表(student_id, student_no, student_name, student_depid)
student_id student_no student_name student_depid A123454321 00001 Rain Hu MSE A123123123 00002 Mike Hu IM A221232134 00003 Eva Hsu ECE A223124125 00004 Dudu Liu ECE A124124512 00005 Gober Wei IT student_id表示學生身分證字號 student_no表示學生學號 student_name表示學生姓名 student_depid表示學生的科系代號 Super key 就可以是 {student_id}、{student_no}、 {student_id, student_no}、{student_id, student_name}、{student_id, student_depid} … 等等，都符合唯一性的條件。 Candidate Key 就可以是 {student_id}、{student_no}，都符合唯一性及最小性的條件。 Primary Key 就可以從Candidate Key挑選一個，至於挑選哪一個，就看你的系統特性。如果你的學校是多學制的話，就可能不適合挑選學生身分證字號當主鍵，因為可能某個學生原本是國中部，畢業後再進入高中部，如果系統沒有考慮清楚，這個畢業後再變新生的個體，就可能出錯。 Alternate Key 就是沒被挑中當成Primary Key的其他Candidate Key，例如，如果挑選 {student_id}當成主鍵，Alternate Key 就是{student_no}。 如果存在科系資料表 (depid, dep_name)，而且depid當成科系資料表的主鍵，學生資料表的 student_depid就是Foreign Key。 資料來源：https://www.mysql.tw/2015/04/super-keycandidate-keyprimary.html
...</p></div><footer class=entry-footer><span title='2023-05-11 21:50:43 +0800 +0800'>May 11, 2023</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] 關聯模式的五大鍵 Super key、Candidate Key、Primary Key、Alternate Key、Foreign Key" href=https://intervalrain.github.io/it/keysinrelation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[IT] Design Patterns</h2></header><div class=entry-content><p>設計模式 Design Pattern 什麼是設計模式? 設計模式是指在軟體設計中通常出現的問題的典型解決方案。它們就像是預先製作好的藍圖，您可以根據自己程式碼中出現的重複設計問題來進行自定義。 設計模式不是一個特定的程式碼，而是一個解決特定問題的一般概念。您可以按照模式的細節來實現適合自己程式的解決方案。值得注意的是，設計模式常與演算法混淆，因為這兩個概念都描述了解決某些已知問題的典型解決方案。模式是一個更高層次的解決方案描述。 模式通常包括模式意圖、動機、結構、程式碼示例等幾個方面，以便人們在多種情況下可以複製它們。模式目錄還列出了其他有用的細節，例如模式的適用性、實施步驟和與其他模式的關係。 誰發明了設計模式? 設計模式不是晦澀難懂、高深複雜的概念，相反地，它們是物件導向設計中解決常見問題的典型解決方案。當一個解決方案在不同的項目中反復出現，某人最終會給它命名並詳細描述解決方案。這基本上是模式的發現方式。 模式的概念最初是由Christopher Alexander在《模式語言：城鎮、建築、建設》中描述的。這本書描述了一種用於設計城市環境的“語言”。這種語言的單位是模式。它們可以描述窗戶應該有多高，建築物應該有多少層，社區中綠地的大小應該是多少等等。+ 這個想法被四位作者Erch Gamma、John Vlissides、Ralph Johnson和Richard Helm接受。在1994年，他們出版了《Design Patterns: Elements of + Reusable Object-Oriented Software》一書，將設計模式的概念應用於編程中。該書介紹了23個解決物件導向設計中各種問題的模式，並迅速成為暢銷書。由於書名過長，人們開始稱之為“四人幫的書(Gang of Four, GoF)”。 此後，發現了許多其他物件導向模式。模式方法在其他編程領域也變得非常流行，因此現在還存在許多與物件導向設計無關的模式。 為什麼要學習設計模式? 設計模式是解決軟體設計中常見問題的一套經過驗證的解決方案工具包。即使從未遇到這些問題，了解模式仍然有用，因為它可以使用物件導向設計原則解決各種問題。 設計模式定義了一個共通的語言，使團隊之間可以使用它更有效地進行溝通。 設計模式的分類 設計模式可以根據其複雜性、細節程度和應用於整個系統的規模進行分類。它們有點像道路建設的類比：通過安裝交通信號燈或建造整個多層立交橋和地下通道來使十字路口更安全。 最基本和低層次的模式通常被稱為 “idioms”。它們通常僅適用於單一程式語言。 最通用和高層次的模式是架構模式(architectural patterns)。開發人員可以在幾乎任何語言中實現這些模式。與其他模式不同，它們可用於設計整個應用程序的架構。 此外，所有模式都可以通過其意圖或目的進行分類。本文將涵蓋三個主要模式： 創建型模式(creational)：提供了增加彈性和重複使用現有代碼的物件創建機制。 結構型模式(structural)：解釋如何將物件和類組合成更大的結構，同時保持這些結構的靈活性和效率。 行為型模式(behavioral)：負責處理物件之間的有效溝通和職責分配。 SOLID 原則 在進入本文之前，來認識一下 SOLID 原則：(詳細的內容可以參考YC的部落格) S = Single-responsibility principle (SRP) = 單一職責原則 O = Open–closed principle (OCP) = 開放封閉原則 L = Liskov substitution principle (LSP) = 里氏替換原則 補充：jyt0532 I = Interface segregation principle (ISP) = 介面隔離原則 D = Dependency inversion principle (DIP) = 依賴反向原則 正文 Factory 簡介
...</p></div><footer class=entry-footer><span title='2023-05-01 00:22:49 +0800 +0800'>May 1, 2023</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] Design Patterns" href=https://intervalrain.github.io/it/design_pattern/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[IT] C# Depth Ch.2 C# 2</h2></header><div class=entry-content><p>C# 2 一、泛型 使用泛型(generic type)可以在編寫在編譯時類型安全的通用程式碼，無須事先知道要使用的具體類型。 示例1: array類型: 大小需預先設定，若要添加需要重新分配 public static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(string[] names) { foreach (string name in names) { Console.WriteLine(name); } } public static string[] GenerateNames() { string[] names = new string[4]; names[0] = "Mike"; names[1] = "Rain"; names[2] = "Jessica"; names[3] = "Billy"; return names; } 示例2: ArrayList類型: ArrayList.Add是Object的方法，但如果塞入不適合的參數類型，可能會引發InvalidCastException
public static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(ArrayList names) { foreach (object name in names) { Console.WriteLine(name); } } public static ArrayList GenerateNames() { ArrayList names = new ArrayList(); names.Add("Mike"); names.Add("Rain"); names.Add("Jessica"); names.Add("Billy"); return names; } 示例3: StringCollection專用類型: 解決前述兩個問題，但也限制了返回值。
...</p></div><footer class=entry-footer><span title='2023-01-20 10:10:46 +0800 +0800'>January 20, 2023</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] C# Depth Ch.2 C# 2" href=https://intervalrain.github.io/it/csharp_depth_ch2/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[IT] C# Depth Ch.1 與時俱進的語言</h2></header><div class=entry-content><p>與時俱進的語言 一、System Class 1. 泛型(genric) 可更清楚的描述序列中每個元素的類型。 C#1 示例
public class Bookshelf { public IEnumerable Books { get { ... } } } C#2 示例：泛型
public class Bookshelf { public IEnumerable&lt;Book> Books { get { ... } } } 2. 可空值類型(nullable value type) 可有效的表示未定的變量值，以擺脫魔數(用-1當集合索引，用 MinValue 或 MaxValue 做為初始值)。 示例
string? a = null; Console.WriteLine(a ?? "null"); // null a = "abc"; Console.WriteLine(a ?? "null"); // abc 3. 匿名類型(anonymous type)、隱式局部變數(var) 兩者皆可解決靜態類型語言的缺陷：程式碼冗長。 示例1: 匿名類型(anonymous type)
var book = new { Title = "Harry Potter", Author = "J.K. Rowling" } string title = book.Title; string author = book.Author; 若已經調用了建構式的話，就無需顯式的宣該告變數的類型了。 示例2: 隱式類型(implicit typing)
...</p></div><footer class=entry-footer><span title='2023-01-17 22:27:58 +0800 +0800'>January 17, 2023</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] C# Depth Ch.1 與時俱進的語言" href=https://intervalrain.github.io/it/csharp_depth_ch1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>[IT] Shell 筆記</h2></header><div class=entry-content><p>Reference
https://blog.csdn.net/w918589859/article/details/108752592
https://www.w3cschool.cn/linux/linux-Shell.html
一、Shell 簡介 什麼是 Shell?
Shell 是一個用 C 語言編寫的程式，它是使用者使用 Linux 的橋樑。Shell 既是一種命令語言，又是一種程式設計語言。
Shell 是指一種應用程式，這個應用程式提供了一個界面，使用者通過這個界面訪問作業系統核心(kernel)的服務。 為什麼要學習和使用 Shell?
Shell 屬於內建的腳本，程序開發的效率非常高，依賴於功能強大的命令可以迅速的完成開發任務(批次處理)。 Shell 腳本(Shell script)
是一種為 Shell 編寫的腳本程式。業界所說的 Shell 通常都是指 Shell 腳本。 二、 Shell 入門 1. Shell 環境 Shell 編程需要能編寫程式碼的文本編輯器和一個能解釋執行的腳本解釋器。 在 linux 中有很多類型的 Shell，不同的 Shell 具備不同的功能，Shell 還決定了腳本中函數的語法。 Bash 是 Linux 中默認的 Shell。一般情況下，人們不區分 Bourne Shell 和 Bourne Again Shell，所以 #!/bin/sh 也可以被替換成 #!/bin/bash Linux 的 Shell 種類眾多，不同的 Shell 都有自己的特點以及用途，常見的有： Bourne Shell (/usr/bin/sh 或 /bin/sh) Bourne Again Shell (/bin/bash) C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root(sbin/sh) …… 2. Bash 常用快捷鏈 快捷鏈 功能 Ctrl+A 把游標移動到命令行開頭。 Ctrl+E 把游標移動到命令行結尾。 Ctrl+C 強制終止當前的命令。 Ctrl+L 清除螢幕，等於 clear 指令。 Ctrl+U 清除並剪下當前命令。 Ctrl+K 刪除並剪下游標以後的命令。 Ctrl+Y 貼上。 Ctrl+R 在歷史命令中搜索，按下 Ctrl+R 之後，就會出現搜索界面，只要輸入搜索內容，就會從歷史命令中搜索。 Ctrl+D 退出當前終端機。 Ctrl+Z 暫停，並放入後台。 Ctrl+S 暫停螢幕輸出。 Ctrl+Q 恢復螢幕輸出。 3. 輸入與輸出 I/O linux 的標準輸入與輸出
...</p></div><footer class=entry-footer><span title='2023-01-12 23:34:41 +0800 +0800'>January 12, 2023</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] Shell 筆記" href=https://intervalrain.github.io/it/shell/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[IT] 動態鏈結庫(DDL)</h2></header><div class=entry-content><p>動態鏈結庫(Dynamic Linked Library, DDL) 將程式中重複引用的程式庫獨立包裝出來以便共同引用 好處是比起靜態庫更節省空間 也可以單獨修改動態庫文件 示例 創建一個自定義程式庫 math.c // math.c int add(int a, int b) { return a + b; } 建建一個 math.h 只包含函式的宣告 // math.h int add(int a, int b); 將 math.c 編譯成一個動態庫 -shared 表明是一個 shared library .so 是 Linux 下的動態庫的副檔名，Windows 下為 .dll $ gcc -shared -fPIC math.c -o libmath.so 在主程式中包含 math.h 頭文件 // main.c #include &lt;stdio.h> #include &lt;math.h> int main() { printf("add(1, 2) returns %d\n", add(1, 2)); return 0; } 利用 -l 編譯主程式 省略 libmath.so 中的 lib 與 .so 為 -lmath gcc main.c -lmath -L. -o main 系統在路徑下找不到文件的解決方案 將動態庫複製到系統路徑下(需要 root 權限) $ sudo ^C cp libmath.so /usr/local/lib/ 使用環境變量，將當前目錄加到 LD_LIBRARY_PATH 環境變量中 $ export LD_LIBRARY_PATH="$(pwd)" // 將當前目錄叫到 LD_LIBRARY_PATH中 $ echo $LD_LIBRARY_PATH // 測試是否調用成功</p></div><footer class=entry-footer><span title='2022-09-18 22:45:56 +0800 +0800'>September 18, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] 動態鏈結庫(DDL)" href=https://intervalrain.github.io/it/ddl/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/it/>«&nbsp;上一頁&nbsp;
</a><a class=next href=https://intervalrain.github.io/it/page/3/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>