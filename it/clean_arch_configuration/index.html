<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[IT] 使用 Clean Architecture + DDD 建置 Restful API | Rain Hu's Workspace</title><meta name=keywords content="IT,C#,Clean Architecture"><meta name=description content='程式碼
https://github.com/intervalrain/webapi_ca/
正文
建置 Solution


首先先參考 Clean Architecture 最經典的同心圓，來確定我們需要將我們的解決方案做哪些分層：

我將使用 Restful API 做為我們 I/O (Presentation Layer)
並且我需要配備身份驗證的機制 (Presentation Layer)
我使用 PostgresDB 作為我的 (Infrastructure Layer)
我的核心商業邏輯 (Application / Domain Layer)




創建專案


dotnet new sln -o Mysln

進入專案所在的資料夾

cd Mysln

根據預先的分層建立專案資料夾，並且使用 dotnet 指令建立相對應的專案類型。

Api &ndash;> WebAPI
Infrastructure &ndash;> classlib
Contracts &ndash;> classlib
Application &ndash;> classlib
Domain &ndash;> classlib



dotnet new webapi -o Mysln.Api
dotnet new classlib -o Mysln.Contracts
dotnet new classlib -o Mysln.Infrastructure
dotnet new classlib -o Mysln.Application
dotnet new classlib -o Mysln.Domain

接著我們需要把產生的專案資料夾，加入到我們的 Solution。

dotnet sln add Mysln.Api
dotnet sln add Mysln.Application
dotnet sln add Mysln.Contracts
dotnet sln add Mysln.Domain
dotnet sln add Mysln.Infrastructure

接下來按照 Clean Architecture 的依賴原則來設定 dependency，依我的專案來說依賴方向如下。

    
graph TD;
  Api-->Contracts;
  Api-->Application;
  Infrastructure-->Application
  Application-->Domain
  Api-.->Infrastructure



dotnet add Mysln.Api reference Mysln.Contracts Mysln.Application
dotnet add Mysln.Infrastructure reference Mysln.Application
dotnet add Mysln.Application reference Mysln.Domain
dotnet add Mysln.Api reference Mysln.Infrastructure

至此，已經完成了基本的 hierarchy 建置，接下來要為 Restful Client 做準備。

Login Authentication

作為驗證的需要，我們需要以下三種驗證檔案，包含兩個 Request 與一個 Response

public record RegisterRequest(
    string FirstName,
    string LastName,
    string Email,
    string Password
);

public record LoginRequest(
    string Email,
    string Password
);

public record AuthenticationResponse(
    Guid Id,
    string FirstName,
    string LastName,
    string Email,
    string token
);

到 Controller 去設置註冊與登入的兩個路由，並且將之後的服務介面預先注入到其中。

[ApiController]
[Route("auth")]
public class AuthenticationController : ControllerBase
{
	[HttpPost("register")]
	public IActionResult Register(RegisterRequest request)
	{
		return Ok(request);
	}

	[HttpPost("login")]
	public IActionResult Login(LoginRequest request)
	{
		return Ok(request);
	}
}

接著我們創建 Application 中的服務，注意到因為 Application 不依賴於 Contracts，故我們這邊需要創建自己的 DataModel

public record AuthenticationResult
(
    Guid Id,
    string FirstName,
    string LastName,
    string Email,
    string Token
);

接著我們定義出 Application 的 Service。

public interface IAuthenticationService
{
	AuthenticationResult Register(string firstName, string lastName, string email, string password);
    AuthenticationResult Login(string email, string password);
}

定義好我們的 service interface 之後，就可以到 Presentation 中將我們的 service 注入到 presentation 之中。

[ApiController]
[Route("auth")]
public class AuthenticationController : ControllerBase
{
    private readonly IAuthenticationService _authenticationService;

    public AuthenticationController(IAuthenticationService authenticationService)
    {
        _authenticationService = authenticationService;
    }

    [HttpPost("register")]
	public IActionResult Register(RegisterRequest request)
	{
		var authResult = _authenticationService.Register(
			request.FirstName,
			request.LastName,
			request.Email,
			request.Password);
		var response = new AuthenticationResponse(
            authResult.Id,
            authResult.FirstName,
            authResult.LastName,
            authResult.Email,
            authResult.Token);
		return Ok(response);
	}

	[HttpPost("login")]
	public IActionResult Login(LoginRequest request)
	{
        var authResult = _authenticationService.Login(
            request.Email,
            request.Password);
        var response = new AuthenticationResponse(
            authResult.Id,
            authResult.FirstName,
            authResult.LastName,
            authResult.Email,
            authResult.Token);
        return Ok(response);
    }
}

我們已經定義好我們的 service 後，便可以到 presentation 的 Program(或是其它入口點，如 Startup.cs 或 MauiProgram.cs)，做 service 的依賴注入。

using BuberDinner.Application.Services.Authentication;

var builder = WebApplication.CreateBuilder(args);
{
    builder.Services.AddScoped<IAuthenticationService, AuthenticationService>();
    builder.Services.AddControllers();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();
}

var app = builder.Build();
{
    app.UseSwagger();
    app.UseSwaggerUI();
    app.UseHttpsRedirection();
    app.MapControllers();
    app.Run();
}

最後，我們先實作一個暫時的 Service，來確認 Api 是可以作業的。

public class AuthenticationService : IAuthenticationService
{
    public AuthenticationResult Register(string firstName, string lastName, string email, string password)
    {
        return new AuthenticationResult(
            Guid.NewGuid(),
            firstName,
            lastName,
            email,
            "token"
            );
    }

    public AuthenticationResult Login(string email, string password)
    {
        return new AuthenticationResult(
            Guid.NewGuid(),
            "firstName",
            "lastName",
            email,
            "token"
            );
    }
}

執行 dotnet run --project .\Mysln.Api\
在 Swagger 中測試我們實作的 register 與 login API，如果正常工作，會回傳 StatusCode: 200。

Dependency Injection

我們想要每一層都可以自己管理自己的注入，此時我們需要引入 Microsoft.Extensions.DependencyInjection。
接下來實作 Application 的 DependencyInjection。

public static class DependencyInjection
{
    public static IServiceCollection AddApllication(this IServiceCollection services)
    {
        services.AddScope<IAuthenticationService, AuthenticationService>();
        return services;
    }
}

接下來實作 Infrastructure 的 DependencyInjection。(暫時還沒有注入 repository)

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services)
    {
        // 未來要注入 repositories
        return services;
    }
}

接下來我們可以改寫 Program.cs。

using BuberDinner.Application;
using BuberDinner.Infrastructure;

var builder = WebApplication.CreateBuilder(args);
{
    builder.Services
        .AddApplication()
        .AddInfrastructure();
    builder.Services.AddControllers();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();
}

var app = builder.Build();
{
    app.UseSwagger();
    app.UseSwaggerUI();
    app.UseHttpsRedirection();
    app.MapControllers();
    app.Run();
}
實作 JWT Token Generator

首先先在 Application Layer 創建一個 interface 來做依賴反轉

public interface IJwtTokenGenerator
{
    string GenerateToken(Guid userId, string firstName, string lastName);
}

接著我們到 Infrastructure Layer 來實作我們的 JwtTokenGenerator。
首先我們需要 System.IdentityModel.Tokens.Jwt 這個 Package。
接著我們實作 JwtTokenGenerator。

public class JwtTokenGenerator : IJwtTokenGenerator
{
    public string GenerateToken(Guid userId, string firstName, string lastName)
    {
        var signingCredentials = new SigningCredentials(
            new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes("super-secret-key")),
            SecurityAlgorithms.HmacSha256);

        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()),
            new Claim(JwtRegisteredClaimNames.GivenName, firstName),
            new Claim(JwtRegisteredClaimNames.FamilyName, lastName),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };

        var securityToken = new JwtSecurityToken(
            issuer: "Mysln",
            expires: DateTime.Now.AddDays(1),
            claims: claims,
            signingCredentials: signingCredentials);

        return new JwtSecurityTokenHandler().WriteToken(securityToken);
    }
}

接著我們將之注入到服務中，即大功告成了。

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services)
    {
        services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>();
        return services;
    }
}
使用 Options Pattern 注入 JWT Settings

接下來我們要使用 Options Pattern 將 JWT Settings 注入到 JwtTokenGenerator 中。
首先我們先到 Mysln.Api 的 appsettings.json 中將 options 設置完成。

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
    "JwtSettings": {
    "Secret": "super-secret-key",
    "ExpiryMinutes": 60,
    "Issuer": "Mysln",
    "Audience:": "Mysln"
  }
}

由於我們要使用 Options Pattern，我們需要改寫我們的 Program.cs，並且將 ConfigurationManager 注入到 Infrastructure 的 DependencyInjection。
為此我們需要引入套件 Microsoft.Extensions.Configuration 與 Microsoft.Extensions.Options.ConfigurationExtensions。
並且我們需要創建一個 Model。

public class JwtSettings
{
    public const string SectionName = "JwtSettings";
	public string Secret { get; init; } = null!;
	public int ExpiryMinutes { get; init; }
	public string Issuer { get; init; } = null!;
	public string Audience { get; init; } = null!;
}

Program.cs 需改寫成：

builder.Services
        .AddApplication()
        .AddInfrastructure(builder.Configuration);

將 DependencyInjection 改寫成：

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration)
    {
        services.Configure<JwtSettings>(configuration.GetSection(JwtSettings.SectionName));
        services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>();
        services.AddSingleton<IDateTimeProvider, DateTimeProvider>();
        return services;
    }
}

接下來，我們可以把 JwtTokenGenerator 改寫成：

public class JwtTokenGenerator : IJwtTokenGenerator
{
    private readonly JwtSettings _jwtSettings;
    private readonly IDateTimeProvider _dateTimeProvider;

    public JwtTokenGenerator(IDateTimeProvider dateTimeProvider, IOptions<JwtSettings> jwtOptions)
    {
        _dateTimeProvider = dateTimeProvider;
        _jwtSettings = jwtOptions.Value;
    }

    public string GenerateToken(Guid userId, string firstName, string lastName)
    {
        var signingCredentials = new SigningCredentials(
            new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(_jwtSettings.Secret)),
            SecurityAlgorithms.HmacSha256);

        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()),
            new Claim(JwtRegisteredClaimNames.GivenName, firstName),
            new Claim(JwtRegisteredClaimNames.FamilyName, lastName),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };

        var securityToken = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            expires: _dateTimeProvider.UtcNow.AddMinutes(_jwtSettings.ExpiryMinutes),
            claims: claims,
            signingCredentials: signingCredentials);

        return new JwtSecurityTokenHandler().WriteToken(securityToken);
    }
}

以上就大功告成了。

使用 dotnet user-secrets 指令

如果不想要將 Options 中的 secret 儲存在程式(appsettings.json)裡面，可以利用 dotnet user-secrets 將 secret 儲存於環境變數裡面。
透過執行以下的指令來初始化專案的 UserSecretsId

dotnet user-secrets init --project Mysln.Api

接著將 UserSecretsId 綁定到我們專案的 JwtSettings:Secret。

dotnet user-secrets set --project Mysln.Api "JwtSettings:Secret"

日後可以經由以下指令查詢。

dotnet user-secrets list --project Mysln.Api
Domain Model

先建立一個簡單的 Domain Model(Entity)

public class User
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string FirstName { get; set; } = null!;
    public string LastName { get; set; } = null!;
    public string Email { get; set; } = null!;
    public string Password { get; set; } = null!;
}
Repository Pattern

在 Application Layer 建立 IRepository

public interface IUserRepository
{
    User? GetUserByEmail(string email);
    void Add(User user);

}

將 IRepository 注入 Application 的 Service
並用查改存推改寫 Service

public class AuthenticationService : IAuthenticationService
{
    private readonly IJwtTokenGenerator _jwtTokenGenerator;
    private readonly IUserRepository _userRepository;
    public AuthenticationService(IJwtTokenGenerator jwtTokenGenerator, IUserRepository userRepository)
    {
        _jwtTokenGenerator = jwtTokenGenerator;
        _userRepository = userRepository;
    }

    public AuthenticationResult Register(string firstName, string lastName, string email, string password)
    {
        // 查
        if (_userRepository.GetUserByEmail(email) is not null)
        {
            throw new Exception("User with given email already exists.");
        }
        // 改
        var user = new User
        {
            FirstName = firstName,
            LastName = lastName,
            Email = email,
            Password = password
        };
        // 存
        _userRepository.Add(user);
        // 推
        var token = _jwtTokenGenerator.GenerateToken(user.Id, firstName, lastName);
        return new AuthenticationResult(user.Id, firstName, lastName, email, token);
    }

    public AuthenticationResult Login(string email, string password)
    {
        // 查
        if (_userRepository.GetUserByEmail(email) is not User user)
        {
            throw new Exception("User with given email does not exist.");
        }
        if (user.Password != password)
        {
            throw new Exception("Invalid password.");
        }
        // 改
        var token = _jwtTokenGenerator.GenerateToken(user.Id, user.FirstName, user.LastName);
        
        return new AuthenticationResult(user.Id, user.FirstName, user.LastName, email, token);
    }
}

接著我們在 Infrastructure Layer 實作我們的 repository，我們暫時先不接資料庫，所以先做一個 InMemory 版本的 repository 來做測試。

public class UserRepository : IUserRepository
{
    private readonly List<User> _users = new();

    public void Add(User user)
    {
        _users.Add(user);
    }

    public User? GetUserByEmail(string email)
    {
        return _users.SingleOrDefault(u => u.Email.Equals(email));
    }
}

實作完需要透過 DependencyInjection 注入到我們的 Service Container 內。

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration)
    {
        services.Configure<JwtSettings>(configuration.GetSection(JwtSettings.SectionName));
        services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>();
        services.AddSingleton<IDateTimeProvider, DateTimeProvider>();
        services.AddSingleton<IUserRepository, UserRepository>();
        return services;
    }
}

至此，我們已經完成了一個簡單的身份認證的 API。
'><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4c6c0beaf1dfe52cd0f712a5896ac127e66fd064cfc598e04750f496d470699e.css integrity="sha256-TGwL6vHf5SzQ9xKliWrBJ+Zv0GTPxZjgR1D0ltRwaZ4=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/it/clean_arch_configuration/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/it/clean_arch_configuration/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[IT] 使用 Clean Architecture + DDD 建置 Restful API"><meta property="og:description" content='程式碼 https://github.com/intervalrain/webapi_ca/
正文 建置 Solution 首先先參考 Clean Architecture 最經典的同心圓，來確定我們需要將我們的解決方案做哪些分層：
我將使用 Restful API 做為我們 I/O (Presentation Layer) 並且我需要配備身份驗證的機制 (Presentation Layer) 我使用 PostgresDB 作為我的 (Infrastructure Layer) 我的核心商業邏輯 (Application / Domain Layer) 創建專案
dotnet new sln -o Mysln 進入專案所在的資料夾 cd Mysln 根據預先的分層建立專案資料夾，並且使用 dotnet 指令建立相對應的專案類型。 Api –> WebAPI Infrastructure –> classlib Contracts –> classlib Application –> classlib Domain –> classlib dotnet new webapi -o Mysln.Api dotnet new classlib -o Mysln.Contracts dotnet new classlib -o Mysln.Infrastructure dotnet new classlib -o Mysln.Application dotnet new classlib -o Mysln.Domain 接著我們需要把產生的專案資料夾，加入到我們的 Solution。 dotnet sln add Mysln.Api dotnet sln add Mysln.Application dotnet sln add Mysln.Contracts dotnet sln add Mysln.Domain dotnet sln add Mysln.Infrastructure 接下來按照 Clean Architecture 的依賴原則來設定 dependency，依我的專案來說依賴方向如下。 graph TD; Api-->Contracts; Api-->Application; Infrastructure-->Application Application-->Domain Api-.->Infrastructure dotnet add Mysln.Api reference Mysln.Contracts Mysln.Application dotnet add Mysln.Infrastructure reference Mysln.Application dotnet add Mysln.Application reference Mysln.Domain dotnet add Mysln.Api reference Mysln.Infrastructure 至此，已經完成了基本的 hierarchy 建置，接下來要為 Restful Client 做準備。 Login Authentication 作為驗證的需要，我們需要以下三種驗證檔案，包含兩個 Request 與一個 Response public record RegisterRequest( string FirstName, string LastName, string Email, string Password ); public record LoginRequest( string Email, string Password ); public record AuthenticationResponse( Guid Id, string FirstName, string LastName, string Email, string token ); 到 Controller 去設置註冊與登入的兩個路由，並且將之後的服務介面預先注入到其中。 [ApiController] [Route("auth")] public class AuthenticationController : ControllerBase { [HttpPost("register")] public IActionResult Register(RegisterRequest request) { return Ok(request); } [HttpPost("login")] public IActionResult Login(LoginRequest request) { return Ok(request); } } 接著我們創建 Application 中的服務，注意到因為 Application 不依賴於 Contracts，故我們這邊需要創建自己的 DataModel public record AuthenticationResult ( Guid Id, string FirstName, string LastName, string Email, string Token ); 接著我們定義出 Application 的 Service。 public interface IAuthenticationService { AuthenticationResult Register(string firstName, string lastName, string email, string password); AuthenticationResult Login(string email, string password); } 定義好我們的 service interface 之後，就可以到 Presentation 中將我們的 service 注入到 presentation 之中。 [ApiController] [Route("auth")] public class AuthenticationController : ControllerBase { private readonly IAuthenticationService _authenticationService; public AuthenticationController(IAuthenticationService authenticationService) { _authenticationService = authenticationService; } [HttpPost("register")] public IActionResult Register(RegisterRequest request) { var authResult = _authenticationService.Register( request.FirstName, request.LastName, request.Email, request.Password); var response = new AuthenticationResponse( authResult.Id, authResult.FirstName, authResult.LastName, authResult.Email, authResult.Token); return Ok(response); } [HttpPost("login")] public IActionResult Login(LoginRequest request) { var authResult = _authenticationService.Login( request.Email, request.Password); var response = new AuthenticationResponse( authResult.Id, authResult.FirstName, authResult.LastName, authResult.Email, authResult.Token); return Ok(response); } } 我們已經定義好我們的 service 後，便可以到 presentation 的 Program(或是其它入口點，如 Startup.cs 或 MauiProgram.cs)，做 service 的依賴注入。 using BuberDinner.Application.Services.Authentication; var builder = WebApplication.CreateBuilder(args); { builder.Services.AddScoped<IAuthenticationService, AuthenticationService>(); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); } var app = builder.Build(); { app.UseSwagger(); app.UseSwaggerUI(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); } 最後，我們先實作一個暫時的 Service，來確認 Api 是可以作業的。 public class AuthenticationService : IAuthenticationService { public AuthenticationResult Register(string firstName, string lastName, string email, string password) { return new AuthenticationResult( Guid.NewGuid(), firstName, lastName, email, "token" ); } public AuthenticationResult Login(string email, string password) { return new AuthenticationResult( Guid.NewGuid(), "firstName", "lastName", email, "token" ); } } 執行 dotnet run --project .\Mysln.Api\ 在 Swagger 中測試我們實作的 register 與 login API，如果正常工作，會回傳 StatusCode: 200。 Dependency Injection 我們想要每一層都可以自己管理自己的注入，此時我們需要引入 Microsoft.Extensions.DependencyInjection。 接下來實作 Application 的 DependencyInjection。 public static class DependencyInjection { public static IServiceCollection AddApllication(this IServiceCollection services) { services.AddScope<IAuthenticationService, AuthenticationService>(); return services; } } 接下來實作 Infrastructure 的 DependencyInjection。(暫時還沒有注入 repository) public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services) { // 未來要注入 repositories return services; } } 接下來我們可以改寫 Program.cs。 using BuberDinner.Application; using BuberDinner.Infrastructure; var builder = WebApplication.CreateBuilder(args); { builder.Services .AddApplication() .AddInfrastructure(); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); } var app = builder.Build(); { app.UseSwagger(); app.UseSwaggerUI(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); } 實作 JWT Token Generator 首先先在 Application Layer 創建一個 interface 來做依賴反轉 public interface IJwtTokenGenerator { string GenerateToken(Guid userId, string firstName, string lastName); } 接著我們到 Infrastructure Layer 來實作我們的 JwtTokenGenerator。 首先我們需要 System.IdentityModel.Tokens.Jwt 這個 Package。 接著我們實作 JwtTokenGenerator。 public class JwtTokenGenerator : IJwtTokenGenerator { public string GenerateToken(Guid userId, string firstName, string lastName) { var signingCredentials = new SigningCredentials( new SymmetricSecurityKey( Encoding.UTF8.GetBytes("super-secret-key")), SecurityAlgorithms.HmacSha256); var claims = new[] { new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()), new Claim(JwtRegisteredClaimNames.GivenName, firstName), new Claim(JwtRegisteredClaimNames.FamilyName, lastName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }; var securityToken = new JwtSecurityToken( issuer: "Mysln", expires: DateTime.Now.AddDays(1), claims: claims, signingCredentials: signingCredentials); return new JwtSecurityTokenHandler().WriteToken(securityToken); } } 接著我們將之注入到服務中，即大功告成了。 public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services) { services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>(); return services; } } 使用 Options Pattern 注入 JWT Settings 接下來我們要使用 Options Pattern 將 JWT Settings 注入到 JwtTokenGenerator 中。 首先我們先到 Mysln.Api 的 appsettings.json 中將 options 設置完成。 { "Logging": { "LogLevel": { "Default": "Information", "Microsoft.AspNetCore": "Warning" } }, "AllowedHosts": "*", "JwtSettings": { "Secret": "super-secret-key", "ExpiryMinutes": 60, "Issuer": "Mysln", "Audience:": "Mysln" } } 由於我們要使用 Options Pattern，我們需要改寫我們的 Program.cs，並且將 ConfigurationManager 注入到 Infrastructure 的 DependencyInjection。 為此我們需要引入套件 Microsoft.Extensions.Configuration 與 Microsoft.Extensions.Options.ConfigurationExtensions。 並且我們需要創建一個 Model。 public class JwtSettings { public const string SectionName = "JwtSettings"; public string Secret { get; init; } = null!; public int ExpiryMinutes { get; init; } public string Issuer { get; init; } = null!; public string Audience { get; init; } = null!; } Program.cs 需改寫成： builder.Services .AddApplication() .AddInfrastructure(builder.Configuration); 將 DependencyInjection 改寫成： public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration) { services.Configure<JwtSettings>(configuration.GetSection(JwtSettings.SectionName)); services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>(); services.AddSingleton<IDateTimeProvider, DateTimeProvider>(); return services; } } 接下來，我們可以把 JwtTokenGenerator 改寫成： public class JwtTokenGenerator : IJwtTokenGenerator { private readonly JwtSettings _jwtSettings; private readonly IDateTimeProvider _dateTimeProvider; public JwtTokenGenerator(IDateTimeProvider dateTimeProvider, IOptions<JwtSettings> jwtOptions) { _dateTimeProvider = dateTimeProvider; _jwtSettings = jwtOptions.Value; } public string GenerateToken(Guid userId, string firstName, string lastName) { var signingCredentials = new SigningCredentials( new SymmetricSecurityKey( Encoding.UTF8.GetBytes(_jwtSettings.Secret)), SecurityAlgorithms.HmacSha256); var claims = new[] { new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()), new Claim(JwtRegisteredClaimNames.GivenName, firstName), new Claim(JwtRegisteredClaimNames.FamilyName, lastName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }; var securityToken = new JwtSecurityToken( issuer: _jwtSettings.Issuer, audience: _jwtSettings.Audience, expires: _dateTimeProvider.UtcNow.AddMinutes(_jwtSettings.ExpiryMinutes), claims: claims, signingCredentials: signingCredentials); return new JwtSecurityTokenHandler().WriteToken(securityToken); } } 以上就大功告成了。 使用 dotnet user-secrets 指令 如果不想要將 Options 中的 secret 儲存在程式(appsettings.json)裡面，可以利用 dotnet user-secrets 將 secret 儲存於環境變數裡面。 透過執行以下的指令來初始化專案的 UserSecretsId dotnet user-secrets init --project Mysln.Api 接著將 UserSecretsId 綁定到我們專案的 JwtSettings:Secret。 dotnet user-secrets set --project Mysln.Api "JwtSettings:Secret" 日後可以經由以下指令查詢。 dotnet user-secrets list --project Mysln.Api Domain Model 先建立一個簡單的 Domain Model(Entity) public class User { public Guid Id { get; set; } = Guid.NewGuid(); public string FirstName { get; set; } = null!; public string LastName { get; set; } = null!; public string Email { get; set; } = null!; public string Password { get; set; } = null!; } Repository Pattern 在 Application Layer 建立 IRepository public interface IUserRepository { User? GetUserByEmail(string email); void Add(User user); } 將 IRepository 注入 Application 的 Service 並用查改存推改寫 Service public class AuthenticationService : IAuthenticationService { private readonly IJwtTokenGenerator _jwtTokenGenerator; private readonly IUserRepository _userRepository; public AuthenticationService(IJwtTokenGenerator jwtTokenGenerator, IUserRepository userRepository) { _jwtTokenGenerator = jwtTokenGenerator; _userRepository = userRepository; } public AuthenticationResult Register(string firstName, string lastName, string email, string password) { // 查 if (_userRepository.GetUserByEmail(email) is not null) { throw new Exception("User with given email already exists."); } // 改 var user = new User { FirstName = firstName, LastName = lastName, Email = email, Password = password }; // 存 _userRepository.Add(user); // 推 var token = _jwtTokenGenerator.GenerateToken(user.Id, firstName, lastName); return new AuthenticationResult(user.Id, firstName, lastName, email, token); } public AuthenticationResult Login(string email, string password) { // 查 if (_userRepository.GetUserByEmail(email) is not User user) { throw new Exception("User with given email does not exist."); } if (user.Password != password) { throw new Exception("Invalid password."); } // 改 var token = _jwtTokenGenerator.GenerateToken(user.Id, user.FirstName, user.LastName); return new AuthenticationResult(user.Id, user.FirstName, user.LastName, email, token); } } 接著我們在 Infrastructure Layer 實作我們的 repository，我們暫時先不接資料庫，所以先做一個 InMemory 版本的 repository 來做測試。 public class UserRepository : IUserRepository { private readonly List<User> _users = new(); public void Add(User user) { _users.Add(user); } public User? GetUserByEmail(string email) { return _users.SingleOrDefault(u => u.Email.Equals(email)); } } 實作完需要透過 DependencyInjection 注入到我們的 Service Container 內。 public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration) { services.Configure<JwtSettings>(configuration.GetSection(JwtSettings.SectionName)); services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>(); services.AddSingleton<IDateTimeProvider, DateTimeProvider>(); services.AddSingleton<IUserRepository, UserRepository>(); return services; } } 至此，我們已經完成了一個簡單的身份認證的 API。 '><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="it"><meta property="article:published_time" content="2024-02-26T15:03:15+08:00"><meta property="article:modified_time" content="2024-02-26T15:03:15+08:00"><meta property="article:tag" content="IT"><meta property="article:tag" content="C#"><meta property="article:tag" content="Clean Architecture"><meta name=twitter:card content="summary"><meta name=twitter:title content="[IT] 使用 Clean Architecture + DDD 建置 Restful API"><meta name=twitter:description content='程式碼
https://github.com/intervalrain/webapi_ca/
正文
建置 Solution


首先先參考 Clean Architecture 最經典的同心圓，來確定我們需要將我們的解決方案做哪些分層：

我將使用 Restful API 做為我們 I/O (Presentation Layer)
並且我需要配備身份驗證的機制 (Presentation Layer)
我使用 PostgresDB 作為我的 (Infrastructure Layer)
我的核心商業邏輯 (Application / Domain Layer)




創建專案


dotnet new sln -o Mysln

進入專案所在的資料夾

cd Mysln

根據預先的分層建立專案資料夾，並且使用 dotnet 指令建立相對應的專案類型。

Api &ndash;> WebAPI
Infrastructure &ndash;> classlib
Contracts &ndash;> classlib
Application &ndash;> classlib
Domain &ndash;> classlib



dotnet new webapi -o Mysln.Api
dotnet new classlib -o Mysln.Contracts
dotnet new classlib -o Mysln.Infrastructure
dotnet new classlib -o Mysln.Application
dotnet new classlib -o Mysln.Domain

接著我們需要把產生的專案資料夾，加入到我們的 Solution。

dotnet sln add Mysln.Api
dotnet sln add Mysln.Application
dotnet sln add Mysln.Contracts
dotnet sln add Mysln.Domain
dotnet sln add Mysln.Infrastructure

接下來按照 Clean Architecture 的依賴原則來設定 dependency，依我的專案來說依賴方向如下。

    
graph TD;
  Api-->Contracts;
  Api-->Application;
  Infrastructure-->Application
  Application-->Domain
  Api-.->Infrastructure



dotnet add Mysln.Api reference Mysln.Contracts Mysln.Application
dotnet add Mysln.Infrastructure reference Mysln.Application
dotnet add Mysln.Application reference Mysln.Domain
dotnet add Mysln.Api reference Mysln.Infrastructure

至此，已經完成了基本的 hierarchy 建置，接下來要為 Restful Client 做準備。

Login Authentication

作為驗證的需要，我們需要以下三種驗證檔案，包含兩個 Request 與一個 Response

public record RegisterRequest(
    string FirstName,
    string LastName,
    string Email,
    string Password
);

public record LoginRequest(
    string Email,
    string Password
);

public record AuthenticationResponse(
    Guid Id,
    string FirstName,
    string LastName,
    string Email,
    string token
);

到 Controller 去設置註冊與登入的兩個路由，並且將之後的服務介面預先注入到其中。

[ApiController]
[Route("auth")]
public class AuthenticationController : ControllerBase
{
	[HttpPost("register")]
	public IActionResult Register(RegisterRequest request)
	{
		return Ok(request);
	}

	[HttpPost("login")]
	public IActionResult Login(LoginRequest request)
	{
		return Ok(request);
	}
}

接著我們創建 Application 中的服務，注意到因為 Application 不依賴於 Contracts，故我們這邊需要創建自己的 DataModel

public record AuthenticationResult
(
    Guid Id,
    string FirstName,
    string LastName,
    string Email,
    string Token
);

接著我們定義出 Application 的 Service。

public interface IAuthenticationService
{
	AuthenticationResult Register(string firstName, string lastName, string email, string password);
    AuthenticationResult Login(string email, string password);
}

定義好我們的 service interface 之後，就可以到 Presentation 中將我們的 service 注入到 presentation 之中。

[ApiController]
[Route("auth")]
public class AuthenticationController : ControllerBase
{
    private readonly IAuthenticationService _authenticationService;

    public AuthenticationController(IAuthenticationService authenticationService)
    {
        _authenticationService = authenticationService;
    }

    [HttpPost("register")]
	public IActionResult Register(RegisterRequest request)
	{
		var authResult = _authenticationService.Register(
			request.FirstName,
			request.LastName,
			request.Email,
			request.Password);
		var response = new AuthenticationResponse(
            authResult.Id,
            authResult.FirstName,
            authResult.LastName,
            authResult.Email,
            authResult.Token);
		return Ok(response);
	}

	[HttpPost("login")]
	public IActionResult Login(LoginRequest request)
	{
        var authResult = _authenticationService.Login(
            request.Email,
            request.Password);
        var response = new AuthenticationResponse(
            authResult.Id,
            authResult.FirstName,
            authResult.LastName,
            authResult.Email,
            authResult.Token);
        return Ok(response);
    }
}

我們已經定義好我們的 service 後，便可以到 presentation 的 Program(或是其它入口點，如 Startup.cs 或 MauiProgram.cs)，做 service 的依賴注入。

using BuberDinner.Application.Services.Authentication;

var builder = WebApplication.CreateBuilder(args);
{
    builder.Services.AddScoped<IAuthenticationService, AuthenticationService>();
    builder.Services.AddControllers();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();
}

var app = builder.Build();
{
    app.UseSwagger();
    app.UseSwaggerUI();
    app.UseHttpsRedirection();
    app.MapControllers();
    app.Run();
}

最後，我們先實作一個暫時的 Service，來確認 Api 是可以作業的。

public class AuthenticationService : IAuthenticationService
{
    public AuthenticationResult Register(string firstName, string lastName, string email, string password)
    {
        return new AuthenticationResult(
            Guid.NewGuid(),
            firstName,
            lastName,
            email,
            "token"
            );
    }

    public AuthenticationResult Login(string email, string password)
    {
        return new AuthenticationResult(
            Guid.NewGuid(),
            "firstName",
            "lastName",
            email,
            "token"
            );
    }
}

執行 dotnet run --project .\Mysln.Api\
在 Swagger 中測試我們實作的 register 與 login API，如果正常工作，會回傳 StatusCode: 200。

Dependency Injection

我們想要每一層都可以自己管理自己的注入，此時我們需要引入 Microsoft.Extensions.DependencyInjection。
接下來實作 Application 的 DependencyInjection。

public static class DependencyInjection
{
    public static IServiceCollection AddApllication(this IServiceCollection services)
    {
        services.AddScope<IAuthenticationService, AuthenticationService>();
        return services;
    }
}

接下來實作 Infrastructure 的 DependencyInjection。(暫時還沒有注入 repository)

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services)
    {
        // 未來要注入 repositories
        return services;
    }
}

接下來我們可以改寫 Program.cs。

using BuberDinner.Application;
using BuberDinner.Infrastructure;

var builder = WebApplication.CreateBuilder(args);
{
    builder.Services
        .AddApplication()
        .AddInfrastructure();
    builder.Services.AddControllers();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();
}

var app = builder.Build();
{
    app.UseSwagger();
    app.UseSwaggerUI();
    app.UseHttpsRedirection();
    app.MapControllers();
    app.Run();
}
實作 JWT Token Generator

首先先在 Application Layer 創建一個 interface 來做依賴反轉

public interface IJwtTokenGenerator
{
    string GenerateToken(Guid userId, string firstName, string lastName);
}

接著我們到 Infrastructure Layer 來實作我們的 JwtTokenGenerator。
首先我們需要 System.IdentityModel.Tokens.Jwt 這個 Package。
接著我們實作 JwtTokenGenerator。

public class JwtTokenGenerator : IJwtTokenGenerator
{
    public string GenerateToken(Guid userId, string firstName, string lastName)
    {
        var signingCredentials = new SigningCredentials(
            new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes("super-secret-key")),
            SecurityAlgorithms.HmacSha256);

        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()),
            new Claim(JwtRegisteredClaimNames.GivenName, firstName),
            new Claim(JwtRegisteredClaimNames.FamilyName, lastName),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };

        var securityToken = new JwtSecurityToken(
            issuer: "Mysln",
            expires: DateTime.Now.AddDays(1),
            claims: claims,
            signingCredentials: signingCredentials);

        return new JwtSecurityTokenHandler().WriteToken(securityToken);
    }
}

接著我們將之注入到服務中，即大功告成了。

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services)
    {
        services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>();
        return services;
    }
}
使用 Options Pattern 注入 JWT Settings

接下來我們要使用 Options Pattern 將 JWT Settings 注入到 JwtTokenGenerator 中。
首先我們先到 Mysln.Api 的 appsettings.json 中將 options 設置完成。

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
    "JwtSettings": {
    "Secret": "super-secret-key",
    "ExpiryMinutes": 60,
    "Issuer": "Mysln",
    "Audience:": "Mysln"
  }
}

由於我們要使用 Options Pattern，我們需要改寫我們的 Program.cs，並且將 ConfigurationManager 注入到 Infrastructure 的 DependencyInjection。
為此我們需要引入套件 Microsoft.Extensions.Configuration 與 Microsoft.Extensions.Options.ConfigurationExtensions。
並且我們需要創建一個 Model。

public class JwtSettings
{
    public const string SectionName = "JwtSettings";
	public string Secret { get; init; } = null!;
	public int ExpiryMinutes { get; init; }
	public string Issuer { get; init; } = null!;
	public string Audience { get; init; } = null!;
}

Program.cs 需改寫成：

builder.Services
        .AddApplication()
        .AddInfrastructure(builder.Configuration);

將 DependencyInjection 改寫成：

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration)
    {
        services.Configure<JwtSettings>(configuration.GetSection(JwtSettings.SectionName));
        services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>();
        services.AddSingleton<IDateTimeProvider, DateTimeProvider>();
        return services;
    }
}

接下來，我們可以把 JwtTokenGenerator 改寫成：

public class JwtTokenGenerator : IJwtTokenGenerator
{
    private readonly JwtSettings _jwtSettings;
    private readonly IDateTimeProvider _dateTimeProvider;

    public JwtTokenGenerator(IDateTimeProvider dateTimeProvider, IOptions<JwtSettings> jwtOptions)
    {
        _dateTimeProvider = dateTimeProvider;
        _jwtSettings = jwtOptions.Value;
    }

    public string GenerateToken(Guid userId, string firstName, string lastName)
    {
        var signingCredentials = new SigningCredentials(
            new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(_jwtSettings.Secret)),
            SecurityAlgorithms.HmacSha256);

        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()),
            new Claim(JwtRegisteredClaimNames.GivenName, firstName),
            new Claim(JwtRegisteredClaimNames.FamilyName, lastName),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };

        var securityToken = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            expires: _dateTimeProvider.UtcNow.AddMinutes(_jwtSettings.ExpiryMinutes),
            claims: claims,
            signingCredentials: signingCredentials);

        return new JwtSecurityTokenHandler().WriteToken(securityToken);
    }
}

以上就大功告成了。

使用 dotnet user-secrets 指令

如果不想要將 Options 中的 secret 儲存在程式(appsettings.json)裡面，可以利用 dotnet user-secrets 將 secret 儲存於環境變數裡面。
透過執行以下的指令來初始化專案的 UserSecretsId

dotnet user-secrets init --project Mysln.Api

接著將 UserSecretsId 綁定到我們專案的 JwtSettings:Secret。

dotnet user-secrets set --project Mysln.Api "JwtSettings:Secret"

日後可以經由以下指令查詢。

dotnet user-secrets list --project Mysln.Api
Domain Model

先建立一個簡單的 Domain Model(Entity)

public class User
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string FirstName { get; set; } = null!;
    public string LastName { get; set; } = null!;
    public string Email { get; set; } = null!;
    public string Password { get; set; } = null!;
}
Repository Pattern

在 Application Layer 建立 IRepository

public interface IUserRepository
{
    User? GetUserByEmail(string email);
    void Add(User user);

}

將 IRepository 注入 Application 的 Service
並用查改存推改寫 Service

public class AuthenticationService : IAuthenticationService
{
    private readonly IJwtTokenGenerator _jwtTokenGenerator;
    private readonly IUserRepository _userRepository;
    public AuthenticationService(IJwtTokenGenerator jwtTokenGenerator, IUserRepository userRepository)
    {
        _jwtTokenGenerator = jwtTokenGenerator;
        _userRepository = userRepository;
    }

    public AuthenticationResult Register(string firstName, string lastName, string email, string password)
    {
        // 查
        if (_userRepository.GetUserByEmail(email) is not null)
        {
            throw new Exception("User with given email already exists.");
        }
        // 改
        var user = new User
        {
            FirstName = firstName,
            LastName = lastName,
            Email = email,
            Password = password
        };
        // 存
        _userRepository.Add(user);
        // 推
        var token = _jwtTokenGenerator.GenerateToken(user.Id, firstName, lastName);
        return new AuthenticationResult(user.Id, firstName, lastName, email, token);
    }

    public AuthenticationResult Login(string email, string password)
    {
        // 查
        if (_userRepository.GetUserByEmail(email) is not User user)
        {
            throw new Exception("User with given email does not exist.");
        }
        if (user.Password != password)
        {
            throw new Exception("Invalid password.");
        }
        // 改
        var token = _jwtTokenGenerator.GenerateToken(user.Id, user.FirstName, user.LastName);
        
        return new AuthenticationResult(user.Id, user.FirstName, user.LastName, email, token);
    }
}

接著我們在 Infrastructure Layer 實作我們的 repository，我們暫時先不接資料庫，所以先做一個 InMemory 版本的 repository 來做測試。

public class UserRepository : IUserRepository
{
    private readonly List<User> _users = new();

    public void Add(User user)
    {
        _users.Add(user);
    }

    public User? GetUserByEmail(string email)
    {
        return _users.SingleOrDefault(u => u.Email.Equals(email));
    }
}

實作完需要透過 DependencyInjection 注入到我們的 Service Container 內。

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration)
    {
        services.Configure<JwtSettings>(configuration.GetSection(JwtSettings.SectionName));
        services.AddSingleton<IJwtTokenGenerator, JwtTokenGenerator>();
        services.AddSingleton<IDateTimeProvider, DateTimeProvider>();
        services.AddSingleton<IUserRepository, UserRepository>();
        return services;
    }
}

至此，我們已經完成了一個簡單的身份認證的 API。
'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ITs","item":"https://intervalrain.github.io/it/"},{"@type":"ListItem","position":2,"name":"[IT] 使用 Clean Architecture + DDD 建置 Restful API","item":"https://intervalrain.github.io/it/clean_arch_configuration/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[IT] 使用 Clean Architecture + DDD 建置 Restful API","name":"[IT] 使用 Clean Architecture \u002b DDD 建置 Restful API","description":"程式碼 https://github.com/intervalrain/webapi_ca/\n正文 建置 Solution 首先先參考 Clean Architecture 最經典的同心圓，來確定我們需要將我們的解決方案做哪些分層：\n我將使用 Restful API 做為我們 I/O (Presentation Layer) 並且我需要配備身份驗證的機制 (Presentation Layer) 我使用 PostgresDB 作為我的 (Infrastructure Layer) 我的核心商業邏輯 (Application / Domain Layer) 創建專案\ndotnet new sln -o Mysln 進入專案所在的資料夾 cd Mysln 根據預先的分層建立專案資料夾，並且使用 dotnet 指令建立相對應的專案類型。 Api \u0026ndash;\u0026gt; WebAPI Infrastructure \u0026ndash;\u0026gt; classlib Contracts \u0026ndash;\u0026gt; classlib Application \u0026ndash;\u0026gt; classlib Domain \u0026ndash;\u0026gt; classlib dotnet new webapi -o Mysln.Api dotnet new classlib -o Mysln.Contracts dotnet new classlib -o Mysln.Infrastructure dotnet new classlib -o Mysln.Application dotnet new classlib -o Mysln.Domain 接著我們需要把產生的專案資料夾，加入到我們的 Solution。 dotnet sln add Mysln.Api dotnet sln add Mysln.Application dotnet sln add Mysln.Contracts dotnet sln add Mysln.Domain dotnet sln add Mysln.Infrastructure 接下來按照 Clean Architecture 的依賴原則來設定 dependency，依我的專案來說依賴方向如下。 graph TD; Api--\u003eContracts; Api--\u003eApplication; Infrastructure--\u003eApplication Application--\u003eDomain Api-.-\u003eInfrastructure dotnet add Mysln.Api reference Mysln.Contracts Mysln.Application dotnet add Mysln.Infrastructure reference Mysln.Application dotnet add Mysln.Application reference Mysln.Domain dotnet add Mysln.Api reference Mysln.Infrastructure 至此，已經完成了基本的 hierarchy 建置，接下來要為 Restful Client 做準備。 Login Authentication 作為驗證的需要，我們需要以下三種驗證檔案，包含兩個 Request 與一個 Response public record RegisterRequest( string FirstName, string LastName, string Email, string Password ); public record LoginRequest( string Email, string Password ); public record AuthenticationResponse( Guid Id, string FirstName, string LastName, string Email, string token ); 到 Controller 去設置註冊與登入的兩個路由，並且將之後的服務介面預先注入到其中。 [ApiController] [Route(\u0026#34;auth\u0026#34;)] public class AuthenticationController : ControllerBase { [HttpPost(\u0026#34;register\u0026#34;)] public IActionResult Register(RegisterRequest request) { return Ok(request); } [HttpPost(\u0026#34;login\u0026#34;)] public IActionResult Login(LoginRequest request) { return Ok(request); } } 接著我們創建 Application 中的服務，注意到因為 Application 不依賴於 Contracts，故我們這邊需要創建自己的 DataModel public record AuthenticationResult ( Guid Id, string FirstName, string LastName, string Email, string Token ); 接著我們定義出 Application 的 Service。 public interface IAuthenticationService { AuthenticationResult Register(string firstName, string lastName, string email, string password); AuthenticationResult Login(string email, string password); } 定義好我們的 service interface 之後，就可以到 Presentation 中將我們的 service 注入到 presentation 之中。 [ApiController] [Route(\u0026#34;auth\u0026#34;)] public class AuthenticationController : ControllerBase { private readonly IAuthenticationService _authenticationService; public AuthenticationController(IAuthenticationService authenticationService) { _authenticationService = authenticationService; } [HttpPost(\u0026#34;register\u0026#34;)] public IActionResult Register(RegisterRequest request) { var authResult = _authenticationService.Register( request.FirstName, request.LastName, request.Email, request.Password); var response = new AuthenticationResponse( authResult.Id, authResult.FirstName, authResult.LastName, authResult.Email, authResult.Token); return Ok(response); } [HttpPost(\u0026#34;login\u0026#34;)] public IActionResult Login(LoginRequest request) { var authResult = _authenticationService.Login( request.Email, request.Password); var response = new AuthenticationResponse( authResult.Id, authResult.FirstName, authResult.LastName, authResult.Email, authResult.Token); return Ok(response); } } 我們已經定義好我們的 service 後，便可以到 presentation 的 Program(或是其它入口點，如 Startup.cs 或 MauiProgram.cs)，做 service 的依賴注入。 using BuberDinner.Application.Services.Authentication; var builder = WebApplication.CreateBuilder(args); { builder.Services.AddScoped\u0026lt;IAuthenticationService, AuthenticationService\u0026gt;(); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); } var app = builder.Build(); { app.UseSwagger(); app.UseSwaggerUI(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); } 最後，我們先實作一個暫時的 Service，來確認 Api 是可以作業的。 public class AuthenticationService : IAuthenticationService { public AuthenticationResult Register(string firstName, string lastName, string email, string password) { return new AuthenticationResult( Guid.NewGuid(), firstName, lastName, email, \u0026#34;token\u0026#34; ); } public AuthenticationResult Login(string email, string password) { return new AuthenticationResult( Guid.NewGuid(), \u0026#34;firstName\u0026#34;, \u0026#34;lastName\u0026#34;, email, \u0026#34;token\u0026#34; ); } } 執行 dotnet run --project .\\Mysln.Api\\ 在 Swagger 中測試我們實作的 register 與 login API，如果正常工作，會回傳 StatusCode: 200。 Dependency Injection 我們想要每一層都可以自己管理自己的注入，此時我們需要引入 Microsoft.Extensions.DependencyInjection。 接下來實作 Application 的 DependencyInjection。 public static class DependencyInjection { public static IServiceCollection AddApllication(this IServiceCollection services) { services.AddScope\u0026lt;IAuthenticationService, AuthenticationService\u0026gt;(); return services; } } 接下來實作 Infrastructure 的 DependencyInjection。(暫時還沒有注入 repository) public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services) { // 未來要注入 repositories return services; } } 接下來我們可以改寫 Program.cs。 using BuberDinner.Application; using BuberDinner.Infrastructure; var builder = WebApplication.CreateBuilder(args); { builder.Services .AddApplication() .AddInfrastructure(); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); } var app = builder.Build(); { app.UseSwagger(); app.UseSwaggerUI(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); } 實作 JWT Token Generator 首先先在 Application Layer 創建一個 interface 來做依賴反轉 public interface IJwtTokenGenerator { string GenerateToken(Guid userId, string firstName, string lastName); } 接著我們到 Infrastructure Layer 來實作我們的 JwtTokenGenerator。 首先我們需要 System.IdentityModel.Tokens.Jwt 這個 Package。 接著我們實作 JwtTokenGenerator。 public class JwtTokenGenerator : IJwtTokenGenerator { public string GenerateToken(Guid userId, string firstName, string lastName) { var signingCredentials = new SigningCredentials( new SymmetricSecurityKey( Encoding.UTF8.GetBytes(\u0026#34;super-secret-key\u0026#34;)), SecurityAlgorithms.HmacSha256); var claims = new[] { new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()), new Claim(JwtRegisteredClaimNames.GivenName, firstName), new Claim(JwtRegisteredClaimNames.FamilyName, lastName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }; var securityToken = new JwtSecurityToken( issuer: \u0026#34;Mysln\u0026#34;, expires: DateTime.Now.AddDays(1), claims: claims, signingCredentials: signingCredentials); return new JwtSecurityTokenHandler().WriteToken(securityToken); } } 接著我們將之注入到服務中，即大功告成了。 public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services) { services.AddSingleton\u0026lt;IJwtTokenGenerator, JwtTokenGenerator\u0026gt;(); return services; } } 使用 Options Pattern 注入 JWT Settings 接下來我們要使用 Options Pattern 將 JWT Settings 注入到 JwtTokenGenerator 中。 首先我們先到 Mysln.Api 的 appsettings.json 中將 options 設置完成。 { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;JwtSettings\u0026#34;: { \u0026#34;Secret\u0026#34;: \u0026#34;super-secret-key\u0026#34;, \u0026#34;ExpiryMinutes\u0026#34;: 60, \u0026#34;Issuer\u0026#34;: \u0026#34;Mysln\u0026#34;, \u0026#34;Audience:\u0026#34;: \u0026#34;Mysln\u0026#34; } } 由於我們要使用 Options Pattern，我們需要改寫我們的 Program.cs，並且將 ConfigurationManager 注入到 Infrastructure 的 DependencyInjection。 為此我們需要引入套件 Microsoft.Extensions.Configuration 與 Microsoft.Extensions.Options.ConfigurationExtensions。 並且我們需要創建一個 Model。 public class JwtSettings { public const string SectionName = \u0026#34;JwtSettings\u0026#34;; public string Secret { get; init; } = null!; public int ExpiryMinutes { get; init; } public string Issuer { get; init; } = null!; public string Audience { get; init; } = null!; } Program.cs 需改寫成： builder.Services .AddApplication() .AddInfrastructure(builder.Configuration); 將 DependencyInjection 改寫成： public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration) { services.Configure\u0026lt;JwtSettings\u0026gt;(configuration.GetSection(JwtSettings.SectionName)); services.AddSingleton\u0026lt;IJwtTokenGenerator, JwtTokenGenerator\u0026gt;(); services.AddSingleton\u0026lt;IDateTimeProvider, DateTimeProvider\u0026gt;(); return services; } } 接下來，我們可以把 JwtTokenGenerator 改寫成： public class JwtTokenGenerator : IJwtTokenGenerator { private readonly JwtSettings _jwtSettings; private readonly IDateTimeProvider _dateTimeProvider; public JwtTokenGenerator(IDateTimeProvider dateTimeProvider, IOptions\u0026lt;JwtSettings\u0026gt; jwtOptions) { _dateTimeProvider = dateTimeProvider; _jwtSettings = jwtOptions.Value; } public string GenerateToken(Guid userId, string firstName, string lastName) { var signingCredentials = new SigningCredentials( new SymmetricSecurityKey( Encoding.UTF8.GetBytes(_jwtSettings.Secret)), SecurityAlgorithms.HmacSha256); var claims = new[] { new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()), new Claim(JwtRegisteredClaimNames.GivenName, firstName), new Claim(JwtRegisteredClaimNames.FamilyName, lastName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }; var securityToken = new JwtSecurityToken( issuer: _jwtSettings.Issuer, audience: _jwtSettings.Audience, expires: _dateTimeProvider.UtcNow.AddMinutes(_jwtSettings.ExpiryMinutes), claims: claims, signingCredentials: signingCredentials); return new JwtSecurityTokenHandler().WriteToken(securityToken); } } 以上就大功告成了。 使用 dotnet user-secrets 指令 如果不想要將 Options 中的 secret 儲存在程式(appsettings.json)裡面，可以利用 dotnet user-secrets 將 secret 儲存於環境變數裡面。 透過執行以下的指令來初始化專案的 UserSecretsId dotnet user-secrets init --project Mysln.Api 接著將 UserSecretsId 綁定到我們專案的 JwtSettings:Secret。 dotnet user-secrets set --project Mysln.Api \u0026#34;JwtSettings:Secret\u0026#34; 日後可以經由以下指令查詢。 dotnet user-secrets list --project Mysln.Api Domain Model 先建立一個簡單的 Domain Model(Entity) public class User { public Guid Id { get; set; } = Guid.NewGuid(); public string FirstName { get; set; } = null!; public string LastName { get; set; } = null!; public string Email { get; set; } = null!; public string Password { get; set; } = null!; } Repository Pattern 在 Application Layer 建立 IRepository public interface IUserRepository { User? GetUserByEmail(string email); void Add(User user); } 將 IRepository 注入 Application 的 Service 並用查改存推改寫 Service public class AuthenticationService : IAuthenticationService { private readonly IJwtTokenGenerator _jwtTokenGenerator; private readonly IUserRepository _userRepository; public AuthenticationService(IJwtTokenGenerator jwtTokenGenerator, IUserRepository userRepository) { _jwtTokenGenerator = jwtTokenGenerator; _userRepository = userRepository; } public AuthenticationResult Register(string firstName, string lastName, string email, string password) { // 查 if (_userRepository.GetUserByEmail(email) is not null) { throw new Exception(\u0026#34;User with given email already exists.\u0026#34;); } // 改 var user = new User { FirstName = firstName, LastName = lastName, Email = email, Password = password }; // 存 _userRepository.Add(user); // 推 var token = _jwtTokenGenerator.GenerateToken(user.Id, firstName, lastName); return new AuthenticationResult(user.Id, firstName, lastName, email, token); } public AuthenticationResult Login(string email, string password) { // 查 if (_userRepository.GetUserByEmail(email) is not User user) { throw new Exception(\u0026#34;User with given email does not exist.\u0026#34;); } if (user.Password != password) { throw new Exception(\u0026#34;Invalid password.\u0026#34;); } // 改 var token = _jwtTokenGenerator.GenerateToken(user.Id, user.FirstName, user.LastName); return new AuthenticationResult(user.Id, user.FirstName, user.LastName, email, token); } } 接著我們在 Infrastructure Layer 實作我們的 repository，我們暫時先不接資料庫，所以先做一個 InMemory 版本的 repository 來做測試。 public class UserRepository : IUserRepository { private readonly List\u0026lt;User\u0026gt; _users = new(); public void Add(User user) { _users.Add(user); } public User? GetUserByEmail(string email) { return _users.SingleOrDefault(u =\u0026gt; u.Email.Equals(email)); } } 實作完需要透過 DependencyInjection 注入到我們的 Service Container 內。 public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration) { services.Configure\u0026lt;JwtSettings\u0026gt;(configuration.GetSection(JwtSettings.SectionName)); services.AddSingleton\u0026lt;IJwtTokenGenerator, JwtTokenGenerator\u0026gt;(); services.AddSingleton\u0026lt;IDateTimeProvider, DateTimeProvider\u0026gt;(); services.AddSingleton\u0026lt;IUserRepository, UserRepository\u0026gt;(); return services; } } 至此，我們已經完成了一個簡單的身份認證的 API。 ","keywords":["IT","C#","Clean Architecture"],"articleBody":"程式碼 https://github.com/intervalrain/webapi_ca/\n正文 建置 Solution 首先先參考 Clean Architecture 最經典的同心圓，來確定我們需要將我們的解決方案做哪些分層：\n我將使用 Restful API 做為我們 I/O (Presentation Layer) 並且我需要配備身份驗證的機制 (Presentation Layer) 我使用 PostgresDB 作為我的 (Infrastructure Layer) 我的核心商業邏輯 (Application / Domain Layer) 創建專案\ndotnet new sln -o Mysln 進入專案所在的資料夾 cd Mysln 根據預先的分層建立專案資料夾，並且使用 dotnet 指令建立相對應的專案類型。 Api –\u003e WebAPI Infrastructure –\u003e classlib Contracts –\u003e classlib Application –\u003e classlib Domain –\u003e classlib dotnet new webapi -o Mysln.Api dotnet new classlib -o Mysln.Contracts dotnet new classlib -o Mysln.Infrastructure dotnet new classlib -o Mysln.Application dotnet new classlib -o Mysln.Domain 接著我們需要把產生的專案資料夾，加入到我們的 Solution。 dotnet sln add Mysln.Api dotnet sln add Mysln.Application dotnet sln add Mysln.Contracts dotnet sln add Mysln.Domain dotnet sln add Mysln.Infrastructure 接下來按照 Clean Architecture 的依賴原則來設定 dependency，依我的專案來說依賴方向如下。 graph TD; Api--\u003eContracts; Api--\u003eApplication; Infrastructure--\u003eApplication Application--\u003eDomain Api-.-\u003eInfrastructure dotnet add Mysln.Api reference Mysln.Contracts Mysln.Application dotnet add Mysln.Infrastructure reference Mysln.Application dotnet add Mysln.Application reference Mysln.Domain dotnet add Mysln.Api reference Mysln.Infrastructure 至此，已經完成了基本的 hierarchy 建置，接下來要為 Restful Client 做準備。 Login Authentication 作為驗證的需要，我們需要以下三種驗證檔案，包含兩個 Request 與一個 Response public record RegisterRequest( string FirstName, string LastName, string Email, string Password ); public record LoginRequest( string Email, string Password ); public record AuthenticationResponse( Guid Id, string FirstName, string LastName, string Email, string token ); 到 Controller 去設置註冊與登入的兩個路由，並且將之後的服務介面預先注入到其中。 [ApiController] [Route(\"auth\")] public class AuthenticationController : ControllerBase { [HttpPost(\"register\")] public IActionResult Register(RegisterRequest request) { return Ok(request); } [HttpPost(\"login\")] public IActionResult Login(LoginRequest request) { return Ok(request); } } 接著我們創建 Application 中的服務，注意到因為 Application 不依賴於 Contracts，故我們這邊需要創建自己的 DataModel public record AuthenticationResult ( Guid Id, string FirstName, string LastName, string Email, string Token ); 接著我們定義出 Application 的 Service。 public interface IAuthenticationService { AuthenticationResult Register(string firstName, string lastName, string email, string password); AuthenticationResult Login(string email, string password); } 定義好我們的 service interface 之後，就可以到 Presentation 中將我們的 service 注入到 presentation 之中。 [ApiController] [Route(\"auth\")] public class AuthenticationController : ControllerBase { private readonly IAuthenticationService _authenticationService; public AuthenticationController(IAuthenticationService authenticationService) { _authenticationService = authenticationService; } [HttpPost(\"register\")] public IActionResult Register(RegisterRequest request) { var authResult = _authenticationService.Register( request.FirstName, request.LastName, request.Email, request.Password); var response = new AuthenticationResponse( authResult.Id, authResult.FirstName, authResult.LastName, authResult.Email, authResult.Token); return Ok(response); } [HttpPost(\"login\")] public IActionResult Login(LoginRequest request) { var authResult = _authenticationService.Login( request.Email, request.Password); var response = new AuthenticationResponse( authResult.Id, authResult.FirstName, authResult.LastName, authResult.Email, authResult.Token); return Ok(response); } } 我們已經定義好我們的 service 後，便可以到 presentation 的 Program(或是其它入口點，如 Startup.cs 或 MauiProgram.cs)，做 service 的依賴注入。 using BuberDinner.Application.Services.Authentication; var builder = WebApplication.CreateBuilder(args); { builder.Services.AddScoped(); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); } var app = builder.Build(); { app.UseSwagger(); app.UseSwaggerUI(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); } 最後，我們先實作一個暫時的 Service，來確認 Api 是可以作業的。 public class AuthenticationService : IAuthenticationService { public AuthenticationResult Register(string firstName, string lastName, string email, string password) { return new AuthenticationResult( Guid.NewGuid(), firstName, lastName, email, \"token\" ); } public AuthenticationResult Login(string email, string password) { return new AuthenticationResult( Guid.NewGuid(), \"firstName\", \"lastName\", email, \"token\" ); } } 執行 dotnet run --project .\\Mysln.Api\\ 在 Swagger 中測試我們實作的 register 與 login API，如果正常工作，會回傳 StatusCode: 200。 Dependency Injection 我們想要每一層都可以自己管理自己的注入，此時我們需要引入 Microsoft.Extensions.DependencyInjection。 接下來實作 Application 的 DependencyInjection。 public static class DependencyInjection { public static IServiceCollection AddApllication(this IServiceCollection services) { services.AddScope(); return services; } } 接下來實作 Infrastructure 的 DependencyInjection。(暫時還沒有注入 repository) public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services) { // 未來要注入 repositories return services; } } 接下來我們可以改寫 Program.cs。 using BuberDinner.Application; using BuberDinner.Infrastructure; var builder = WebApplication.CreateBuilder(args); { builder.Services .AddApplication() .AddInfrastructure(); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); } var app = builder.Build(); { app.UseSwagger(); app.UseSwaggerUI(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); } 實作 JWT Token Generator 首先先在 Application Layer 創建一個 interface 來做依賴反轉 public interface IJwtTokenGenerator { string GenerateToken(Guid userId, string firstName, string lastName); } 接著我們到 Infrastructure Layer 來實作我們的 JwtTokenGenerator。 首先我們需要 System.IdentityModel.Tokens.Jwt 這個 Package。 接著我們實作 JwtTokenGenerator。 public class JwtTokenGenerator : IJwtTokenGenerator { public string GenerateToken(Guid userId, string firstName, string lastName) { var signingCredentials = new SigningCredentials( new SymmetricSecurityKey( Encoding.UTF8.GetBytes(\"super-secret-key\")), SecurityAlgorithms.HmacSha256); var claims = new[] { new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()), new Claim(JwtRegisteredClaimNames.GivenName, firstName), new Claim(JwtRegisteredClaimNames.FamilyName, lastName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }; var securityToken = new JwtSecurityToken( issuer: \"Mysln\", expires: DateTime.Now.AddDays(1), claims: claims, signingCredentials: signingCredentials); return new JwtSecurityTokenHandler().WriteToken(securityToken); } } 接著我們將之注入到服務中，即大功告成了。 public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services) { services.AddSingleton(); return services; } } 使用 Options Pattern 注入 JWT Settings 接下來我們要使用 Options Pattern 將 JWT Settings 注入到 JwtTokenGenerator 中。 首先我們先到 Mysln.Api 的 appsettings.json 中將 options 設置完成。 { \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft.AspNetCore\": \"Warning\" } }, \"AllowedHosts\": \"*\", \"JwtSettings\": { \"Secret\": \"super-secret-key\", \"ExpiryMinutes\": 60, \"Issuer\": \"Mysln\", \"Audience:\": \"Mysln\" } } 由於我們要使用 Options Pattern，我們需要改寫我們的 Program.cs，並且將 ConfigurationManager 注入到 Infrastructure 的 DependencyInjection。 為此我們需要引入套件 Microsoft.Extensions.Configuration 與 Microsoft.Extensions.Options.ConfigurationExtensions。 並且我們需要創建一個 Model。 public class JwtSettings { public const string SectionName = \"JwtSettings\"; public string Secret { get; init; } = null!; public int ExpiryMinutes { get; init; } public string Issuer { get; init; } = null!; public string Audience { get; init; } = null!; } Program.cs 需改寫成： builder.Services .AddApplication() .AddInfrastructure(builder.Configuration); 將 DependencyInjection 改寫成： public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration) { services.Configure(configuration.GetSection(JwtSettings.SectionName)); services.AddSingleton(); services.AddSingleton(); return services; } } 接下來，我們可以把 JwtTokenGenerator 改寫成： public class JwtTokenGenerator : IJwtTokenGenerator { private readonly JwtSettings _jwtSettings; private readonly IDateTimeProvider _dateTimeProvider; public JwtTokenGenerator(IDateTimeProvider dateTimeProvider, IOptions jwtOptions) { _dateTimeProvider = dateTimeProvider; _jwtSettings = jwtOptions.Value; } public string GenerateToken(Guid userId, string firstName, string lastName) { var signingCredentials = new SigningCredentials( new SymmetricSecurityKey( Encoding.UTF8.GetBytes(_jwtSettings.Secret)), SecurityAlgorithms.HmacSha256); var claims = new[] { new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()), new Claim(JwtRegisteredClaimNames.GivenName, firstName), new Claim(JwtRegisteredClaimNames.FamilyName, lastName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }; var securityToken = new JwtSecurityToken( issuer: _jwtSettings.Issuer, audience: _jwtSettings.Audience, expires: _dateTimeProvider.UtcNow.AddMinutes(_jwtSettings.ExpiryMinutes), claims: claims, signingCredentials: signingCredentials); return new JwtSecurityTokenHandler().WriteToken(securityToken); } } 以上就大功告成了。 使用 dotnet user-secrets 指令 如果不想要將 Options 中的 secret 儲存在程式(appsettings.json)裡面，可以利用 dotnet user-secrets 將 secret 儲存於環境變數裡面。 透過執行以下的指令來初始化專案的 UserSecretsId dotnet user-secrets init --project Mysln.Api 接著將 UserSecretsId 綁定到我們專案的 JwtSettings:Secret。 dotnet user-secrets set --project Mysln.Api \"JwtSettings:Secret\" 日後可以經由以下指令查詢。 dotnet user-secrets list --project Mysln.Api Domain Model 先建立一個簡單的 Domain Model(Entity) public class User { public Guid Id { get; set; } = Guid.NewGuid(); public string FirstName { get; set; } = null!; public string LastName { get; set; } = null!; public string Email { get; set; } = null!; public string Password { get; set; } = null!; } Repository Pattern 在 Application Layer 建立 IRepository public interface IUserRepository { User? GetUserByEmail(string email); void Add(User user); } 將 IRepository 注入 Application 的 Service 並用查改存推改寫 Service public class AuthenticationService : IAuthenticationService { private readonly IJwtTokenGenerator _jwtTokenGenerator; private readonly IUserRepository _userRepository; public AuthenticationService(IJwtTokenGenerator jwtTokenGenerator, IUserRepository userRepository) { _jwtTokenGenerator = jwtTokenGenerator; _userRepository = userRepository; } public AuthenticationResult Register(string firstName, string lastName, string email, string password) { // 查 if (_userRepository.GetUserByEmail(email) is not null) { throw new Exception(\"User with given email already exists.\"); } // 改 var user = new User { FirstName = firstName, LastName = lastName, Email = email, Password = password }; // 存 _userRepository.Add(user); // 推 var token = _jwtTokenGenerator.GenerateToken(user.Id, firstName, lastName); return new AuthenticationResult(user.Id, firstName, lastName, email, token); } public AuthenticationResult Login(string email, string password) { // 查 if (_userRepository.GetUserByEmail(email) is not User user) { throw new Exception(\"User with given email does not exist.\"); } if (user.Password != password) { throw new Exception(\"Invalid password.\"); } // 改 var token = _jwtTokenGenerator.GenerateToken(user.Id, user.FirstName, user.LastName); return new AuthenticationResult(user.Id, user.FirstName, user.LastName, email, token); } } 接著我們在 Infrastructure Layer 實作我們的 repository，我們暫時先不接資料庫，所以先做一個 InMemory 版本的 repository 來做測試。 public class UserRepository : IUserRepository { private readonly List _users = new(); public void Add(User user) { _users.Add(user); } public User? GetUserByEmail(string email) { return _users.SingleOrDefault(u =\u003e u.Email.Equals(email)); } } 實作完需要透過 DependencyInjection 注入到我們的 Service Container 內。 public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration) { services.Configure(configuration.GetSection(JwtSettings.SectionName)); services.AddSingleton(); services.AddSingleton(); services.AddSingleton(); return services; } } 至此，我們已經完成了一個簡單的身份認證的 API。 ","wordCount":"1192","inLanguage":"zh-tw","datePublished":"2024-02-26T15:03:15+08:00","dateModified":"2024-02-26T15:03:15+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/it/clean_arch_configuration/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/it/>ITs</a></div><h1 class="post-title entry-hint-parent">[IT] 使用 Clean Architecture + DDD 建置 Restful API</h1><div class=post-meta><span title='2024-02-26 15:03:15 +0800 +0800'>February 26, 2024</span>&nbsp;·&nbsp;6 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//IT/Clean_Arch_Configuration.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e7%a8%8b%e5%bc%8f%e7%a2%bc aria-label=程式碼>程式碼</a></li><li><a href=#%e6%ad%a3%e6%96%87 aria-label=正文>正文</a><ul><li><a href=#%e5%bb%ba%e7%bd%ae-solution aria-label="建置 Solution">建置 Solution</a></li><li><a href=#login-authentication aria-label="Login Authentication">Login Authentication</a></li><li><a href=#dependency-injection aria-label="Dependency Injection">Dependency Injection</a></li><li><a href=#%e5%af%a6%e4%bd%9c-jwt-token-generator aria-label="實作 JWT Token Generator">實作 JWT Token Generator</a></li><li><a href=#%e4%bd%bf%e7%94%a8-options-pattern-%e6%b3%a8%e5%85%a5-jwt-settings aria-label="使用 Options Pattern 注入 JWT Settings">使用 Options Pattern 注入 JWT Settings</a></li><li><a href=#%e4%bd%bf%e7%94%a8-dotnet-user-secrets-%e6%8c%87%e4%bb%a4 aria-label="使用 dotnet user-secrets 指令">使用 <code>dotnet user-secrets</code> 指令</a></li><li><a href=#domain-model aria-label="Domain Model">Domain Model</a></li><li><a href=#repository-pattern aria-label="Repository Pattern">Repository Pattern</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=程式碼>程式碼<a hidden class=anchor aria-hidden=true href=#程式碼>#</a></h1><p><a href=https://github.com/intervalrain/webapi_ca/>https://github.com/intervalrain/webapi_ca/</a></p><h1 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h1><h2 id=建置-solution>建置 Solution<a hidden class=anchor aria-hidden=true href=#建置-solution>#</a></h2><ul><li><p>首先先參考 Clean Architecture 最經典的同心圓，來確定我們需要將我們的解決方案做哪些分層：</p><ul><li>我將使用 Restful API 做為我們 I/O (Presentation Layer)</li><li>並且我需要配備身份驗證的機制 (Presentation Layer)</li><li>我使用 PostgresDB 作為我的 (Infrastructure Layer)</li><li>我的核心商業邏輯 (Application / Domain Layer)
<img src=https://herbertograca.files.wordpress.com/2017/04/cleanarchitecture-5c6d7ec787d447a81b708b73abba1680.jpg width=480></li></ul></li><li><p>創建專案</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>sln</span> -<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Mysln</span>
</span></span></code></pre></div><ul><li>進入專案所在的資料夾</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=display:flex><span><span style=color:#a6e22e>cd</span> <span style=color:#a6e22e>Mysln</span>
</span></span></code></pre></div><ul><li>根據預先的分層建立專案資料夾，並且使用 dotnet 指令建立相對應的專案類型。<ul><li>Api &ndash;> WebAPI</li><li>Infrastructure &ndash;> classlib</li><li>Contracts &ndash;> classlib</li><li>Application &ndash;> classlib</li><li>Domain &ndash;> classlib</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>webapi</span> -<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Api</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>classlib</span> -<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Contracts</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>classlib</span> -<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Infrastructure</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>classlib</span> -<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Application</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>classlib</span> -<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Domain</span>
</span></span></code></pre></div><ul><li>接著我們需要把產生的專案資料夾，加入到我們的 Solution。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>sln</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Api</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>sln</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Application</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>sln</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Contracts</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>sln</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Domain</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>sln</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Infrastructure</span>
</span></span></code></pre></div><ul><li>接下來按照 Clean Architecture 的依賴原則來設定 dependency，依我的專案來說依賴方向如下。<div class=mermaid>graph TD;
Api-->Contracts;
Api-->Application;
Infrastructure-->Application
Application-->Domain
Api-.->Infrastructure</div></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Api</span> <span style=color:#a6e22e>reference</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Contracts</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Application</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Infrastructure</span> <span style=color:#a6e22e>reference</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Application</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Application</span> <span style=color:#a6e22e>reference</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Domain</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>add</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Api</span> <span style=color:#a6e22e>reference</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Infrastructure</span>
</span></span></code></pre></div><ul><li>至此，已經完成了基本的 hierarchy 建置，接下來要為 Restful Client 做準備。</li></ul><h2 id=login-authentication>Login Authentication<a hidden class=anchor aria-hidden=true href=#login-authentication>#</a></h2><ul><li>作為驗證的需要，我們需要以下三種驗證檔案，包含兩個 Request 與一個 Response</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>RegisterRequest</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> FirstName,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> LastName,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> Email,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> Password
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>LoginRequest</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> Email,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> Password
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>AuthenticationResponse</span>(
</span></span><span style=display:flex><span>    Guid Id,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> FirstName,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> LastName,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> Email,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> token
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><ul><li>到 Controller 去設置註冊與登入的兩個路由，並且將之後的服務介面預先注入到其中。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[ApiController]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[Route(&#34;auth&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthenticationController</span> : ControllerBase
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>	[HttpPost(&#34;register&#34;)]</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IActionResult Register(RegisterRequest request)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> Ok(request);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>	[HttpPost(&#34;login&#34;)]</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IActionResult Login(LoginRequest request)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> Ok(request);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>接著我們創建 Application 中的服務，注意到因為 Application 不依賴於 Contracts，故我們這邊需要創建自己的 DataModel</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>record</span> <span style=color:#a6e22e>AuthenticationResult</span>
</span></span><span style=display:flex><span>(
</span></span><span style=display:flex><span>    Guid Id,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> FirstName,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> LastName,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> Email,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> Token
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><ul><li>接著我們定義出 Application 的 Service。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IAuthenticationService</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	AuthenticationResult Register(<span style=color:#66d9ef>string</span> firstName, <span style=color:#66d9ef>string</span> lastName, <span style=color:#66d9ef>string</span> email, <span style=color:#66d9ef>string</span> password);
</span></span><span style=display:flex><span>    AuthenticationResult Login(<span style=color:#66d9ef>string</span> email, <span style=color:#66d9ef>string</span> password);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>定義好我們的 service interface 之後，就可以到 Presentation 中將我們的 service 注入到 presentation 之中。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[ApiController]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[Route(&#34;auth&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthenticationController</span> : ControllerBase
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IAuthenticationService _authenticationService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AuthenticationController(IAuthenticationService authenticationService)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _authenticationService = authenticationService;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [HttpPost(&#34;register&#34;)]</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IActionResult Register(RegisterRequest request)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> authResult = _authenticationService.Register(
</span></span><span style=display:flex><span>			request.FirstName,
</span></span><span style=display:flex><span>			request.LastName,
</span></span><span style=display:flex><span>			request.Email,
</span></span><span style=display:flex><span>			request.Password);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>new</span> AuthenticationResponse(
</span></span><span style=display:flex><span>            authResult.Id,
</span></span><span style=display:flex><span>            authResult.FirstName,
</span></span><span style=display:flex><span>            authResult.LastName,
</span></span><span style=display:flex><span>            authResult.Email,
</span></span><span style=display:flex><span>            authResult.Token);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> Ok(response);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>	[HttpPost(&#34;login&#34;)]</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IActionResult Login(LoginRequest request)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> authResult = _authenticationService.Login(
</span></span><span style=display:flex><span>            request.Email,
</span></span><span style=display:flex><span>            request.Password);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>new</span> AuthenticationResponse(
</span></span><span style=display:flex><span>            authResult.Id,
</span></span><span style=display:flex><span>            authResult.FirstName,
</span></span><span style=display:flex><span>            authResult.LastName,
</span></span><span style=display:flex><span>            authResult.Email,
</span></span><span style=display:flex><span>            authResult.Token);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Ok(response);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>我們已經定義好我們的 service 後，便可以到 presentation 的 Program(或是其它入口點，如 Startup.cs 或 MauiProgram.cs)，做 service 的依賴注入。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> BuberDinner.Application.Services.Authentication;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder(args);
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    builder.Services.AddScoped&lt;IAuthenticationService, AuthenticationService&gt;();
</span></span><span style=display:flex><span>    builder.Services.AddControllers();
</span></span><span style=display:flex><span>    builder.Services.AddEndpointsApiExplorer();
</span></span><span style=display:flex><span>    builder.Services.AddSwaggerGen();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    app.UseSwagger();
</span></span><span style=display:flex><span>    app.UseSwaggerUI();
</span></span><span style=display:flex><span>    app.UseHttpsRedirection();
</span></span><span style=display:flex><span>    app.MapControllers();
</span></span><span style=display:flex><span>    app.Run();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>最後，我們先實作一個暫時的 Service，來確認 Api 是可以作業的。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthenticationService</span> : IAuthenticationService
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AuthenticationResult Register(<span style=color:#66d9ef>string</span> firstName, <span style=color:#66d9ef>string</span> lastName, <span style=color:#66d9ef>string</span> email, <span style=color:#66d9ef>string</span> password)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AuthenticationResult(
</span></span><span style=display:flex><span>            Guid.NewGuid(),
</span></span><span style=display:flex><span>            firstName,
</span></span><span style=display:flex><span>            lastName,
</span></span><span style=display:flex><span>            email,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;token&#34;</span>
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AuthenticationResult Login(<span style=color:#66d9ef>string</span> email, <span style=color:#66d9ef>string</span> password)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AuthenticationResult(
</span></span><span style=display:flex><span>            Guid.NewGuid(),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;firstName&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;lastName&#34;</span>,
</span></span><span style=display:flex><span>            email,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;token&#34;</span>
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>執行 <code>dotnet run --project .\Mysln.Api\</code></li><li>在 Swagger 中測試我們實作的 <code>register</code> 與 <code>login</code> API，如果正常工作，會回傳 StatusCode: 200。</li></ul><h2 id=dependency-injection>Dependency Injection<a hidden class=anchor aria-hidden=true href=#dependency-injection>#</a></h2><ul><li>我們想要每一層都可以自己管理自己的注入，此時我們需要引入 <code>Microsoft.Extensions.DependencyInjection</code>。</li><li>接下來實作 Application 的 DependencyInjection。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DependencyInjection</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IServiceCollection AddApllication(<span style=color:#66d9ef>this</span> IServiceCollection services)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        services.AddScope&lt;IAuthenticationService, AuthenticationService&gt;();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> services;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>接下來實作 Infrastructure 的 DependencyInjection。(暫時還沒有注入 repository)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DependencyInjection</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IServiceCollection AddInfrastructure(<span style=color:#66d9ef>this</span> IServiceCollection services)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 未來要注入 repositories</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> services;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>接下來我們可以改寫 <code>Program.cs</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> BuberDinner.Application;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> BuberDinner.Infrastructure;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> builder = WebApplication.CreateBuilder(args);
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    builder.Services
</span></span><span style=display:flex><span>        .AddApplication()
</span></span><span style=display:flex><span>        .AddInfrastructure();
</span></span><span style=display:flex><span>    builder.Services.AddControllers();
</span></span><span style=display:flex><span>    builder.Services.AddEndpointsApiExplorer();
</span></span><span style=display:flex><span>    builder.Services.AddSwaggerGen();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> app = builder.Build();
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    app.UseSwagger();
</span></span><span style=display:flex><span>    app.UseSwaggerUI();
</span></span><span style=display:flex><span>    app.UseHttpsRedirection();
</span></span><span style=display:flex><span>    app.MapControllers();
</span></span><span style=display:flex><span>    app.Run();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=實作-jwt-token-generator>實作 JWT Token Generator<a hidden class=anchor aria-hidden=true href=#實作-jwt-token-generator>#</a></h2><ul><li>首先先在 Application Layer 創建一個 interface 來做依賴反轉</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IJwtTokenGenerator</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> GenerateToken(Guid userId, <span style=color:#66d9ef>string</span> firstName, <span style=color:#66d9ef>string</span> lastName);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>接著我們到 Infrastructure Layer 來實作我們的 JwtTokenGenerator。</li><li>首先我們需要 <code>System.IdentityModel.Tokens.Jwt</code> 這個 Package。</li><li>接著我們實作 <code>JwtTokenGenerator</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JwtTokenGenerator</span> : IJwtTokenGenerator
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> GenerateToken(Guid userId, <span style=color:#66d9ef>string</span> firstName, <span style=color:#66d9ef>string</span> lastName)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> signingCredentials = <span style=color:#66d9ef>new</span> SigningCredentials(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> SymmetricSecurityKey(
</span></span><span style=display:flex><span>                Encoding.UTF8.GetBytes(<span style=color:#e6db74>&#34;super-secret-key&#34;</span>)),
</span></span><span style=display:flex><span>            SecurityAlgorithms.HmacSha256);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> claims = <span style=color:#66d9ef>new</span>[]
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(JwtRegisteredClaimNames.Sub, userId.ToString()),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(JwtRegisteredClaimNames.GivenName, firstName),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(JwtRegisteredClaimNames.FamilyName, lastName),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> securityToken = <span style=color:#66d9ef>new</span> JwtSecurityToken(
</span></span><span style=display:flex><span>            issuer: <span style=color:#e6db74>&#34;Mysln&#34;</span>,
</span></span><span style=display:flex><span>            expires: DateTime.Now.AddDays(<span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            claims: claims,
</span></span><span style=display:flex><span>            signingCredentials: signingCredentials);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JwtSecurityTokenHandler().WriteToken(securityToken);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>接著我們將之注入到服務中，即大功告成了。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DependencyInjection</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IServiceCollection AddInfrastructure(<span style=color:#66d9ef>this</span> IServiceCollection services)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        services.AddSingleton&lt;IJwtTokenGenerator, JwtTokenGenerator&gt;();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> services;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=使用-options-pattern-注入-jwt-settings>使用 Options Pattern 注入 JWT Settings<a hidden class=anchor aria-hidden=true href=#使用-options-pattern-注入-jwt-settings>#</a></h2><ul><li>接下來我們要使用 Options Pattern 將 JWT Settings 注入到 JwtTokenGenerator 中。</li><li>首先我們先到 <code>Mysln.Api</code> 的 <code>appsettings.json</code> 中將 options 設置完成。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;Logging&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;LogLevel&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;Default&#34;</span>: <span style=color:#e6db74>&#34;Information&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;Microsoft.AspNetCore&#34;</span>: <span style=color:#e6db74>&#34;Warning&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;AllowedHosts&#34;</span>: <span style=color:#e6db74>&#34;*&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;JwtSettings&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;Secret&#34;</span>: <span style=color:#e6db74>&#34;super-secret-key&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;ExpiryMinutes&#34;</span>: <span style=color:#ae81ff>60</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;Issuer&#34;</span>: <span style=color:#e6db74>&#34;Mysln&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;Audience:&#34;</span>: <span style=color:#e6db74>&#34;Mysln&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>由於我們要使用 Options Pattern，我們需要改寫我們的 <code>Program.cs</code>，並且將 ConfigurationManager 注入到 Infrastructure 的 DependencyInjection。</li><li>為此我們需要引入套件 <code>Microsoft.Extensions.Configuration</code> 與 <code>Microsoft.Extensions.Options.ConfigurationExtensions</code>。</li><li>並且我們需要創建一個 Model。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JwtSettings</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> SectionName = <span style=color:#e6db74>&#34;JwtSettings&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Secret { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; } = <span style=color:#66d9ef>null</span>!;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> ExpiryMinutes { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Issuer { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; } = <span style=color:#66d9ef>null</span>!;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Audience { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>init</span>; } = <span style=color:#66d9ef>null</span>!;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>Program.cs</code> 需改寫成：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>builder.Services
</span></span><span style=display:flex><span>        .AddApplication()
</span></span><span style=display:flex><span>        .AddInfrastructure(builder.Configuration);
</span></span></code></pre></div><ul><li>將 <code>DependencyInjection</code> 改寫成：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DependencyInjection</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IServiceCollection AddInfrastructure(<span style=color:#66d9ef>this</span> IServiceCollection services, ConfigurationManager configuration)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        services.Configure&lt;JwtSettings&gt;(configuration.GetSection(JwtSettings.SectionName));
</span></span><span style=display:flex><span>        services.AddSingleton&lt;IJwtTokenGenerator, JwtTokenGenerator&gt;();
</span></span><span style=display:flex><span>        services.AddSingleton&lt;IDateTimeProvider, DateTimeProvider&gt;();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> services;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>接下來，我們可以把 JwtTokenGenerator 改寫成：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JwtTokenGenerator</span> : IJwtTokenGenerator
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> JwtSettings _jwtSettings;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IDateTimeProvider _dateTimeProvider;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> JwtTokenGenerator(IDateTimeProvider dateTimeProvider, IOptions&lt;JwtSettings&gt; jwtOptions)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _dateTimeProvider = dateTimeProvider;
</span></span><span style=display:flex><span>        _jwtSettings = jwtOptions.Value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> GenerateToken(Guid userId, <span style=color:#66d9ef>string</span> firstName, <span style=color:#66d9ef>string</span> lastName)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> signingCredentials = <span style=color:#66d9ef>new</span> SigningCredentials(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> SymmetricSecurityKey(
</span></span><span style=display:flex><span>                Encoding.UTF8.GetBytes(_jwtSettings.Secret)),
</span></span><span style=display:flex><span>            SecurityAlgorithms.HmacSha256);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> claims = <span style=color:#66d9ef>new</span>[]
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(JwtRegisteredClaimNames.Sub, userId.ToString()),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(JwtRegisteredClaimNames.GivenName, firstName),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(JwtRegisteredClaimNames.FamilyName, lastName),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> securityToken = <span style=color:#66d9ef>new</span> JwtSecurityToken(
</span></span><span style=display:flex><span>            issuer: _jwtSettings.Issuer,
</span></span><span style=display:flex><span>            audience: _jwtSettings.Audience,
</span></span><span style=display:flex><span>            expires: _dateTimeProvider.UtcNow.AddMinutes(_jwtSettings.ExpiryMinutes),
</span></span><span style=display:flex><span>            claims: claims,
</span></span><span style=display:flex><span>            signingCredentials: signingCredentials);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JwtSecurityTokenHandler().WriteToken(securityToken);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>以上就大功告成了。</li></ul><h2 id=使用-dotnet-user-secrets-指令>使用 <code>dotnet user-secrets</code> 指令<a hidden class=anchor aria-hidden=true href=#使用-dotnet-user-secrets-指令>#</a></h2><ul><li>如果不想要將 Options 中的 secret 儲存在程式(appsettings.json)裡面，可以利用 <code>dotnet user-secrets</code> 將 secret 儲存於環境變數裡面。</li><li>透過執行以下的指令來初始化專案的 <code>UserSecretsId</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>user</span>-<span style=color:#a6e22e>secrets</span> <span style=color:#a6e22e>init</span> --<span style=color:#a6e22e>project</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Api</span>
</span></span></code></pre></div><ul><li>接著將 <code>UserSecretsId</code> 綁定到我們專案的 <code>JwtSettings:Secret</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>user</span>-<span style=color:#a6e22e>secrets</span> <span style=color:#66d9ef>set</span> --<span style=color:#a6e22e>project</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Api</span> <span style=color:#e6db74>&#34;JwtSettings:Secret&#34;</span>
</span></span></code></pre></div><ul><li>日後可以經由以下指令查詢。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vim data-lang=vim><span style=display:flex><span><span style=color:#a6e22e>dotnet</span> <span style=color:#a6e22e>user</span>-<span style=color:#a6e22e>secrets</span> <span style=color:#a6e22e>list</span> --<span style=color:#a6e22e>project</span> <span style=color:#a6e22e>Mysln</span>.<span style=color:#a6e22e>Api</span>
</span></span></code></pre></div><h2 id=domain-model>Domain Model<a hidden class=anchor aria-hidden=true href=#domain-model>#</a></h2><ul><li>先建立一個簡單的 Domain Model(Entity)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Guid Id { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = Guid.NewGuid();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> FirstName { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#66d9ef>null</span>!;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> LastName { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#66d9ef>null</span>!;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Email { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#66d9ef>null</span>!;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Password { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; } = <span style=color:#66d9ef>null</span>!;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=repository-pattern>Repository Pattern<a hidden class=anchor aria-hidden=true href=#repository-pattern>#</a></h2><ul><li>在 Application Layer 建立 IRepository</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IUserRepository</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    User? GetUserByEmail(<span style=color:#66d9ef>string</span> email);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Add(User user);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>將 IRepository 注入 Application 的 Service</li><li>並用查改存推改寫 Service</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthenticationService</span> : IAuthenticationService
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IJwtTokenGenerator _jwtTokenGenerator;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IUserRepository _userRepository;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AuthenticationService(IJwtTokenGenerator jwtTokenGenerator, IUserRepository userRepository)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _jwtTokenGenerator = jwtTokenGenerator;
</span></span><span style=display:flex><span>        _userRepository = userRepository;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AuthenticationResult Register(<span style=color:#66d9ef>string</span> firstName, <span style=color:#66d9ef>string</span> lastName, <span style=color:#66d9ef>string</span> email, <span style=color:#66d9ef>string</span> password)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_userRepository.GetUserByEmail(email) <span style=color:#66d9ef>is</span> not <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;User with given email already exists.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 改</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> user = <span style=color:#66d9ef>new</span> User
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            FirstName = firstName,
</span></span><span style=display:flex><span>            LastName = lastName,
</span></span><span style=display:flex><span>            Email = email,
</span></span><span style=display:flex><span>            Password = password
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 存</span>
</span></span><span style=display:flex><span>        _userRepository.Add(user);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 推</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> token = _jwtTokenGenerator.GenerateToken(user.Id, firstName, lastName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AuthenticationResult(user.Id, firstName, lastName, email, token);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AuthenticationResult Login(<span style=color:#66d9ef>string</span> email, <span style=color:#66d9ef>string</span> password)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_userRepository.GetUserByEmail(email) <span style=color:#66d9ef>is</span> not User user)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;User with given email does not exist.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (user.Password != password)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Exception(<span style=color:#e6db74>&#34;Invalid password.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 改</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> token = _jwtTokenGenerator.GenerateToken(user.Id, user.FirstName, user.LastName);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AuthenticationResult(user.Id, user.FirstName, user.LastName, email, token);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>接著我們在 Infrastructure Layer 實作我們的 repository，我們暫時先不接資料庫，所以先做一個 InMemory 版本的 repository 來做測試。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserRepository</span> : IUserRepository
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;User&gt; _users = <span style=color:#66d9ef>new</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Add(User user)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _users.Add(user);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> User? GetUserByEmail(<span style=color:#66d9ef>string</span> email)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _users.SingleOrDefault(u =&gt; u.Email.Equals(email));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>實作完需要透過 DependencyInjection 注入到我們的 Service Container 內。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DependencyInjection</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IServiceCollection AddInfrastructure(<span style=color:#66d9ef>this</span> IServiceCollection services, ConfigurationManager configuration)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        services.Configure&lt;JwtSettings&gt;(configuration.GetSection(JwtSettings.SectionName));
</span></span><span style=display:flex><span>        services.AddSingleton&lt;IJwtTokenGenerator, JwtTokenGenerator&gt;();
</span></span><span style=display:flex><span>        services.AddSingleton&lt;IDateTimeProvider, DateTimeProvider&gt;();
</span></span><span style=display:flex><span>        services.AddSingleton&lt;IUserRepository, UserRepository&gt;();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> services;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>至此，我們已經完成了一個簡單的身份認證的 API。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/it/>IT</a></li><li><a href=https://intervalrain.github.io/tags/c%23/>C#</a></li><li><a href=https://intervalrain.github.io/tags/clean-architecture/>Clean Architecture</a></li></ul><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>