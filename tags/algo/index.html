<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algo | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/tags/algo/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/tags/algo/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/tags/algo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/tags/algo/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="Algo"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Algo"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/tags/>Tags</a></div><h1>Algo</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[algo] timeline algorithm</h2></header><div class=entry-content><p>#include &lt;iostream> #include &lt;string> #include &lt;vector> using namespace std; class Solution { public: string shortestCommonSupersequence(string a, string b) { int m = a.size(); int n = b.size(); vector&lt;vector&lt;int>> dp(m+1, vector&lt;int>(n+1, 0)); for (int i = 0; i &lt;= m; i++) { for (int j = 0; j &lt;= n; j++) { if (i == 0 || j == 0) continue; if (a[i-1] == b[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } int i = m; int j = n; string res; while (i > 0 && j > 0) { if (a[i-1] == b[j-1]) { res += a[i-1]; --i; --j; } else { if (dp[i-1][j] &lt; dp[i][j-1]) { res += b[--j]; } else { res += a[--i]; } } } while (i > 0) res += a[--i]; while (j > 0) res += b[--j]; reverse(res.begin(), res.end()); return res; } string shortestCommonSupersequencePlus(vector&lt;string>& strs) { string res = strs[0]; for (int i = 1; i &lt; strs.size(); i++) { res = shortestCommonSupersequence(res, strs[i]); } return res; } string trans(string& a, string& pattern) { int i = 0; int j = 0; int m = a.size(); int n = pattern.size(); string res; while (i &lt; m && j &lt; n) { if (a[i] != pattern[j]) { res.push_back(' '); j++; } else { res.push_back(a[i]); i++; j++; } } return res; } }; int main() { int n; vector&lt;string> strs = { "ABCDEH", "ACDEFBH", "ADEHG" }; Solution* sol = new Solution(); string res = sol->shortestCommonSupersequencePlus(strs); cout &lt;&lt; res &lt;&lt; endl; cout &lt;&lt; sol->trans(strs[0], res) &lt;&lt; endl; cout &lt;&lt; sol->trans(strs[1], res) &lt;&lt; endl; cout &lt;&lt; sol->trans(strs[2], res) &lt;&lt; endl; return 0; } 結果 input: ABCDEH ACDEFBH ADEHG ========= output: ABCDEFBHG ABCDE H A CDEFBH A DE HG</p></div><footer class=entry-footer><span title='2023-11-10 03:10:09 +0800 +0800'>November 10, 2023</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [algo] timeline algorithm" href=https://intervalrain.github.io/algo/timeline/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Algo] 3-2. Binary Search</h2></header><div class=entry-content><p>Binary Search 二元搜索法 通常一般的二分搜是在解決以下這種問題：如果有一個遞增的函數 \(f\) 定義在區間 \([a, a + n)\) 上，請求出滿足 \(f(s)\ge c\)的最小整數\(s\)。 若用一般的 linear search 從 a 開始搜直到找到滿足條件的 s，那麼複雜度是 \(O(n)\)，而用二元搜索法可以優化時間複雜度變成 \(O(\log n)\)。
想法是對於某個在 \((a, a + n)\) 中的整數 \(k\)，如果 \(f(k − 1) \ge c\)，那麼 \(s &lt; k\)，也就是答案會落在區間 \([a, k)\) 中。
反之，如果 \(f(k − 1) &lt; c\)，那麼 \(s \ge k\)，也就是說你要求的答案會落在 \([k, a + n)\)。
為了讓兩種情況的可能性都盡量低， k 取愈接近 a + n/2 愈好。如此一來，每次候選區間的長度都會縮小一半，因此複雜度為 \(O(\log n)\)。 實務上，這種函數 \(f\) 常常不能直接得出某一點的值 \(f(a)\)（甚至只能確認它和 \(c\) 的大小關係），而需要 \(O(M)\) 的時間來計算。顯然地，這時複雜度是 \(O(M \log n)\)。 1. 三元搜 利用二分搜這種「縮短候選人長度」的想法，我們可以找出滿足特定性質的函數的最小值，這種技巧稱為三分搜。 三分搜處理的問題如下：有一個在 \([a, a + n)\) 中先嚴格遞減再嚴格遞增的函數 \(f\)，請求出 \(f\) 在 \([a, a + n)\) 的最小值。取在 \([a, a + n)\) 中的兩個整數 \(x &lt; y\)。如果 \(f(x) &lt; f(y)\)，那麼最小值一定落在 \([a, y)\)。如果 \(f(x) > f(y)\)，那麼最小值一定落在 \((x, a + n)\)。如果 \(f(x) = f(y)\)，那麼最小值一定落在 \((x, y)\)。為了讓候選區間每次都會縮短一定的比例，通常都取 x 跟 y 為區間的三等分點（取中間一點的話常數會變小）。複雜度仍然是 \(O(\log n)\)。 2. 對答案二分搜 有許多問題都喜歡叫你求「滿足條件的最小值」這種東西。如果這個問題滿足「單調 性」，那或許可以考慮對答案二分搜。 什麼是「單調性」呢？考慮一個函數 P，如果 s 滿足條件，那麼 P(s) = 1，反之則為 0。如果 P 有單調性，我們就說這個問題有單調性。這樣的好處是，我們可以直接用前面的方法二分搜出要求的 s。如果計算 P 的複雜度並不大時，這樣的方法可以有非常的表現效率。在你沒辦法快速求出 s 而只能快速確認一個 s 是否符合條件時，這是一個非常好的方法。 例題：Leetcode875. Koko Eating Bananas 以此題而言， canFinish 就是一個具備單調性的函式，符合我們對答案作二分搜的條件。 int minEatingSpeed(vector&lt;int>& piles, int h) { int max = *max_element(piles.begin(), piles.end()); if (piles.size() == h) return max; int left = 1, right = max + 1; while (left &lt; right){ int mid = left + (right-left)/2; if (canFinish(piles, mid, h)){ right = mid; } else { left = mid + 1; } } return left; } bool canFinish(vector&lt;int> piles, int speed, int h){ int time = 0; for (int n : piles){ time += n/speed + ((n % speed > 0) ? 1 : 0); } return time &lt;= h; } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 3-1. Two Pointer 接著閱讀：[Algo] 3-3. Monotonic Stack</p></div><footer class=entry-footer><span title='2023-05-07 18:46:56 +0800 +0800'>May 7, 2023</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 3-2. Binary Search" href=https://intervalrain.github.io/cs/algo/binary_search/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Algo] 3-10. Binary Indexed Tree(Fenwick Tree, BIT)</h2></header><div class=entry-content><p>前言：
若要對一數組做範圍取值，那麼最快的方法是前綴數組(prefix sum)，可以做到\(O(1)\)的查詢，但若要做單點更新需要\(O(n)\)的時間來維護。
而數組則是做單點更新只需要\(O(1)\)的時間，而要範圍取值則需要\(O(n)\)的查詢時間。
故若是查詢遠大於更新的情境，則適用前綴數組；若更新遠大於查詢的情境，則適用一般數組。
那假如查詢與更新的次數一樣多呢(動態更新與查詢的情境)，這種情況就可以用到此章節要介紹的資料結構，Binary Indexed Tree 了。
此結構可以做到 \(O(n)\) 的初始化，\(\log(n)\) 的更新與 \(\log(n)\) 的查詢。
\( \begin{array}{|c|c|c|}\hline &\textsf{範圍查詢}&\textsf{單點更新}\\\hline \textsf{數組}&amp;O(n)&amp;O(1)\\\hline \textsf{前綴數組}&amp;O(1)&amp;O(n)\\\hline \textsf{BIT}&amp;O(\log n)&amp;O(\log n)\\\hline \end{array} \)
簡介 與線狀樹(Segment Tree)類似，但線狀樹可以看成是 BIT 的擴充版。 BIT 的好處是只需要 n 的數組空間便可以實作，且其指標移動是透過位元運算，計算相當快速，缺點是無法套用到取極大值、極小值的情境。 參考上圖，BIT 利用「部分presum」的特性，來達到平均 \(O\log n\)的查詢與更新的時間，而其實其結構就是 partition 的其中半顆樹。 \(\text{BIT[1]=arr[1]}\) \(\text{BIT[2]=arr[1]+arr[2]}\) \(\text{BIT[3]=arr[3]}\) \(\text{BIT[4]=arr[1]+arr[2]+arr[3]+arr[4]}\) … \(\text{BIT[8]=arr[1]+arr[2]+…+arr[8]}= \text{BIT[4]+BIT[6]+BIT[7]+arr[8]}\) 觀察以上結構， 查詢時，求 [0:n] 的值為把上圖的片段湊起來變成 n 的長度。 如 \(\text{SUM[0:7]=BIT[7]+BIT[6]+BIT[4]}\) 位元表示：\(\text{SUM[0:7]=BIT[1b'111]+BIT[1b'110]+BIT[1b'100]}\) 如 \(\text{SUM[0:11]=BIT[11]+BIT[10]+BIT[8]}\) 位元表示：\(\text{SUM[0:11]=BIT[1b'1011]+BIT[1b'1010]+BIT[1b'1000]}\) 可以發現位元的規律是每次把當前的 LSB(least significant bit) 扣掉。 更新時，需要把包含 n 的片段都更新。(設n=18) 如 \(\text{update(arr[7])=update(BIT[7])+update(BIT[8])+update(BIT[16])}\) 位元表示：\(\text{update(arr[7])=update(BIT[1b'111])+update(BIT[1b'1000])+update(BIT[1b'10000])}\) 如 \(\text{update(arr[11])=update(BIT[11])+update(BIT[12])+update(BIT[16])}\) 位元表示：\(\text{update(arr[7])=update(BIT[1b'1011])+update(BIT[1b'1100])+update(BIT[1b'10000])}\) 可以發現位元的規律是每次把當前的 LSB 加進來。 統整以上規律我們可以寫成以下的模版 將 BIT[0] 設為 dummy，可方便計算。 模板 class BIT { private: vector&lt;int> bit; int lowbit(int a) { return a & (-a); } public: BIT (int n) { bit.assign(n+1, 0); } void add(int idx, int diff) { idx++; int n = bit.size(); while (idx &lt; n) { bit[idx] += diff; idx += lowbit(idx); } } int query(int idx) { int sum = 0; idx++; while (idx > 0) { sum += bit[idx]; idx -= lowbit(idx); } return sum; } } 回目錄 Catalog
...</p></div><footer class=entry-footer><span title='2023-04-08 17:46:12 +0800 +0800'>April 8, 2023</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 3-10. Binary Indexed Tree(Fenwick Tree, BIT)" href=https://intervalrain.github.io/cs/algo/bit/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Algo] 3-1. Two Pointer/Sliding Window</h2></header><div class=entry-content><p>前言：
先前我們在鏈表的單元已經介紹過求鏈表中點的「前後指針」與求有環鏈表的「快慢指針」，這都是雙指針的應用。
在接下來的這個章節，主要會介紹的雙指針應用，與更進階的滑動窗口(sliding window)的應用。
一、Two Pointer in LinkedList 在本文中會學到 LinkedList 的七種技巧： 合併兩個有序鏈表 分解鏈表 合併多個有序鏈表 尋找鏈表的倒數第 k 個節點 尋找鏈表的中點 判斷鏈表是否包含環 判斷兩個鏈表是否相交 1. Merge Two Sorted Lists Leetcode 21. Merge Two Sorted Lists 這一題的小技巧是創建一個 dummy node 依序將兩條鏈表中較小的值接在後面，最後回傳 dummy->next，過程很像 merge sort。 ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* dummy = new ListNode(); ListNode* curr = dummy; while (list1 && list2) { if (list1->val &lt;= list2->val) { curr->next = list1; list1 = list1->next; } else { curr->next = list2; list2 = list2->next; } curr = curr->next; } if (list1) curr->next = list1; if (list2) curr->next = list2; return dummy->next; } 二、Two Pointer in Array 三、Sliding Window 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 3-0. Sorting 接著閱讀：[Algo] 3-2. Binary Search</p></div><footer class=entry-footer><span title='2023-03-19 22:56:03 +0800 +0800'>March 19, 2023</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 3-1. Two Pointer/Sliding Window" href=https://intervalrain.github.io/cs/algo/two_pointer/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[Algo] 3-0. Sorting</h2></header><div class=entry-content><p>前言：
在開始練習各種演算法題型時，最先需要養成的是，如何選用「適當」的演算法，題目往往不會只有一種解，但合適的演算法可以如同走捷徑一般，快速且優雅的達到目標。 在實作程式前，更重要的是，寫下一段 pseudo code，試著說明其複雜度，並觀察是否有冗餘的空間可以優化。 在腦海中模擬一遍程式碼之後，最後才是快速的將程式碼實作出來。 在這一章節，我們將練習如何將「想法」轉換成「實作」。並且我們必須熟悉如何計算其時間複雜度。
一、Cheat Table 首先我們需要先瞭解每一種資料結構的各種操作的時間複雜度，以便我們選擇適合的資料結構與演算法。
下面這種表的 Array, Stack, Queue, Linked List, Hash Table, Binary Search Tree 基本上是要背起來的，其餘的遇到再去認識就好。 接下來就輪到練習實作了，排序演算法是個很好的練習，試著把下表中的排序演算法完成，並且計算其時間複雜度吧。
參考題目 Leetcode 912. Sort an Array 二、Sorting Algorithm 0. 測資 這個 file 是我寫的測資，可以拿來測試自己的實作，用法是 #include "agtr.h"，之後用 judge() 函式測試你寫好的 function。 #include &lt;iostream> #include &lt;random> #include &lt;vector> using namespace std; class agtr{ public: static vector&lt;int> exec(int n, int minv, int maxv) { if (minv > maxv) return {}; else if (minv == maxv) return vector&lt;int>(n, minv); vector&lt;int> res; random_device rd; mt19937 mt(rd()); uniform_real_distribution&lt;double> dist(minv, maxv); while (n--) { res.push_back(dist(mt)); } return res; } static vector&lt;int> exec(int n) { return exec(n, 0, 10); } static vector&lt;int> exec() { return exec(10); } static void print(vector&lt;int>& nums) { cout &lt;&lt; "["; for_each(nums.begin(), nums.end()-1, [](int x) { cout &lt;&lt; x &lt;&lt; ","; }); cout &lt;&lt; *(nums.end()-1) &lt;&lt; "]"; } static bool check(vector&lt;int>& nums, vector&lt;int> copy) { sort(copy.begin(), copy.end()); for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] != copy[i]) return false; } return true; } static void judge(void (*func)(vector&lt;int>&)) { int n = 10; bool test = true; int cnt = 0; while (n--) { auto nums = exec(); auto copy = vector&lt;int>(nums.begin(), nums.end()); print(nums); (*func)(nums); cout &lt;&lt; "->"; print(nums); int result = check(nums, copy); cout &lt;&lt; "(" &lt;&lt; (result ? "Pass" : "Fail") &lt;&lt; ")" &lt;&lt; endl; if (result) cnt++; test &= result; } if (test) { cout &lt;&lt; "Pass! (10/10)" &lt;&lt; endl; } else { cout &lt;&lt; "Fail! (" &lt;&lt; cnt &lt;&lt; "/10)" &lt;&lt; endl; } } }; 以下為測試的方式 # include "agtr.h" void sort(vector&lt;int>& nums) {...} // 你的實作 int main() { agtr::judge(sort); // 用這個函式測試你的實作 return 0; } 1. Bubble Sort void sort(vector&lt;int>& nums) { int n = nums.size(); for (int i = n-1; i > 0; i--) { for (int j = 0; j &lt; i; j++) { if (nums[j] > nums[j+1]) swap(nums[j], nums[j+1]); } } } 2. Selection SOrt void sort(vector&lt;int>& nums) { int n = nums.size(); for (int i = 0; i &lt; n-1; i++) { int p = i; for (int j = i+1; j &lt; n; j++) { if (nums[j] &lt; nums[p]) p = j; } swap(nums[p], nums[i]); } } 3. Insertion Sort void sort(vector&lt;int>& nums){ int n = nums.size(); for (int i = 1; i &lt; n; i++) { int j = i-1; int curr = nums[i]; for (; j >= 0; j--) { if (nums[j] &lt;= curr) { break; } nums[j+1] = nums[j]; } nums[j+1] = curr; } } 4. Heap Sort void heapify(vector&lt;int>& nums, int i) { int left = 2*i+1; int right = 2*i+2; int p = i; int n = nums.size(); if (left &lt; n && nums[left] &lt; nums[p]) p = left; if (right &lt; n && nums[right] &lt; nums[p]) p = right; if (p != i) { swap(nums[i], nums[p]); heapify(nums, p); } } void sort(vector&lt;int>& nums) { vector&lt;int> vec(nums.begin(), nums.end()); int n = vec.size(); int parent = (n-1)/2; for (int i = parent; i >= 0; i--) { heapify(vec, i); } for (int i = 0; i &lt; n; i++) { nums[i] = vec[0]; vec[0] = vec.back(); vec.pop_back(); heapify(vec, 0); } } 5. Tree Sort class TreeNode { private: TreeNode* left, *right; int val; TreeNode* insert(TreeNode* root, int val) { if (!root) { root = new TreeNode(val); return root; } if (val &lt; root->val) { root->left = insert(root->left, val); } else { root->right = insert(root->right, val); } return root; } void dfs(TreeNode* root, vector&lt;int>& nums) { if (!root) return; dfs(root->left, nums); nums.push_back(root->val); dfs(root->right, nums); } public: TreeNode() {} TreeNode(int val) : val(val) {} TreeNode(int val, TreeNode* left, TreeNode* right) : val(val), left(left), right(right) {} void insert(int val) { insert(this, val); } vector&lt;int> getArray() { vector&lt;int> nums; dfs(this, nums); return nums; } }; void sort(vector&lt;int>& nums) { TreeNode* root = new TreeNode(nums[0]); for (int i = 1; i &lt; nums.size(); i++) { root->insert(nums[i]); } nums = root->getArray(); } 6. Merge Sort void merge(vector&lt;int>& nums, int left, int mid, int right) { int i = left, j = mid + 1; vector&lt;int> tmp; while (i &lt;= mid && j &lt;= right) { if (nums[i] &lt; nums[j]) tmp.push_back(nums[i++]); else tmp.push_back(nums[j++]); } while (i &lt;= mid) tmp.push_back(nums[i++]); while (j &lt;= right) tmp.push_back(nums[j++]); for (i = left; i &lt;= right; i++) { nums[i] = tmp[i-left]; } } void sort(vector&lt;int>& nums, int left, int right) { if (right &lt;= left) return; int mid = left + (right-left)/2; sort(nums, left, mid); sort(nums, mid+1, right); merge(nums, left, mid, right); } void sort(vector&lt;int>& nums) { sort(nums, 0, nums.size()-1); } 7. Quick Sort nt partition(vector&lt;int>& nums, int left, int right) { int pivot = left; int i = left; int j = right+1; while (true) { while (i &lt; right && nums[++i] &lt; nums[pivot]); while (j > left && nums[--j] > nums[pivot]); if (i >= j) break; swap(nums[i], nums[j]); } swap(nums[pivot], nums[j]); return j; } void sort(vector&lt;int>& nums, int left, int right) { if (left >= right) return; int pivot = partition(nums, left, right); sort(nums, left, pivot-1); sort(nums, pivot+1, right); } void sort(vector&lt;int>& nums) { sort(nums, 0, nums.size()-1); } 8. Tim Sort #define MIN_MERGE 32 int minRunLength(int n) { int r = 0; while (n >= MIN_MERGE) { r |= (n & 1); n >>= 1; } return n + r; } void insertionSort(vector&lt;int>& nums, int left, int right) { int n = nums.size(); for (int i = left+1; i &lt;= right; i++) { int j = i-1; int curr = nums[i]; for (; j >= left; j--) { if (nums[j] &lt;= curr) { break; } nums[j+1] = nums[j]; } nums[j+1] = curr; } } void merge(vector&lt;int>& nums, int left, int mid, int right) { int i = left; int j = mid + 1; vector&lt;int> tmp; while (i &lt;= mid && j &lt;= right) { if (nums[i] &lt; nums[j]) tmp.push_back(nums[i++]); else tmp.push_back(nums[j++]); } while (i &lt;= mid) tmp.push_back(nums[i++]); while (j &lt;= right) tmp.push_back(nums[j++]); for (i = left; i &lt;= right; i++) { nums[i] = tmp[i-left]; } } void sort(vector&lt;int>& nums) { int minRun = minRunLength(MIN_MERGE); int n = nums.size(); for (int i = 0; i &lt; n; i += minRun) { int hi = min((i + MIN_MERGE - 1), n-1); insertionSort(nums, i, hi); } for (int size = minRun; size &lt; n; size &lt;&lt;= 1) { for (int left = 0; left &lt; n; left += (size &lt;&lt; 1)) { int mid = left + size - 1; int right = min((left + (size &lt;&lt; 1) - 1), n-1); if (mid &lt; right) { merge(nums, left, mid, right); } } } } 9. Shell Sort void sort(vector&lt;int>& nums) { int n = nums.size(); for (int gap = n>>1; gap > 0; gap>>=1) { for (int i = gap; i &lt; n; i++) { int tmp = nums[i]; int j; for (j = i; j >= gap && nums[j-gap] > tmp; j -= gap) { nums[j] = nums[j-gap]; } nums[j] = tmp; } } } 10. Counting Sort void sort(vector&lt;int>& nums) { vector&lt;int> dp(10, 0); for (const auto& x : nums) { dp[x]++; } int j = 0; for (int i = 0; i &lt; 10; i++) { while (dp[i]-- > 0) { nums[j++] = i; } } } 回到目錄：[Algo] 演算法筆記 接著閱讀：[Algo] 3-1. Two Pointer/Sliding Window</p></div><footer class=entry-footer><span title='2023-03-16 19:50:21 +0800 +0800'>March 16, 2023</span>&nbsp;·&nbsp;6 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 3-0. Sorting" href=https://intervalrain.github.io/cs/algo/sorting/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[Algo] 2-4. 回溯法 Backtracking</h2></header><div class=entry-content><p>一、回溯法 回溯法與 dfs 相當類似，本質上都是暴力窮舉的演算法，但細微的差異在於： dfs 在遍歷節點。 backtracking 在遍歷樹枝。 站在回溯樹上的一個節點，需要考慮的只有三件事情： 路徑 選擇 終止條件 以全排列問題([Leetcode] 46. permutation)來舉例 全排列問題即給定一組數組 nums，需返回這些數字的所有排列組合，舉例來說，給定一個數組 nums = [1,2,3]，那麼它可能的排列會有： [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1] 對應上圖的回溯樹來看，我們在每個樹的節點，都會面臨一次決策，站在樹的根時，相當於我們要選擇排列的第一位，而我們有三個選擇，即 1 或 2 或 3。若我們的第一位選擇了 1，代表我們選擇了 \(\text{x}_1=1\) 的路徑，故接下來我們的選擇只剩下兩個，即 2 或 3。當我們繼續往下做，直到子葉節點時，代表我們已經沒有選擇可選，此時就是我們的終止條件。 回憶我們在二叉樹中練習過前序、中序、後序的思維，前序與後序代表我們在遍歷節點前與後的時間點，而在回溯法，這兩個時間點，各自代表了 將選擇加入路徑 從路徑中撤銷選擇 用二叉樹程式碼來說明即： void traverse(TreeNode* root){ if (!root) return; // preorder: do option traverse(root->left); traverse(root->right); // postorder: retrieve option } N-ary 樹： class Node{ int val; vector&lt;Node*> children; }; void traverse(Node* root){ if (!root) return; for (Node* child : root->children) { // preorder: do option traverse(child); // postorder: retrieve option } } 二、回溯法的框架 藉由上面的思維練習，我們可以拼湊出回溯法的基本框架： vector&lt;Node*> path; vector&lt;vector&lt;Node*>> res; void backtrack(Node* root) { if (terminate_condition) { // 當終止條件時 res.push_back(path); // 將路徑加入結果 return; // 治原路徑返回 } for (auto& next : root->children) { path.push_back(next); // 將選擇加入路徑 backtrack(next); path.pop_back(); // 從路徑中撤銷選擇 } } 試著解題[Leetcode] 46. permutation： void backtrack(vector&lt;int>& nums, vector&lt;bool>& visited, vector&lt;int>& path) { if (path.size() == nums.size()) { res.push_back(path); return; } for (int i = 0; i &lt; nums.size(); i++) { if (visited[i]) continue; visited[i] = true; path.push_back(nums[i]); backtrack(nums, visited, path); visited[i] = false; path.pop_back(); } } 三、例題 1. [Leetcode] 51. N-Queens 經典的 N-Queen 問題，在一個 N x N 的棋盤上，每個橫排、直排與斜線都不能出現 2 個以上的皇后，試求有幾種皇后的排法。 此題就可以用到回溯法，以 4 x 4 的棋盤為例，我們會建構一個深度為 16 的決策樹： 路徑：之前做過的選擇 選擇：選擇要放置皇后，或是不要放置皇后 終止條件：16 個棋格都走完(4列都走完) 注意：因為在第 i 列放了皇后，則同列的其它格子就不能放皇后了，故我們可以直接往第 i+1 列前進。故到了第 n 列，代表達到終止條件。 程式碼： int sz; vector&lt;vector&lt;string>> solveNQueens(int n) { sz = n; vector&lt;vector&lt;string>> res; vector&lt;string> board(n, string(n, '.')); backtrack(board, 0, res); return res; } void backtrack(vector&lt;string>& board, int row, vector&lt;vector&lt;string>>& res){ if (row == sz){ // 終止條件：走完 n 行 res.push_back(board); return; } for (int col = 0; col &lt; sz; col++){ if (!isValid(board, row, col)) continue; board[row][col] = 'Q'; // 放皇后 backtrack(board, row+1, res); board[row][col] = '.'; // 撤銷皇后 } } // 直行、橫列、斜線都不能出線皇后 bool isValid(vector&lt;string>& board, int& row, int& col){ if (row == sz) return true; for (int i = row - 1; i >= 0; i--) if (board[i][col] == 'Q') return false; for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){ if (board[i][j] == 'Q') return false; } for (int i = row - 1, j = col + 1; i >= 0 && j &lt; sz; i--, j++){ if (board[i][j] == 'Q') return false; } return true; } 2. [Leetcode] 797. All Paths From Source to Target 給定一個 DAG(directed acyclic graph)，各用 0 到 n-1 的數字標示，找出所以可能從 0 走到 n-1 的路徑。其中 graph[i] 代表從 i 可以到達的下一個節點。 vector&lt;vector&lt;int>> allPathsSourceTarget(vector&lt;vector&lt;int>>& graph) { vector&lt;vector&lt;int>> res; vector&lt;int> path; path.push_back(0); // 站在起點 0 backtrack(graph, res, path, 0, -1); return res; } void backtrack(vector&lt;vector&lt;int>>& graph, vector&lt;vector&lt;int>>& res, vector&lt;int>& path, int curr, int last) { if (curr == graph.size()-1) { // 到達終點 n-1 res.push_back(path); return; } for (const auto& next : graph[curr]) { // if (last == next) continue; // 若是 directed 或是 cyclic graph，需要避免走回頭路 path.push_back(next); // 做選擇 backtrack(graph, res, path, next, curr); path.pop_back(); // 做撤銷 } } 3. [Leetcode] 980. Unique Path III 機器人必須走過除了牆外的所有棋格，必且到達指定的位置，試求機器人有幾種走法。其中 1 代表起點。 2 代表終點。 0 代表空白棋格，即機器人必須要經過的棋格。 -1 代表牆，即機器人無須經過且不能經過的棋格。 注意此題的選擇、與撤銷的位置與框架中的前序、後序位置不同，試想會有什麼效果 int res; int uniquePathsIII(vector&lt;vector&lt;int>>& grid) { res = 0; int m = grid.size(), n = grid[0].size(); // 先記錄機器人的起點與終點 pair&lt;int,int> start, end; // 記錄機器人所需走多少步(選擇的次數): 棋格數-障礙-1 int left = m*n; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == 1) { start = {i, j}; left--; } else if (grid[i][j] == -1) { left--; } } } backtrack(grid, start.first, start.second, left); return res; } int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; void backtrack(vector&lt;vector&lt;int>>& grid, int row, int col, int left) { // 超出棋格、或是已經走過 if (row &lt; 0 || row >= grid.size() || col &lt; 0 || col >= grid[0].size() || grid[row][col] == -1) return; // 終止條件：到達目標且每一個空白棋格都走完(left == 0) if (grid[row][col] == 2 && left == 0) { res++; return; } int tmp = grid[row][col]; // 做選擇 grid[row][col] = -1; // 做標記，代表已走過 for (const auto& d : dir) { backtrack(grid, row+d[0], col+d[1], left-1); } grid[row][col] = tmp; // 做撤銷 } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-3. 分治法 接著閱讀：[Algo] 2-5. 動態規劃</p></div><footer class=entry-footer><span title='2023-01-27 10:50:26 +0800 +0800'>January 27, 2023</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 2-4. 回溯法 Backtracking" href=https://intervalrain.github.io/cs/algo/backtracking/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[Algo] 2-3. 分治法 Divide and Conquer</h2></header><div class=entry-content><p>一、分治法 分治法，簡而言之就是分而治之，把複雜的問題分成兩個或更多個相似或相似的子問題，直到子問題可以直接求解，最後再將子問題的解做合併。 三步驟：Divide、Conquer、Merge 以 pseudo code 來表示大概像： void func(collection set) { // 子問題求解 if (base_case) { // 根據要求將子問題解合併成母問題解 do_something return; } // 將母問題分解成子問題 for (collection subset : set) { func(subset); } } graph LR; 母問題-->子問題1; 母問題-->子問題2; subgraph Divide 子問題1-->最小子問題1; 子問題1-->最小子問題2; 子問題2-->最小子問題3; 子問題2-->最小子問題4; end subgraph Conquer 最小子問題1-->最小子問題解1; 最小子問題2-->最小子問題解2; 最小子問題3-->最小子問題解3; 最小子問題4-->最小子問題解4; end subgraph Merge 最小子問題解1-->合併; 最小子問題解2-->合併; 最小子問題解3-->合併; 最小子問題解4-->合併; end 合併-->母問題解 舉例說明，河內塔遊戲： 河內塔是由三根桿子以大小不同碟片所組成的遊戲，僧人一次可以從一根桿子移動一個碟片到另一根桿子，但是小的碟片若放憂大的碟片下面會使得小的碟片裂開(也就是碟片只能由上而下從小排到大)，試問將一座塔從一根桿子完整的移動到另一根桿子需要移動多少次。 思考上面的情形，以三個碟片為例，若我們要從 A 到 C 移動一座塔，我們可以將之分解成「如何把上面兩個碟片移動到 B」，因為剩下的一個大碟片，可以很簡單的從 A 移動到 C。也就是說 f3(A->C) = f2(A->B) + f1(A->C) + f2(B->C)。 再更進一步，f2(A->B) 和 f2(B->C) 其實就是移動兩個碟片到另一座塔，所以可以分解成 f2(A->C) = f1(A->B) + f1(A->C) + f1(B->C)，至此，我們已經把 f3 都分解成可以代表一次移動的最小子問題的解 f1 了： graph TD; A[f3,A->C] B[f2,A->B] C[f1,A->C] D[f2,B->C] E[f1,A->C] F[f1,A->B] G[f1,C->B] H[f1,B->A] I[f1,B->C] J[f1,A->C] A-->B A--->C A-->D B-->E B-->F B-->G D-->H D-->I D-->J 故我們可以以數學方式證明：
\(\begin{array}{l} T(n)=T(n-1)+T(1)+T(n-1)=2T(n-1)+T(1)\\ T(n-1)=T(n-2)+T(1)+T(n-2)=2T(n-2)+T(1)\\ T(n)=2[2T(n-2)+T(1)]+T(1)\\ T(n)=2\times2T(n-2)+(1+2)T(1)\\ T(n)=2^k\times T(n-k)+(1+2+…+2^k)T(1)\\ 令k=n-1\\ T(n)=2^{n-1}\times T(1)+(1+2+…+2^{n-1})T(1)\\ T(n)=2^{n-1}\times T(1)+\frac{2^{n-1}-1}{2-1}T(1)\\ T(n)=(2^n-1)\times T(1) \end{array}\) 得所需要的移動次數為 \(2^n-1\) 次 分治法的特色 要解決的問題有一定的規模 該問題可以分解成若干個規模較小的問題 可以找到一個 base case，可以直接求解(如上述數學證明的\(T(1)\)) 分解出來的子問題都是相互獨立的。(若有相依性，則無法使用分治法) 分治法的時間複雜度 將規模為 n 的問題分為 k個規模為 n/m 的子問題去解，那麼可以得到
\(T(n)=kT(n/m)+f(n)\) 二、分治法的應用 1. 二元搜索法 Binary Search 令有一已排序的數列，欲查找該數列中是否有數值 x。 由於該數列已經過排序，所以我們無需遍歷整個數列，我們可以選擇每次挑選數列的中間值，若目標比中間值大，則選擇大的那側再繼續做篩選，此法稱為二元搜索法，其時間複雜度可以從線性搜索法的 \(O(n)\) 降低到 \(O(n\log n)\)。 int binarySearch(vector&lt;int>& nums, int target) { int left = 0, right = nums.size()-1; while (left &lt;= right) { int mid = left + (right-left)/2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] > target) right = mid - 1; } return -1; } 2. Strassen 矩陣乘法 試做一個矩陣\(A\)與矩陣\(B\)內積。 \( A=\left[\begin{matrix}A_{11}&amp;A_{12}\\A_{21}&amp;A_{22}\end{matrix}\right], B=\left[\begin{matrix}B_{11}&amp;B_{12}\\B_{21}&amp;B_{22}\end{matrix}\right], C=\left[\begin{matrix}C_{11}&amp;C_{12}\\C_{21}&amp;C_{22}\end{matrix}\right],其中\\ \left[\begin{matrix}C_{11}&amp;C_{12}\\C_{21}&amp;C_{22}\end{matrix}\right]=\left[\begin{matrix}A_{11}&amp;A_{12}\\A_{21}&amp;A_{22}\end{matrix}\right]\cdot\left[\begin{matrix}B_{11}&amp;B_{12}\\B_{21}&amp;B_{22}\end{matrix}\right] \) 若通過一般展開可得
\( C_{11}=A_{11}\cdot B_{11}+A_{12}\cdot B_{21}\\ C_{12}=A_{11}\cdot B_{12}+A_{12}\cdot B_{22}\\ C_{21}=A_{21}\cdot B_{11}+A_{22}\cdot B_{21}\\ C_{22}=A_{21}\cdot B_{12}+A_{22}\cdot B_{22} \) 從上可得計算兩個 \(n\cdot n\) 的矩陣內積需要 兩個 \(\frac{n}{2}\cdot\frac{n}{2}\) 的矩陣做 8 次的乘法加上 4 次的加法，其時間複雜度可以表示成： \( T(n)=8T(\frac{n}{2})+\Theta(n^2)\\ T(\frac{n}{2})=8T(\frac{n}{4})+\Theta({\frac{n}{2}}^2)\\ T(n)=8\left[{8T(\frac{n}{4})+\Theta({{(\frac{n}{2}})}^2)}\right]+\Theta(n^2)\\ T(n)=8^2T(\frac{n}{4})+\Theta(n^2)+8\Theta(\frac{n^2}{4})=8^2T(\frac{n}{4})+(1+2)\Theta(n^2)\\ T(n)=8^kT(\frac{n}{2^k})+(1+2+…+2^{k-1})\Theta(n^2)\\ 令n=2^k\\ T(n)=n^3T(1)+(\frac{n/2-1}{2-1})\Theta(n^2)\approx \Theta(n^3) \) 若使用 Strassen 演算法 同樣將矩陣\(A,B,C\)作分解，\(時間\Theta(1)\) 創建 10 個 \(\frac{n}{2}\cdot\frac{n}{2}\) 的矩陣 \(S_1,S_2,…,S_{10}\)，時間\(\Theta(n^2)\)
\( S_1=B_{12}-B_{22}\\ S_2=A_{11}+A_{12}\\ S_3=A_{21}+A_{22}\\ S_4=B_{21}-B_{11}\\ S_5=A_{11}+A_{22}\\ S_6=B_{11}+B_{22}\\ S_7=A_{12}-A_{22}\\ S_8=B_{21}+B_{22}\\ S_9=A_{11}-A_{21}\\ S_{10}=B_{11}+B_{12}\\ \) 遞迴的計算 7 個矩陣積 \(P_1,P_2,…,P_7\)，其中每個矩陣\(P_i\)都是\(\frac{n}{2}\cdot\frac{n}{2}\)的。
\( P_1=A_{11}\cdot S_1=A_{11}\cdot B_{12}-A_{11}\cdot B_{22}\\ P_2=S_2\cdot B_{22}=A_{11}\cdot B_{22}+A_{12}\cdot B_{22}\\ P_3=S_3\cdot B_{11}=A_{21}\cdot B_{11}+A_{22}\cdot B_{11}\\ P_4=A_{22}\cdot S_4=A_{22}\cdot B_{21}-A_{22}\cdot B_{11}\\ P_5=S_5\cdot S_6=A_{11}\cdot B_{11}+A_{11}\cdot B_{22}+A_{22}\cdot B_{11}+A_{22}\cdot B_{22}\\ P_6=S_7\cdot S_8=A_{12}\cdot B_{21}+A_{12}\cdot B_{22}-A_{22}\cdot B_{21}-A_{22}\cdot B_{22}\\\\ P_7=S_9\cdot S_{10}=A_{11}\cdot B_{11}+A_{11}\cdot B_{12}-A_{21}\cdot B_{11}-A_{21}\cdot B_{12}\\\\\\ \) 藉由 \(P_i\) 來計算得到 矩陣 \(C\)：時間\(\Theta(n^2)\)
\( C_{11}=P_5+P_4-P_2+P_6\\ C_{12}=P_1+P_2\\ C_{21}=P_3+P_4\\ C_{22}=P_5+P_1-P_3-P_7 \) 綜合已上可得： \( T(n)=\bigg\lbrace \begin{array}{ll} \Theta(1)&若n=1\\ 7T{\frac{n}{2}}+\Theta(n^2)&若n>1 \end{array} \) 故時間複雜度可推得 \(T(n)=\Theta(n^{\log_27})\approx \Theta(n^{2.807})\) 參考來源 Wikipedia 3. 合併排序 Merge Sort 在[Algo] 0-4. 二元樹(Binary Tree)中有介紹過，合併排序跟快速排序都有著類似前序、後序的結構， 步驟： 將數列拆成若干個只有 1 個元素的子數列(因為只有一個元素，所有可以視為已排序的數列)。 將已排序的數列兩兩合併，直到所有的數列都合併完成，即完成排序。 程式碼實作：mergeSort 4. 快速排序 Quick Sort 步驟： 選定一個數當作樞紐(pivot)，將小於此數的值都放到左邊，大於此數的都放到右邊。 反覆同樣動作，直到子數列只有一個數，即完成排序。 程式碼實作：quickSort 三、例題 1. 樹類問題 樹相關的問題很常有著類似的解題結構：
...</p></div><footer class=entry-footer><span title='2023-01-27 10:48:42 +0800 +0800'>January 27, 2023</span>&nbsp;·&nbsp;6 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 2-3. 分治法 Divide and Conquer" href=https://intervalrain.github.io/cs/algo/divide_and_conquer/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[Algo] 2-2. 貪心演算法 Greedy</h2></header><div class=entry-content><p>一、貪心演算法 是一種在每一步都採前當下看起來最好的選擇的一種策略。 由於是當下看起來最好的選擇，故也有可能選到錯的路線，導致最終的答案不是最佳解。 先舉個生活中常見的例子： 今天小明的撲滿裡存滿了大大小小的1塊、5塊跟10塊，今天小明打算要要幫撲滿瘦身，令它的重量降低，那麼小明可以到銀行換鈔，將幣值小、重量重的硬幣集結起來換成幣值大、重量輕的紙鈔。 用貪心演算法的思維，我們一定是從幣值大的 1000 開始換起，再來 500、100、50、10，以此類推，有多少換多少。 // vector&lt;int>& nums = {1000, 500, 100, 50, 10, 5, 1}; vector&lt;int> coinChange(vector&lt;int>& nums, int money) { vector&lt;int> res(nums.size(), 0); for (int i = 0; i &lt; nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 但若我們新增了一個幣值是 23，那麼上面這個思路就有可能會導致錯誤。 貪心演算法的特點 直覺且快速 通常不是最佳的 需要會被要求證明 always stays ahead：跑者每個時間點都在第一名，最後結果會是第一名 用歸納法證明。 exchange argument 用反證法，找到原解的 inversions，並作交換，證明交換後並不影響最佳解。 二、貪心演算法的應用 0. 核心思維 貪心演算法是從某一個初始狀態出發，每次通過選取區域性最優解向目標前進，並最終期望取得整體最優解的一種演算法。由這個定義可知，貪心選擇標準就是選擇當前最好的決策，貪心演算法根據這個標準進行決策，將原問題變成一個相似但規模更小的子問題，而後每一步選出來的一定是原問題整體最優解的一部分。
如果一個問題貪心後只剩下一個子問題且有最優子結構，那麼該問題就可以使用貪心演算法。當一個問題的整體最優解包含其子問題的最優解時，我們稱次問題具有最優子結構性質。 解題一般步驟 設計資料結構並找規律 進心貪心猜想 正確性證明(歸納法證明或是列舉反例進行反證) 實現程式碼 1. 找零錢問題(Coin Change) 先用剛剛提到的那一題來試做： 以貪心法的思維來做就是，幣值愈大先換，換到不能再換時再往次大的幣值換。 vector&lt;int> coinChange(vector&lt;int>& nums, int money) { vector&lt;int> res(nums.size(), 0); for (int i = 0; i &lt; nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 以範例 nums = {1000, 500, 100, 50, 23, 10, 5, 1}，money = 1069 來測試看看，以上述得到的結果應該是：(參考例題Leetcode 322. Coin Change) {1000, 500, 100, 50, 23, 10, 5, 1} = {1, 0, 0, 1, 0, 1, 1, 4}，也就是說，得到的硬幣總數是 8(假設所有幣值都是硬幣)。 因為夾雜了 23，使得問題變得稍微有點不一樣，因為最佳解可以是：
{1000, 500, 100, 50, 23, 10, 5, 1} = {1, 0, 0, 0, 3, 0, 0, 0}，總數 4。 從上面此例來觀察，貪心法是需要有適用時機的，當今天少掉 23 的時候，使用貪心法是可以得到最佳解的，因為所有數字互為因數、倍數關係，也就是說，當今天可以用 1 張 1000 解決的情況，必定可以用其它幣值用更多的代價來替換，如 2 張 500，或 10 張 100。但是 23 可以替換的是 2 個 10 塊加上 3 個 1 塊。用數字為例的話如下 \(\boxed{\begin{array}{ll} 1069&=1\times1000+1\times50+1\times10+1\times5+4\times1\\ &=1\times(2\times500)+1\times50+1\times10+1\times5+4\times1\\ &=1\times(10\times100)+1\times50+1\times10+1\times5+4\times1\\ &=1\times(20\times50)+1\times50+1\times10+1\times5+4\times1\\ \end{array}} \) 不管怎麼換，總數都是變大。 如果要解出上述的最佳解，需要做一點修正，或是使用暴力破解法，例如 bfs 來遍歷所有情形來獲得最小值。 試想要怎麼改寫可以使貪法仍然可以適用，「將23拿掉」那麼貪心法就仍可以適用，那要怎麼有技巧的將 23 拿掉呢。 23 能夠有效的替換表示我們一定會使用到 23，也就是說我們可以找到反例使 23 不能有效的替換就好了。 23 = 23*1(1) 換 10*2 + 1*3(5) 46 = 23*2(2) 換 10*4 + 5*1 + 1*1(6) 69 = 23*3(3) 換 50*1 + 10*1 + 1*4(6) 92 = 23*4(4) 換 50*1 + 10*4 + 1*2(7) 115 = 23*5(5) 換 100*1 + 10*1 + 5*1(3) 我們可以發現當 23 替換到第 5 個的時候已經不能有效的替換了，表示我們只有嘗試替換 0~4 個 23 硬幣，其餘剩下的錢用貪心法去計算，仍然可以得到有效的解。(在此只是為了展示失去「局部最佳性」的範例，不做嚴謹的數學證明) 即求 min(f(1069)+0, f(1046)+1, f(1023)+2, f(1000)+3, f(976)+4。 vector&lt;int> coinChange(vector&lt;int>&amp;nums, int money) { ... } // implement by greedy vector&lt;int> coinChangePlus(vector&lt;int>&amp;nums, int money) { vector&lt;int> res; int coins = INT_MAX; for (int i = 0; i &lt;= 4; i++) { vector&lt;int> tmp = coinChange(nums, money-23*i); tmp[4]+=i; int cnt = accumulate(tmp.begin(), tmp.end(), 0); if (cnt &lt; coins) { res = tmp; coins = cnt; } } return res; } 以上方法當遇到單一奇異數(無因倍數關係)的時候還可以用，但遇到多個奇異數的時候，複雜度就會明顯上升，到時後我們會遇用其它方法來解構。在後面的動態規劃篇，有深入的介紹，如何利用其它技巧達到剪枝得到最佳解。 由此可發現，貪心法不一定會得到最佳解，需要嚴格的驗證「局部最佳性」，才能保證最後的解是最佳解。 2. 背包問題(Knapsack Problem) 常見的背包問題分為分數背包問題與0-1背包問題。 今天在某個場合，你有一個載重5kg的背包，面前有3kg的金沙、3kg的銀沙與2kg的銅沙，已知金的價格比銀高，銀的價格比銅高。你可以任意決定怎麼將它們裝進背包，最後換取對應價值的獎金，試問怎麼裝可以得到最高的獎金？ 同樣的場合，金沙、銀沙、銅沙換成了金塊、銀塊、銅塊，分別也是 3kg、3kg、2kg，且不可切割，試問要怎麼裝可以得到最高的獎金？ 第1題(分數背包)，顯而易見，用貪心法來做一定是盡可能先裝滿價值高的金沙，再用剩餘的空間以此類推裝填其它的。(3kg金沙+2kg銀沙) 第2題(0-1背包)，由於拿完金塊，無法再拿銀塊，所以最佳解變成了拿金塊與銅塊。(3kg金塊+2kg銅塊) 三、例題 1. 餅乾分配問題 Leetcode 455. Assign Cookies 有若干個不同份量的餅乾，與若干個需要不同份量才能滿足的小孩，試問餅乾最多可以讓幾個小孩滿意。 把餅乾的份量從小排到大，把小孩從需求小排到需求大。 盡可能的滿足需求小的小孩。(若需求小的都滿足不了，那麼需求大的就不可能滿足了) int findContentChildren(vector&lt;int>& children, vector&lt;int>& cookies) { sort(children.begin(), children.end()); sort(cookies.begin(), cookies.end()); int child = 0, cookie = 0; while (child &lt; children.size() && cookie &lt; cookies.size()) { if (children[child] &lt;= cookies[cookie]) child++; cookie++; } return child; } 2. 股票買賣問題 Leetcode 122. Best Timer to Buy and Sell Stock II 有一數列為某上市公司每日的股價，若手上最多只能有一張股票，要怎麼樣買賣可以得到最高獲利。 最高獲利代表所有上升波段的總和，忽略所有下降波段。 int maxProfit(vector&lt;int>& prices) { int sum = 0; int last = prices[0]; for (const auto& price : prices) { sum += (price > last) ? price - last : 0; last = price } return sum; } 3. 跳躍遊戲 55. Jump Game 有一數列表示，在該 i 索引位置起，最多可以跳幾個索引長度，試問從索引值為 0 開始，可否到達索引值為 n-1。 盡可能的往前跳，不斷的更新最遠可以到達的位置。 bool canJump(vector&lt;int>& nums) { int reach = nums[0]; for (int i = 0; i &lt; nums.size() && i &lt;= reach; i++) { if (i == nums.size()-1) return true; reach = max(reach, nums[i]+i); } return false; } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-1. 暴力演算法 接著閱讀：[Algo] 2-3. 分治法</p></div><footer class=entry-footer><span title='2023-01-24 18:31:15 +0800 +0800'>January 24, 2023</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 2-2. 貪心演算法 Greedy" href=https://intervalrain.github.io/cs/algo/greedy/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[Algo] 2-1. 暴力演算法 Brute Force</h2></header><div class=entry-content><p>一、暴力演算法 暴力演算法就是枚舉法，試想今天有一個行李箱的密碼鎖為四個一組，但你又忘記密碼，那要怎麼辦？你會試著從 0000 轉到 9999 共 10000 種組合都試過，必定會找出密碼，把所有可能都枚舉過一遍，遍是暴力演算法。
暴力演算法可以應用於很多問題，包含數論、樹、圖論等等，而暴力演算法的重點在於枚舉所有可能，以樹來說就是樹的遍歷。
舉例來說：
Leetcode 1. Two Sum
給定一個數列，找數列中任兩個數的和為 target，回傳兩個數的索引值。 在還沒有認識任何資料結構之前，我們能想到最簡單的方法就是遍歷整個數列，用兩個指標 i 與 j，各指向一個數，將所有可能檢查過一遍，直到找到目標。 vector&lt;int> twoSum(vector&lt;int>& nums, int target) { for (int i = 0; i &lt; nums.size() - 1; i++) for (int j = i + 1; j &lt; nums.size(); j++) if (nums[i] + nums[j] == target) return {i, j}; return {-1, -1}; } 以上例來說，用暴力破解法求解時，求兩數和的時候，我們需進行兩個維度的 for-loop 迴圈來求解。若進一步到三數和、四數和、五數和時，我們會發現，維度會隨著多少個數字和增加。也就是三數和為 3 個迴圈，四數和為 4 個迴圈，以此類推。 以 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis來分析，也就相當於 k 數和的時間複雜度為 \(O(n^k)\)，這個增長是相當恐怖的。 暴力演算法的特點
簡單粗暴 將所有可能枚舉出來，藉由電腦的運算力高於人腦的特性。 執行效率低 由於所有的情形都需列舉出來，所以執行效率低。 只適用於規模小的問題。 可作用衡量效率問題的基礎算法 暴力法可以看成是某問題時間效能的底限，所以可以用來衡量其它演算法的效率。 二、暴力演算法應用 1. 數組 線性搜索法(Linear Search) 將一個資料集合的所有元素遍歷一次，找到所需的目標。 例：有一個數列共有 n 個元素，找數列中是否含有某數 target，若有則回傳其索引值，若無則回傳 -1。 int findTarget(vector&lt;int>& nums, int target) { for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] == target) return i; } return -1; } 2. 樹 ...</p></div><footer class=entry-footer><span title='2023-01-24 15:57:40 +0800 +0800'>January 24, 2023</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 2-1. 暴力演算法 Brute Force" href=https://intervalrain.github.io/cs/algo/brute_force/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[Algo] 1-9. Algorithm</h2></header><div class=entry-content><p>algorithm &lt;algorithm> 定義了專為元素集合設計的函式。
元素集合包含可以被迭代器或指標存取的一系列元素，例如陣列或 STL container。但且注意，演算法只會透過迭代器去操作容器中的值，並不會更改其結構或是大小。
一、函式 1. 無修改值的操作 all_of bool all_of(Iterator first, Iterator last, UnaryPredicate pred)
檢查是否全部的元素都符合判斷式。 #include &lt;iostream> #include &lt;vector> #include &lt;algorithm> using namespace std; int main(){ vector&lt;int> arr1 = {1,2,3,4,5}; vector&lt;int> arr2 = {1,3,5,7,9}; vector&lt;int> arr3 = {2,4,6,8,10}; auto isodd = [](int x)->bool{ return x%2; }; cout &lt;&lt; all_of(arr1.begin(), arr1.end(), isodd) &lt;&lt; endl; // 0 cout &lt;&lt; all_of(arr2.begin(), arr2.end(), isodd) &lt;&lt; endl; // 1 cout &lt;&lt; all_of(arr3.begin(), arr3.end(), isodd) &lt;&lt; endl; // 0 return 0; } any_of bool any_of(Iterator first, Iterator last, Predicate pred)
...</p></div><footer class=entry-footer><span title='2023-01-03 21:49:42 +0800 +0800'>January 3, 2023</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 1-9. Algorithm" href=https://intervalrain.github.io/cs/algo/algorithm/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://intervalrain.github.io/tags/algo/page/2/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>