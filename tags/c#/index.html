<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C# | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/tags/c%23/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/tags/c%23/index.xml><link rel=alternate hreflang=en href=https://intervalrain.github.io/tags/c%23/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="C#"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:type" content="website"><meta property="og:url" content="https://intervalrain.github.io/tags/c%23/"><meta name=twitter:card content="summary"><meta name=twitter:title content="C#"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/tags/>Tags</a></div><h1>C#</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] React + .Net</h2></header><section class=entry-content><p>React + .Net 一、環境設置 Setup 1. 行前準備 Prerequisites 安裝 Node.js 和 npm node -v npm -v 安裝 .NET SDK dotnet --version 用 vs code 下載 ES7+ React/Redux/React-Native snippets 因為 rafce 很好用, 相當於, typescript 則是 tsrafce import React from 'react' const index = () => { return ( &lt;div>index&lt;/div> ) } export default index 2. 創建 React 安裝 react npm install create-react-app 創建新的 react app (typescript) --template typescript 可指定使用 typescript npx create-react-app {project} --template typescript cd {project} 必要時可能要初始化一個新的 react 項目，確保版本是匹配的。 yarnpkg add --exact react-dom react-scripts 3. 基本結構 函數式元件(Functional Component): const Card: React.FC&lt;Props> = ({ companyName, ticker, price }: Props): JSX.Element => { ... } Card 是一個函數式元件，使用 TypeScript 和 React。 React.FC&lt;Props> 指定這個元件是接受 Props 作為參數的 React 函數式元件 ({ companyName, ticker, price }) 是從 Props 解構的屬性，這些屬性將會被傳入元件 JSX 標籤: return ( &lt;div className='card'>...&lt;/div> ) 這是元件返回的 JSX，它描述了元件應該如何渲染。 4. State import React, { useState } from 'react' type Props = {} const Button: React.FC&lt;Props> = (props: Props): JSX.Element => { const [count, setCount] = useState&lt;number>(0); const onClick = (e: any) => { setCount(count + 1); console.log(e); } return ( &lt;div> &lt;button onClick={(e) => onClick(e)}>Click me&lt;/button> &lt;p>You clicked {count} times&lt;/p> &lt;/div> ) } export default Button 引入 React 和 useState Hook: import React, { useState } from 'react' 從 React 包中引入 useState Hook，用於函數式元件中添加狀態。 使用 useState Hook 定義狀態 const [count, setCount] = useState&lt;number>(0); 定義一個名為 count 的狀態變量，初始值為 0。 setCount 是用來更新 count 的函數。 useState&lt;number>(0) 指定 count 的類型為 number。 定義 onClick 事件處理函數: const onClick = (e: any) => { setCount(count + 1); console.log(e); } onClick 是一個事件處理函數，接受一個事件參數 e。 每當按鈕被點擊時， count 會加 1，並且會在控制台輸出事件 e。 any 也可被寫成 MounthEvent 或 SyntheticEvent。</p></section><footer class=entry-footer>&lt;span title='2024-06-11 22:00:23 +0800 +0800'>June 11, 2024&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] React + .Net" href=https://intervalrain.github.io/it/csharp-react/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] ApiController Atrribute</h2></header><section class=entry-content><p>ApiController Atrribute 當我在 API 專案中建立新的 controller 時，它會自帶一個 [ApiController] 屬性的控制器類別，而這個標籤的作用為何呢？
[ApiController] public class TestController : ControllerBase { } 1. 自動 HTTP 400 回應 它會自動產生一個行為過濾器(action filter)，當 ModelState.IsValid 為 false 時，自動回傳 400 Response。 2. 綁定來源參數推斷 可以更改模型綁定的約定，例如，[FromBody] 是針對複雜類型參數推斷的。 3. Multi/form-data 請求推理 對於標示 [FromForm] 的參數，推斷 Content-Type 為 multipart/form-data。 4. 屬性路由要求 強制要求所有操作都必須通過屬性路由。 ...</p></section><footer class=entry-footer>&lt;span title='2024-06-09 20:27:03 +0800 +0800'>June 9, 2024&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] ApiController Atrribute" href=https://intervalrain.github.io/it/apicontroller/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] EntityFramework Commands</h2></header><section class=entry-content><p>前置作業 需安裝以下 Packages
Microsoft.EntityFrameworkCore Microsoft.entityFrameworkCore.Design Microsoft.EntityFrameworkCore.Tools 設置好 []DbContext
範例 public class AppDbContext : DbContext { public DbSet&lt;Reminder> Reminders { get; set; } = null!; public DbSet&lt;User> Users { get; set; } = null!; public AppDbContext() { } protected override void OnConfiguring(DbContextOptionsBuilder options) { options.UseNpgsql("Host=localhost;Port=5432;Username=********;Password=********;Database=testdb"); } } ...</p></section><footer class=entry-footer>&lt;span title='2024-03-31 14:37:44 +0800 +0800'>March 31, 2024&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] EntityFramework Commands" href=https://intervalrain.github.io/it/entityframework_command/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] 用 C# 建置 Clean Architecture 專案</h2></header><section class=entry-content><p>Configure C# Solution step by step 開啟 Terminal 新增解決方案 dontet new sln -o MySln 移至方案目錄 cd MySln 根據解決方案 hierarchy 建構專案 dotnet new webapi -o MySln.Api dotnet new classlib -o MySln.Application dotnet new classlib -o MySln.Domain dotnet new classlib -o MySln.Infrastructure dotnet new classlib -o MySln.Contracts 將所有專案加進解決方案 for proj in $(ls -r **/*.csproj) dotnet sln add $proj 建立專案之間的 dependency dotnet add MySln.Api reference MySln.Application MySln.Infrastructure MySln.Contracts dotnet add MySln.Infrastructure reference MySln.Application dotnet add MySln.Application reference MySln.Domain</p></section><footer class=entry-footer>&lt;span title='2024-03-09 13:59:22 +0800 +0800'>March 9, 2024&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] 用 C# 建置 Clean Architecture 專案" href=https://intervalrain.github.io/it/ca_config/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] 使用 Clean Architecture + DDD 建置 Restful API</h2></header><section class=entry-content><p>程式碼 https://github.com/intervalrain/webapi_ca/
正文 建置 Solution 首先先參考 Clean Architecture 最經典的同心圓，來確定我們需要將我們的解決方案做哪些分層：
我將使用 Restful API 做為我們 I/O (Presentation Layer) 並且我需要配備身份驗證的機制 (Presentation Layer) 我使用 PostgresDB 作為我的 (Infrastructure Layer) 我的核心商業邏輯 (Application / Domain Layer) 創建專案
dotnet new sln -o Mysln 進入專案所在的資料夾 cd Mysln 根據預先的分層建立專案資料夾，並且使用 dotnet 指令建立相對應的專案類型。 Api –> WebAPI Infrastructure –> classlib Contracts –> classlib Application –> classlib Domain –> classlib dotnet new webapi -o Mysln.Api dotnet new classlib -o Mysln.Contracts dotnet new classlib -o Mysln.Infrastructure dotnet new classlib -o Mysln.Application dotnet new classlib -o Mysln.Domain 接著我們需要把產生的專案資料夾，加入到我們的 Solution。 dotnet sln add Mysln.Api dotnet sln add Mysln.Application dotnet sln add Mysln.Contracts dotnet sln add Mysln.Domain dotnet sln add Mysln.Infrastructure 接下來按照 Clean Architecture 的依賴原則來設定 dependency，依我的專案來說依賴方向如下。 graph TD; Api-->Contracts; Api-->Application; Infrastructure-->Application Application-->Domain Api-.->Infrastructure dotnet add Mysln.Api reference Mysln.Contracts Mysln.Application dotnet add Mysln.Infrastructure reference Mysln.Application dotnet add Mysln.Application reference Mysln.Domain dotnet add Mysln.Api reference Mysln.Infrastructure 至此，已經完成了基本的 hierarchy 建置，接下來要為 Restful Client 做準備。 Login Authentication 作為驗證的需要，我們需要以下三種驗證檔案，包含兩個 Request 與一個 Response public record RegisterRequest( string FirstName, string LastName, string Email, string Password ); public record LoginRequest( string Email, string Password ); public record AuthenticationResponse( Guid Id, string FirstName, string LastName, string Email, string token ); 到 Controller 去設置註冊與登入的兩個路由，並且將之後的服務介面預先注入到其中。 [ApiController] [Route("auth")] public class AuthenticationController : ControllerBase { [HttpPost("register")] public IActionResult Register(RegisterRequest request) { return Ok(request); } [HttpPost("login")] public IActionResult Login(LoginRequest request) { return Ok(request); } } 接著我們創建 Application 中的服務，注意到因為 Application 不依賴於 Contracts，故我們這邊需要創建自己的 DataModel public record AuthenticationResult ( Guid Id, string FirstName, string LastName, string Email, string Token ); 接著我們定義出 Application 的 Service。 public interface IAuthenticationService { AuthenticationResult Register(string firstName, string lastName, string email, string password); AuthenticationResult Login(string email, string password); } 定義好我們的 service interface 之後，就可以到 Presentation 中將我們的 service 注入到 presentation 之中。 [ApiController] [Route("auth")] public class AuthenticationController : ControllerBase { private readonly IAuthenticationService _authenticationService; public AuthenticationController(IAuthenticationService authenticationService) { _authenticationService = authenticationService; } [HttpPost("register")] public IActionResult Register(RegisterRequest request) { var authResult = _authenticationService.Register( request.FirstName, request.LastName, request.Email, request.Password); var response = new AuthenticationResponse( authResult.Id, authResult.FirstName, authResult.LastName, authResult.Email, authResult.Token); return Ok(response); } [HttpPost("login")] public IActionResult Login(LoginRequest request) { var authResult = _authenticationService.Login( request.Email, request.Password); var response = new AuthenticationResponse( authResult.Id, authResult.FirstName, authResult.LastName, authResult.Email, authResult.Token); return Ok(response); } } 我們已經定義好我們的 service 後，便可以到 presentation 的 Program(或是其它入口點，如 Startup.cs 或 MauiProgram.cs)，做 service 的依賴注入。 using BuberDinner.Application.Services.Authentication; var builder = WebApplication.CreateBuilder(args); { builder.Services.AddScoped&lt;IAuthenticationService, AuthenticationService>(); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); } var app = builder.Build(); { app.UseSwagger(); app.UseSwaggerUI(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); } 最後，我們先實作一個暫時的 Service，來確認 Api 是可以作業的。 public class AuthenticationService : IAuthenticationService { public AuthenticationResult Register(string firstName, string lastName, string email, string password) { return new AuthenticationResult( Guid.NewGuid(), firstName, lastName, email, "token" ); } public AuthenticationResult Login(string email, string password) { return new AuthenticationResult( Guid.NewGuid(), "firstName", "lastName", email, "token" ); } } 執行 dotnet run --project .\Mysln.Api\ 在 Swagger 中測試我們實作的 register 與 login API，如果正常工作，會回傳 StatusCode: 200。 Dependency Injection 我們想要每一層都可以自己管理自己的注入，此時我們需要引入 Microsoft.Extensions.DependencyInjection。 接下來實作 Application 的 DependencyInjection。 public static class DependencyInjection { public static IServiceCollection AddApllication(this IServiceCollection services) { services.AddScope&lt;IAuthenticationService, AuthenticationService>(); return services; } } 接下來實作 Infrastructure 的 DependencyInjection。(暫時還沒有注入 repository) public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services) { // 未來要注入 repositories return services; } } 接下來我們可以改寫 Program.cs。 using BuberDinner.Application; using BuberDinner.Infrastructure; var builder = WebApplication.CreateBuilder(args); { builder.Services .AddApplication() .AddInfrastructure(); builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); } var app = builder.Build(); { app.UseSwagger(); app.UseSwaggerUI(); app.UseHttpsRedirection(); app.MapControllers(); app.Run(); } 實作 JWT Token Generator 首先先在 Application Layer 創建一個 interface 來做依賴反轉 public interface IJwtTokenGenerator { string GenerateToken(Guid userId, string firstName, string lastName); } 接著我們到 Infrastructure Layer 來實作我們的 JwtTokenGenerator。 首先我們需要 System.IdentityModel.Tokens.Jwt 這個 Package。 接著我們實作 JwtTokenGenerator。 public class JwtTokenGenerator : IJwtTokenGenerator { public string GenerateToken(Guid userId, string firstName, string lastName) { var signingCredentials = new SigningCredentials( new SymmetricSecurityKey( Encoding.UTF8.GetBytes("super-secret-key")), SecurityAlgorithms.HmacSha256); var claims = new[] { new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()), new Claim(JwtRegisteredClaimNames.GivenName, firstName), new Claim(JwtRegisteredClaimNames.FamilyName, lastName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }; var securityToken = new JwtSecurityToken( issuer: "Mysln", expires: DateTime.Now.AddDays(1), claims: claims, signingCredentials: signingCredentials); return new JwtSecurityTokenHandler().WriteToken(securityToken); } } 接著我們將之注入到服務中，即大功告成了。 public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services) { services.AddSingleton&lt;IJwtTokenGenerator, JwtTokenGenerator>(); return services; } } 使用 Options Pattern 注入 JWT Settings 接下來我們要使用 Options Pattern 將 JWT Settings 注入到 JwtTokenGenerator 中。 首先我們先到 Mysln.Api 的 appsettings.json 中將 options 設置完成。 { "Logging": { "LogLevel": { "Default": "Information", "Microsoft.AspNetCore": "Warning" } }, "AllowedHosts": "*", "JwtSettings": { "Secret": "super-secret-key", "ExpiryMinutes": 60, "Issuer": "Mysln", "Audience:": "Mysln" } } 由於我們要使用 Options Pattern，我們需要改寫我們的 Program.cs，並且將 ConfigurationManager 注入到 Infrastructure 的 DependencyInjection。 為此我們需要引入套件 Microsoft.Extensions.Configuration 與 Microsoft.Extensions.Options.ConfigurationExtensions。 並且我們需要創建一個 Model。 public class JwtSettings { public const string SectionName = "JwtSettings"; public string Secret { get; init; } = null!; public int ExpiryMinutes { get; init; } public string Issuer { get; init; } = null!; public string Audience { get; init; } = null!; } Program.cs 需改寫成： builder.Services .AddApplication() .AddInfrastructure(builder.Configuration); 將 DependencyInjection 改寫成： public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration) { services.Configure&lt;JwtSettings>(configuration.GetSection(JwtSettings.SectionName)); services.AddSingleton&lt;IJwtTokenGenerator, JwtTokenGenerator>(); services.AddSingleton&lt;IDateTimeProvider, DateTimeProvider>(); return services; } } 接下來，我們可以把 JwtTokenGenerator 改寫成： public class JwtTokenGenerator : IJwtTokenGenerator { private readonly JwtSettings _jwtSettings; private readonly IDateTimeProvider _dateTimeProvider; public JwtTokenGenerator(IDateTimeProvider dateTimeProvider, IOptions&lt;JwtSettings> jwtOptions) { _dateTimeProvider = dateTimeProvider; _jwtSettings = jwtOptions.Value; } public string GenerateToken(Guid userId, string firstName, string lastName) { var signingCredentials = new SigningCredentials( new SymmetricSecurityKey( Encoding.UTF8.GetBytes(_jwtSettings.Secret)), SecurityAlgorithms.HmacSha256); var claims = new[] { new Claim(JwtRegisteredClaimNames.Sub, userId.ToString()), new Claim(JwtRegisteredClaimNames.GivenName, firstName), new Claim(JwtRegisteredClaimNames.FamilyName, lastName), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) }; var securityToken = new JwtSecurityToken( issuer: _jwtSettings.Issuer, audience: _jwtSettings.Audience, expires: _dateTimeProvider.UtcNow.AddMinutes(_jwtSettings.ExpiryMinutes), claims: claims, signingCredentials: signingCredentials); return new JwtSecurityTokenHandler().WriteToken(securityToken); } } 以上就大功告成了。 使用 dotnet user-secrets 指令 如果不想要將 Options 中的 secret 儲存在程式(appsettings.json)裡面，可以利用 dotnet user-secrets 將 secret 儲存於環境變數裡面。 透過執行以下的指令來初始化專案的 UserSecretsId dotnet user-secrets init --project Mysln.Api 接著將 UserSecretsId 綁定到我們專案的 JwtSettings:Secret。 dotnet user-secrets set --project Mysln.Api "JwtSettings:Secret" 日後可以經由以下指令查詢。 dotnet user-secrets list --project Mysln.Api Domain Model 先建立一個簡單的 Domain Model(Entity) public class User { public Guid Id { get; set; } = Guid.NewGuid(); public string FirstName { get; set; } = null!; public string LastName { get; set; } = null!; public string Email { get; set; } = null!; public string Password { get; set; } = null!; } Repository Pattern 在 Application Layer 建立 IRepository public interface IUserRepository { User? GetUserByEmail(string email); void Add(User user); } 將 IRepository 注入 Application 的 Service 並用查改存推改寫 Service public class AuthenticationService : IAuthenticationService { private readonly IJwtTokenGenerator _jwtTokenGenerator; private readonly IUserRepository _userRepository; public AuthenticationService(IJwtTokenGenerator jwtTokenGenerator, IUserRepository userRepository) { _jwtTokenGenerator = jwtTokenGenerator; _userRepository = userRepository; } public AuthenticationResult Register(string firstName, string lastName, string email, string password) { // 查 if (_userRepository.GetUserByEmail(email) is not null) { throw new Exception("User with given email already exists."); } // 改 var user = new User { FirstName = firstName, LastName = lastName, Email = email, Password = password }; // 存 _userRepository.Add(user); // 推 var token = _jwtTokenGenerator.GenerateToken(user.Id, firstName, lastName); return new AuthenticationResult(user.Id, firstName, lastName, email, token); } public AuthenticationResult Login(string email, string password) { // 查 if (_userRepository.GetUserByEmail(email) is not User user) { throw new Exception("User with given email does not exist."); } if (user.Password != password) { throw new Exception("Invalid password."); } // 改 var token = _jwtTokenGenerator.GenerateToken(user.Id, user.FirstName, user.LastName); return new AuthenticationResult(user.Id, user.FirstName, user.LastName, email, token); } } 接著我們在 Infrastructure Layer 實作我們的 repository，我們暫時先不接資料庫，所以先做一個 InMemory 版本的 repository 來做測試。 public class UserRepository : IUserRepository { private readonly List&lt;User> _users = new(); public void Add(User user) { _users.Add(user); } public User? GetUserByEmail(string email) { return _users.SingleOrDefault(u => u.Email.Equals(email)); } } 實作完需要透過 DependencyInjection 注入到我們的 Service Container 內。 public static class DependencyInjection { public static IServiceCollection AddInfrastructure(this IServiceCollection services, ConfigurationManager configuration) { services.Configure&lt;JwtSettings>(configuration.GetSection(JwtSettings.SectionName)); services.AddSingleton&lt;IJwtTokenGenerator, JwtTokenGenerator>(); services.AddSingleton&lt;IDateTimeProvider, DateTimeProvider>(); services.AddSingleton&lt;IUserRepository, UserRepository>(); return services; } } 至此，我們已經完成了一個簡單的身份認證的 API。</p></section><footer class=entry-footer>&lt;span title='2024-02-26 15:03:15 +0800 +0800'>February 26, 2024&lt;/span>&amp;nbsp;·&amp;nbsp;6 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] 使用 Clean Architecture + DDD 建置 Restful API" href=https://intervalrain.github.io/it/clean_arch_configuration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] .NET Maui</h2></header><section class=entry-content><p>.NET Maui .NET Maui 是一個跨平台的桌面與手機應用開發框架，它支援 iOS、Android、macOS、Windows。 不同於 Xamarin，.NET Maui 只需要一個專案便可以導向不同的平台。 架構 一個 .NET Maui 專案底下，預設會有幾個資料夾與檔案，其關係如下圖： /Platforms 底下的各個資料夾為不同平台的入口，不同的平台各有一個 Program.cs。 各個 Program.cs 內又會透過注入該 namespace 底下的 AppDelegate ，將入口指向 MauiProgram 的 CreateMauiApp()，就此將不同平台路由到 MauiProgram.cs 這個統一的入口。 public class Program { static void Main(string[] args) { UIApplication.Main(args, null, typeof(AppDelegate)); } } [Register("AppDelegate")] public class AppDelegate : MauiUIApplicationDelegate { protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp(); } 關係如下圖： graph TD; iOS-->MauiProgram.cs; Android-->MauiProgram.cs; Windows-->MauiProgram.cs; macOS-->MauiProgram.cs; MauiProgram.cs-->App; App-->AppShell; AppShell-.->Page1; AppShell-.->Page2; AppShell-.->Page3; AppShell-.->Page4; public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp&lt;App>() .ConfigureFonts(fonts => { fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular"); fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold"); }); return builder.Build(); } } public partial class App : Application { public App() { InitializeComponent(); MainPage = new AppShell(); } } 從上面兩段程式 MauiProgram.cs 與 App.xaml.cs 可以看出，這個統一的進入點會開啟 App，並將 AppShell 作為 MainPage 開放。 Router 在此可以發現 AppShell 作為一個 Controller 的功能，用來引導頁面的路由。 我們可以透過 RegisterRoute 來注冊要顯示的頁面。 public partial class AppShell : Shell { public AppShell() { InitializeComponent(); Routing.RegisterRoute(nameof(Page1), typeof(Page1)); Routing.RegisterRoute(nameof(Page2), typeof(Page2)); Routing.RegisterRoute(nameof(Page3), typeof(Page3)); } } xaml 上述的頁面可以透過新增 xaml 檔來建立： 以下為一個 xaml 檔的 sample x:class="MoneyTrack.AppShell" 表示該檔案的路徑為 MoneyTrack.AppShell mlns 關鍵字很像是 using： xmlns:views="clr-namespace:MoneyTrack.Views": 代表將 MoneyTrack.Views 這個路徑命名成 views。 ShellContent 內代表是首頁要導引至的頁面，如下例會導向 view:MoneyTackPage &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;Shell x:Class="MoneyTrack.AppShell" xmlns="http://schemas.microsoft.com/dotnet/2021/maui" xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" xmlns:local="clr-namespace:MoneyTrack" xmlns:views="clr-namespace:MoneyTrack.Views" Shell.FlyoutBehavior="Disabled" Title="MoneyTrack"> &lt;ShellContent Title="Home" ContentTemplate="{DataTemplate views:MoneyTackPage}" Route="MoneyTackPage" /> &lt;/Shell> &lt;?xml version="1.0" encoding="utf-8" ?> &lt;ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui" xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" x:Class="MoneyTrack.Views.ContactsPage" Title="Contacts"> &lt;VerticalStackLayout Spacing="5"> &lt;Label Text="Welcome to .NET MAUI!" VerticalOptions="Center" HorizontalOptions="Center" /> &lt;Button x:Name="btn1" Clicked="btn1_Clicked" Text="click1">&lt;/Button> &lt;Button x:Name="btn2" Clicked="btn2_Clicked" Text="click2">&lt;/Button> &lt;/VerticalStackLayout> &lt;/ContentPage> Shell 接著我們可以透過 Shell 來控制面版上要顯示的頁面： public void btnPage1_Clicked() { Shell.Current.GoToAsync(nameof(Page1)); } GoToAsync Shell 本身是一個 View，也是一個 Layout GoToAsync 可以用來切換頁面 void btnPage1_Clicked(object sender, EvertArgs e) { Shell.Current.GoToAsync($"{nameof(Page1)}"); // 前往 Page1 } void btnCancel_Clicked(object sender, EvertArgs e) { Shell.Current.GoToAsync($"//{nameof(MainPage)}"); // 回到 MainPage } void btnCancel_Clicked(object sender, EvertArgs e) { Shell.Current.GoToAsync($".."); // 回到上一頁 } QueryProperty 透過 QueryPropertyAttribute 可以達到如 http method 裡的 get 的方法。 以下範例等同於實現 page1?Id=1，在路由到 page1 的同時，將 property: Id 賦值。 [QueryProperty(nameof(PageId), "Id")] public partial class Page1 : ContentPage { public EditContactPage() { InitializeComponent(); } public string ContactId { set { lblName.Text = Id; } } }</p></section><footer class=entry-footer>&lt;span title='2024-01-28 13:30:34 +0800 +0800'>January 28, 2024&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] .NET Maui" href=https://intervalrain.github.io/it/maui/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] CORS 跨原始來源要求</h2></header><section class=entry-content><p>TL;DR CORS (Cross-Origin Resource Sharing)
是一個支援安全跨源請求和資料傳輸的機制，用於在瀏覽器和伺服器之間進行跨源請求。
這是一個 W3C 標準，可讓伺服器放寬相同原始來源原則。 不是安全性功能，CORS 會放寬安全性。 允許 CORS 並不會增強 API 的安全性。CORS 的運作方式 允許伺服器明確允許某些跨原始來源要求，同時拒絕其他要求。 比舊版技術 (例如：JSONP) 更安全且更有彈性。 何謂相同原始來源 如果兩個 URL 具有相同的配置、主機和連接埠，則其原始來源相同 (RFC 6454)。 這兩個 URL 具有相同的原始來源： https://example.com/foo.html https://example.com/bar.html 這些 URL 的原始來源與前兩個 URL 不同： https://example.net：不同的網域 https://www.example.com/foo.html：不同的子網域 http://example.com/foo.html：不同的配置 https://example.com:9000/foo.html：不同的連接埠 如何啟動 CORS 有三種方式可以啟用 CORS：
在中介軟體中，使用具名原則或預設原則。 使用端點路由。 使用 [EnableCors] 屬性。 搭配具名原則使用 [EnableCors] 屬性能夠以最精細的程度來控制對於支援 CORS 之端點的限制。 ...</p></section><footer class=entry-footer>&lt;span title='2024-01-19 00:41:51 +0800 +0800'>January 19, 2024&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] CORS 跨原始來源要求" href=https://intervalrain.github.io/it/cors/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] LINQ: IQueryable Provider</h2></header><section class=entry-content><p>可重複使用的 IQueryable 基類 IQueryable 簡介 在 C# 最新版本中的 IQueryable 已經不再是一個介面，而是分為兩個部分： IQueryable 與 IQueryProvider。在開始實作之前，我們必須先了解一下這兩個介面。
public interface IQuerable : IEnumerable { Type ElementType { get; } Expression Expression { get; } IQueryProvider Provider { get; } } public interface IQueryable&lt;T> : IEnumerable&lt;T>, IQueryable, IEnumerable { } IQueryable 有三個唯讀屬性：
ElementType 代表了元素的類型 (或等於 IQueryable&lt;T> 中的 T) Expression 代表了查詢對應的表達式。這是 IQueryable 存在的核心要素。在 IQueryable 的內部，實際上是一個表示查詢的表達式，它將查詢表示為 LINQ 查詢運算子/方法調用的樹狀結構。如果進一步看，你會發現，IQueryable 或是 Queryable 都只是在提供一個自動構建表達式樹節點 (expression tree nodes) 的機制。當我們對 IQeuryable 使用 Where 方法時，它只是回傳一個新的 IQueryable，並且在進行調用的樹頂添加一個方法表達式樹節點。 Provider 作為真正的「提供者」，它負責原先所有 IQueryable 的執行方法。 IQueryProvider 簡介 public interface IQueryProvider { IQueryable CreateQuery(Expression expression); IQueryable&lt;TElement> CreateQuery&lt;TElement>(Expression expression); object Execute(Expression expression); TResult Execute&lt;TResult>(Expression expression); } 當我們進一步觀察 IQueryProvider，會發現它事實上只有兩個操作：CreateQuery、Execute，只是各有一個泛型與非泛型的方法。一般我們會使用泛型的方法，因為它可以避免使用反射來建構實例，從而提高性能。
...</p></section><footer class=entry-footer>&lt;span title='2023-09-21 11:34:15 +0800 +0800'>September 21, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;19 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] LINQ: IQueryable Provider" href=https://intervalrain.github.io/it/iq1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[C#] Large Object Heap</h2></header><section class=entry-content><p>LOH(Large Object Heap) GC .NET 具有 GC(garbage collector)，使開發員不需要過多考慮記憶體控管，因為 GC 會自動移除「死掉的」物件，並將記憶體重排。 這些小的物件會透過釋放死的物件，並移動集合中存活的物件，以確保沒有間隙。（事實上並非原地移動，而是將之全部複製到新的記憶體區塊，這樣可以簡化分配記憶體的過程，這樣意味著，空間都會出現在區塊的尾端，所以不需要進行掃描來找尋記憶體區塊來儲存新的物件。 LOH LOH(Large Object Heap) 指的是大型物件堆，也就是大小超過 85000 bytes 的物件，GC 會將之視為獨立的部分，GC 會優先處理其它的堆，原因是若要透過複製移動的方法來重新分配 LOH，它們需要兩倍的記憶體來進行，會使得 GC 花費大量的時間進行任務。 取而代之，GC 不會移動 LOH，而是將之留在原地，使得空間變得碎片化(fragmented)。當移除 LOH 時，會將空間原地保留，當要放入新的物件時，若區塊的尾端沒有足夠的空間，則會在這些 LOH 之間的空洞找尋可用空間，在沒有足夠空間時，擴展堆。 隨著時間堆移，即使不會發生 memory leakage，由於 LOH 之間的碎片空間會愈來愈小，不足以放置新的物件。在最糟的狀況下，這些碎片空間佔有的空間很大，但又不足以放置新的物件，且碎片的個數很多，這可能就會導致更多的產生 OutOfMemoryException。 如何解決 防止或減少使用大型物件的需求。 定期停止或重啟受影響的應用程式。 將大型物件重構成不同的數據結構，如 100000 個元素的數組，儲存成 10 個 10000 個元素的數組。 System.Collections 中也有一個 Capacity 的屬性來促進這種設計模式來避免大型物件的產生，有效的共享大型數據結構也有助於減少大型物件。 Reference: Andrew Hunter - The Dangers of the Large Object Heap
Reference: Microsoft - The large object heap on Windows systems
...</p></section><footer class=entry-footer>&lt;span title='2023-07-22 20:59:57 +0800 +0800'>July 22, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C#] Large Object Heap" href=https://intervalrain.github.io/csharp/loh/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[CS] Sample cost for performance test</h2></header><section class=entry-content><p>Sample code for stop watch using System; using System.Collections.Generic; using System.Data; using System.Linq; using System.Runtime.CompilerServices; using System.Data.Common; using System.Diagnostics; using System.Drawing; using System.Text; using System.Threading.Tasks; namespace Rainspace.PlayGround { public class Program { public static void Main(string[] args) { Stopwatch sw = new Stopwatch(); sw.Start(); System.Console.WriteLine("==============Accumulate1=============="); System.Console.WriteLine("Result: " + Accumulate(0, 100, 0)); sw.Stop(); System.Console.WriteLine("Time cost: " + (sw.ElapsedTicks/1.0e6).ToString() + "ms"); sw.Reset(); sw.Start(); System.Console.WriteLine("==============Accumulate2=============="); System.Console.WriteLine("Result: " + Accumulate(0, 100, 0)); sw.Stop(); System.Console.WriteLine("Time cost: " + (sw.ElapsedTicks/1.0e6).ToString() + "ms"); } public static int Accumulate(int begin, int end, int sum = 0) { int res = sum; if (end &lt; begin) return Accumulate(end, begin, sum); for (int i = begin; i &lt; end; i++) { res += i; } return res; } public static int Accumulate2(int begin, int end, int sum = 0) { int res = (begin + end) * (end - begin) / 2; return res + sum; } } }</p></section><footer class=entry-footer>&lt;span title='2023-05-16 21:26:24 +0800 +0800'>May 16, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [CS] Sample cost for performance test" href=https://intervalrain.github.io/csharp/performancetest/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://intervalrain.github.io/tags/c%23/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>