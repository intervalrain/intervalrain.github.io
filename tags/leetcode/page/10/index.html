<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leetcode | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/tags/leetcode/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/tags/leetcode/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/tags/leetcode/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/tags/leetcode/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="Leetcode"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Leetcode"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/tags/>Tags</a></div><h1>Leetcode</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1706. Where Will the Ball Fall</h2></header><div class=entry-content><p>1706. Where Will the Ball Fall
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Depth-First Search、Matrix、Simulation 一、題目 You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.
Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.
A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1. A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.
We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball get stuck if it hits a “V” shaped pattern between two boards or if a board redirects the ball into either wall of the box.
Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box. Example 1:
...</p></div><footer class=entry-footer><span title='2022-11-01 19:02:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1706. Where Will the Ball Fall" href=https://intervalrain.github.io/leetcode/1706/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1695. Maximum Erasure Value</h2></header><div class=entry-content><p>套不定長的 Sliding Window pattern class IWindow { public: virtual void add(int& num) = 0; virtual void erase(int& num) = 0; virtual bool check(int& num) = 0; virtual int sum() = 0; virtual ~IWindow() {} }; class Window: public IWindow { private: unordered_map&lt;int,int> _cnt; int curr = 0; public: void add(int& num) override { curr += num; _cnt[num]++; } void erase(int& num) override { curr -= num; _cnt[num]--; } bool check(int& num) override { return _cnt[num] == 1; } int sum() override { return curr; } }; class Solution { private: unique_ptr&lt;IWindow> _w; public: Solution(): _w(make_unique&lt;Window>()) {} int maximumUniqueSubarray(vector&lt;int>& nums) { int n = nums.size(); int left = 0, right = 0; int res = 0; unordered_map&lt;int,int> map; while (right &lt; n) { int num = nums[right++]; while (_w->check(num)) { _w->erase(nums[left++]); } _w->add(num); res = max(res, _w->sum()); } return res; } }; 不囉嗦版 class Solution { public: int maximumUniqueSubarray(vector&lt;int>& nums) { int n = nums.size(); int left = 0, right = 0; int res = 0; int curr = 0; unordered_map&lt;int,int> map; while (right &lt; n) { int num = nums[right++]; while (map[num] == 1) { int num2 = nums[left++]; map[num2]--; curr -= num2; } map[num]++; curr += num; res = max(res, curr); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 19:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1695. Maximum Erasure Value" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1695/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 904. Fruit Into Baskets</h2></header><div class=entry-content><p>套不定長的 Sliding Window pattern class IWindow { public: virtual void add(int& num) = 0; virtual void erase(int& num) = 0; virtual bool check(int& num) = 0; virtual ~IWindow() {} }; class Window: public IWindow { private: int _types; unordered_map&lt;int,int> _map; int _curr; public: Window(int types): _types(types) { _curr = 0; } void add(int& num) override { if (_map[num]++ == 0) { _curr++; } } void erase(int& num) override { if (--_map[num] == 0) { _map.erase(num); _curr--; } } bool check(int& num) override { return !_map.count(num) && _curr == _types; } }; class Solution { private: unique_ptr&lt;IWindow> _w; public: Solution(): _w(make_unique&lt;Window>(2)) {} int totalFruit(vector&lt;int>& fruits) { int n = fruits.size(); int left = 0; int right = 0; int res = 0; while (right &lt; n) { int num = fruits[right++]; while (_w->check(num)) _w->erase(fruits[left++]); _w->add(num); res = max(res, right-left); } return res; } }; 不囉嗦版 class Solution { public: int totalFruit(vector&lt;int>& fruits) { int n = fruits.size(); int left = 0, right = 0; int res = 0; int curr = 0; unordered_map&lt;int,int> map; while (right &lt; n) { int num = fruits[right++]; while (curr == 2 && !map.count(num)) { int num2 = fruits[left++]; if (--map[num2] == 0) { map.erase(num2); curr--; } } if (map[num]++ == 0) { curr++; } res = max(res, right-left); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 18:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 904. Fruit Into Baskets" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/904/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2730. Find the Longest Semi-Repetitive Substring</h2></header><div class=entry-content><p>先將 s 轉成 prefix 再套不定長的 Sliding Window 套 pattern class Solution { public: int longestSemiRepetitiveSubstring(string s) { int n = s.size(); auto trans = [&](string& s) -> vector&lt;int> { vector&lt;int> res{0}; for (int i = 1; i &lt; n; i++) { res.push_back(s[i-1] == s[i] ? res.back() + 1 : res.back()); } return res; }; auto nums = trans(s); int left = 0, right = 0, res = 0; while (right &lt; n) { int num = nums[right++]; while (num - nums[left] > 1) left++; res = max(res, right-left); } return res; } }; 不用先轉直接處理 class Solution { public: int longestSemiRepetitiveSubstring(string s) { int n = s.size(); auto check = [&](int i) -> bool { if (i == 0) return false; return s[i] == s[i-1]; }; int left = 0, right = 0, res = 0; int curr = 0; while (right &lt; n) { if (check(right++)) curr++; while (curr > 1) { if (check(++left)) curr--; } res = max(res, right-left); } return res; } }; 左指針快進版 class Solution { public: int longestSemiRepetitiveSubstring(string s) { int n = s.size(); auto check = [&](int i) -> bool { if (i == 0) return false; return s[i] == s[i-1]; }; int left = 0, right = 0, res = 0; int last = 0; while (right &lt; n) { bool flag = check(right++); if (flag) { left = last; last = right-1; } res = max(res, right-left); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 17:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2730. Find the Longest Semi-Repetitive Substring" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2730/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1208. Get Equal Substrings Within Budget</h2></header><div class=entry-content><p>不定長的 Sliding Window 套 pattern class IWindow { public: virtual void add(int num) = 0; virtual void erase(int num) = 0; virtual bool check() = 0; virtual ~IWindow() {} }; class Window: public IWindow { private: int _maxCost; int _curr = 0; public: Window(int maxCost): _maxCost(maxCost) {} void add(int num) override { _curr += num; } void erase(int num) override { _curr -= num; } bool check() override { return _curr > _maxCost; } }; class Solution { private: unique_ptr&lt;IWindow> _w; public: int equalSubstring(string s, string t, int maxCost) { auto nums = [&](int i) -> int { return abs(s[i] - t[i]); }; _w = make_unique&lt;Window>(maxCost); int n = s.size(), left = 0, right = 0; int res = 0; while (right &lt; n) { _w->add(nums(right++)); while (_w->check()) _w->erase(nums(left++)); res = max(res, right - left); } return res; } }; 簡易版 class Solution { public: int equalSubstring(string s, string t, int maxCost) { int curr = 0; int n = s.size(), left = 0, right = 0; int res = 0; while (right &lt; n) { curr += abs(s[right] - t[right]); right++; while (curr > maxCost) { curr -= abs(s[left] - t[left]); left++; } res = max(res, right - left); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 16:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1208. Get Equal Substrings Within Budget" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1208/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1493. Longest Subarray of 1's After Deleting One Element</h2></header><div class=entry-content><p>不定長的 Sliding Window 套 pattern class IWindow { public: virtual void add(int& num) = 0; virtual void erase(int& num) = 0; virtual bool check(int& num) = 0; virtual ~IWindow() {} }; class Window : public IWindow { private: int cnt = 0; public: Window() {} void add(int& num) override { if (num == 0) cnt++; } void erase(int& num) override { if (num == 0) cnt--; } bool check(int& num) override { return num == 0 && cnt == 1; } }; class Solution { private: unique_ptr&lt;IWindow> _w; public: Solution(): _w(make_unique&lt;Window>()) {} int longestSubarray(vector&lt;int>& nums) { int n = nums.size(), left = 0, right = 0; int res = 0; while (right &lt; n) { int num = nums[right++]; while (_w->check(num)) _w->erase(nums[left++]); _w->add(num); res = max(res, right-left-1); } return res; } }; 但其實在 check & 移動左指標這一步可以做優化，左指標可以透過記錄一下一個合法的位置來快速移動。 class Solution { private: int last = 0; public: int longestSubarray(vector&lt;int>& nums) { int n = nums.size(), left = 0, right = 0; int res = 0; while (right &lt; n) { int num = nums[right++]; if (num == 0) { left = last; last = right; } res = max(res, right-left-1); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 15:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1493. Longest Subarray of 1's After Deleting One Element" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1493/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 3. Longest Substring Without Repeating Characters</h2></header><div class=entry-content><p>不定長的 Sliding Window 的 pattern 如下 class Window { public: virtual void add(int num) = 0; virtual void erase(int num) = 0; virtual bool find(int num) = 0; virtual ~Window() {} }; class Bucket : public Window { private:c int _bucketSize; int _valueDiff; int index(int num) { return num &lt; 0 ? (num - _valueDiff) / _bucketSize : num / _bucketSize; } unordered_map&lt;int,int> _map; public: Bucket(int valueDiff): _valueDiff(valueDiff), _bucketSize(valueDiff + 1) {} void add(int num) override { int idx = index(num); _map[idx] = num; } void erase(int num) override { int idx = index(num); _map.erase(idx); } bool find(int num) override { int idx = index(num); return _map.count(idx) || (_map.count(idx-1) && num - _map[idx-1] &lt;= _valueDiff) || (_map.count(idx+1) && _map[idx+1] - num &lt;= _valueDiff); } }; class Solution { private: unique_ptr&lt;Window> _w; public: bool containsNearbyAlmostDuplicate(vector&lt;int>& nums, int indexDiff, int valueDiff) { int n = nums.size(); int k = indexDiff + 1; _w = make_unique&lt;Bucket>(valueDiff); for (int i = 0; i &lt; k && i &lt; n; i++) { if (_w->find(nums[i])) return true; _w->add(nums[i]); } for (int i = k; i &lt; n; i++) { _w->erase(nums[i-k]); if (_w->find(nums[i])) return true; _w->add(nums[i]); } return false; } }; 沒有抽象化的 code class Solution { public: bool containsNearbyAlmostDuplicate(vector&lt;int>& nums, int k, int t) { int n = nums.size(); unordered_map&lt;int,int> map; k++; for (int i = 0; i &lt; n; i++) { int idxin = nums[i] / (t+1); if (nums[i] &lt; 0) idxin--; if (i >= k) { int idxout = nums[i-k] / (t+1); if (nums[i-k] &lt; 0) idxout--; map.erase(idxout); } if (map.count(idxin) || (map.count(idxin-1) && nums[i] - map[idxin-1] &lt;= t) || (map.count(idxin+1) && map[idxin+1] - nums[i] &lt;= t)) return true; map[idxin] = nums[i]; } return false; } };</p></div><footer class=entry-footer><span title='2022-11-01 14:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 3. Longest Substring Without Repeating Characters" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 3090. Maximum Length Substring With Two Occurrences</h2></header><div class=entry-content><p>不定長的 Sliding Window 套 pattern class IWindow { public: virtual void add(char& c) = 0; virtual void erase(char& c) = 0; virtual bool check(char& c) = 0; virtual ~IWindow() {} }; class Window: public IWindow{ private: int cnt[26]; public: Window() { memset(cnt, 0, sizeof(cnt)); } void add(char& c) override { cnt[c-'a']++; } void erase(char& c) override { cnt[c-'a']--; } bool check(char& c) override { return cnt[c-'a'] == 2; } }; class Solution { private: unique_ptr&lt;IWindow> _w; public: Solution(): _w(make_unique&lt;Window>()) {} int maximumLengthSubstring(string s) { int n = s.size(), left = 0, right = 0; int res = 0; while (right &lt; n) { char c = s[right++]; while (_w->check(c)) _w->erase(s[left++]); _w->add(c); res = max(res, right-left); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 14:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 3090. Maximum Length Substring With Two Occurrences" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/3090/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 不定長 Sliding Window Pattern</h2></header><div class=entry-content><p>不定長度的 sliding window pattern 步驟 move sliding window
(1) 滑動左指標直到 window 有效 (2) 加入右指標 (3) 更新 class Window { public: virtual void add(int num) = 0; virtual void erase(int num) = 0; virtual bool check(int num) = 0; virtual ~Window() {} }; class Solution { private: unique_ptr&lt;Window> _w; public: Solution(): _w() {} int solve(vector&lt;int>& nums, int k) { _w = make_unique&lt;WindowImpl>(k); int len = 0; int n = nums.size(), left = 0, right = 0; while (right &lt; n) { int num = nums[right++]; while (_w->check(num)) _w->erase(nums[left++]); _w->add(num); res = max(res, right-left); } return len; } };</p></div><footer class=entry-footer><span title='2022-11-01 14:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 不定長 Sliding Window Pattern" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/pattern_2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 220. Contains Duplicate III</h2></header><div class=entry-content><p>這是一題是很有趣的一題，會用到 bucket sort 結合 sliding window，時間複雜度是 \(O(n)\) 我把 sliding window 的部分拆分開來，讓邏輯更清楚。 class Window { public: virtual void add(int num) = 0; virtual void erase(int num) = 0; virtual bool find(int num) = 0; virtual ~Window() {} }; class Bucket : public Window { private:c int _bucketSize; int _valueDiff; int index(int num) { return num &lt; 0 ? (num - _valueDiff) / _bucketSize : num / _bucketSize; } unordered_map&lt;int,int> _map; public: Bucket(int valueDiff): _valueDiff(valueDiff), _bucketSize(valueDiff + 1) {} void add(int num) override { int idx = index(num); _map[idx] = num; } void erase(int num) override { int idx = index(num); _map.erase(idx); } bool find(int num) override { int idx = index(num); return _map.count(idx) || (_map.count(idx-1) && num - _map[idx-1] &lt;= _valueDiff) || (_map.count(idx+1) && _map[idx+1] - num &lt;= _valueDiff); } }; class Solution { private: unique_ptr&lt;Window> _w; public: bool containsNearbyAlmostDuplicate(vector&lt;int>& nums, int indexDiff, int valueDiff) { int n = nums.size(); int k = indexDiff + 1; _w = make_unique&lt;Bucket>(valueDiff); for (int i = 0; i &lt; k && i &lt; n; i++) { if (_w->find(nums[i])) return true; _w->add(nums[i]); } for (int i = k; i &lt; n; i++) { _w->erase(nums[i-k]); if (_w->find(nums[i])) return true; _w->add(nums[i]); } return false; } }; 沒有抽象化的 code class Solution { public: bool containsNearbyAlmostDuplicate(vector&lt;int>& nums, int k, int t) { int n = nums.size(); unordered_map&lt;int,int> map; k++; for (int i = 0; i &lt; n; i++) { int idxin = nums[i] / (t+1); if (nums[i] &lt; 0) idxin--; if (i >= k) { int idxout = nums[i-k] / (t+1); if (nums[i-k] &lt; 0) idxout--; map.erase(idxout); } if (map.count(idxin) || (map.count(idxin-1) && nums[i] - map[idxin-1] &lt;= t) || (map.count(idxin+1) && map[idxin+1] - nums[i] &lt;= t)) return true; map[idxin] = nums[i]; } return false; } };</p></div><footer class=entry-footer><span title='2022-11-01 13:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 220. Contains Duplicate III" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/220/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/tags/leetcode/page/9/>«&nbsp;上一頁&nbsp;
</a><a class=next href=https://intervalrain.github.io/tags/leetcode/page/11/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>