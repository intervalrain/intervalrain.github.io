<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leetcode | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/tags/leetcode/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/tags/leetcode/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/tags/leetcode/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/tags/leetcode/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="Leetcode"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Leetcode"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/tags/>Tags</a></div><h1>Leetcode</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 766. Toeplitz Matrix</h2></header><div class=entry-content><p>766. Toeplitz Matrix
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Matrix 一、題目 Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.
Example 1:
Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation:
In the above grid, the diagonals are:
“[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”.
In each diagonal all elements are the same, so the answer is True. Example 2: ...</p></div><footer class=entry-footer><span title='2022-11-01 00:40:55 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 766. Toeplitz Matrix" href=https://intervalrain.github.io/leetcode/766/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1016. Binary String With Substrings Representing 1 To N</h2></header><div class=entry-content><p>這一題是滿有趣的一題，我的靈感來自於 zkw 的線段樹(但沒有用到線段樹)。 觀察 1 ~ n 的樹，並將它排成 zkw 的線段樹，可以發現以下規則： 滿足樹的子葉，則必定可以滿足其父節點，例如：找到 "1010"，則可以滿足 "101"、"10"、"1"。 所以可以得到一個數學結論是：我們只需要找到 n ~ n/2+1 的數即可。 [1] len = 1 [10] 11 len = 2 100 [101] 110 111 len = 3 1000 1001 [1010] 1011 1100 1101 1110 1111 len = 4 (8) num mask ^ 1&lt;&lt;3 solution: class Solution { public: bool queryString(string s, int n) { if (n > 1979) return false; // 剪枝：當 n 太大時必為 false, 證明在下面 int len = 32 - __builtin_clz(n); // n 的位元長度 if (s.size() &lt; len) return false; // s 長度連 window 都不夠時 return false int mask = (1 &lt;&lt; len) - 1; // 遮罩 用來控制 window 長度 unordered_set&lt;int> seen; // 用來記錄數字是否出現過 int valid = n - n/2; // 總共需要收集到的數目 // init int curr = 0; for (int i = 0; i &lt; len; i++) { curr = ((curr &lt;&lt; 1) | (s[i] & 1)); if (curr &lt;= n && curr > n/2) seen.insert(curr); if (seen.size() == valid) return true; } // rolling for (int i = len; i &lt; s.size(); i++) { curr = ((curr &lt;&lt; 1) | (s[i] & 1)) & mask; if (curr &lt;= n && curr > n/2) seen.insert(curr); if (seen.size() == valid) return true; } return false; } }; 剪枝的證明： 我來說明 1979 這個臨界值的計算過程： 當字串長度 = 1000 時，我們需要找到滿足以下條件的最大 n：
...</p></div><footer class=entry-footer><span title='2022-10-31 12:00:00 +0800 +0800'>October 31, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1016. Binary String With Substrings Representing 1 To N" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1016/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 19. Remove Nth Node From End of List</h2></header><div class=entry-content><p>19. Remove Nth Node From End of List
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Two Pointers 一、題目 Given the head of a linked list, remove the nth node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Example 3:
Input: head = [1,2], n = 1 Output: [1] Constraints:
...</p></div><footer class=entry-footer><span title='2022-10-31 00:05:10 +0800 +0800'>October 31, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 19. Remove Nth Node From End of List" href=https://intervalrain.github.io/leetcode/19/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination</h2></header><div class=entry-content><p>1293. Shortest Path in a Grid with Obstacles Elimination
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.
Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.
...</p></div><footer class=entry-footer><span title='2022-10-30 21:29:37 +0800 +0800'>October 30, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination" href=https://intervalrain.github.io/leetcode/1293/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2953. Count Complete Substrings</h2></header><div class=entry-content><p>難度分: 2449 這題是一個定長的 sliding window，比較難想的是 window size 是 k * 1, k * 2, … 到 k * 26，因為只有 26 個英文字母，所以最多只可能到 26 * k 的長度。 額外需要檢查相鄰的字母是否距離 &lt;= 2，我使用的方法是找到一個 j 記錄最大的不符合的索引值，所以直要 window 不包含該 j，window 內的所字元都會滿足。 所以 pesudo code 會是 for (int c = 1; c &lt;= 26; i++) { // window size int windowSize = c * k; // construct window for (int i = 0; i &lt; windowSize; i++) { // 處理 j // 計算進入 window } // 確認初始的 window 是否滿足 // rolling windo for (int i = windowSize; i &lt; n; i++) { // 處理 j // 計算進入 window // 計算離開 window // 確認 window 是否滿足 } } class Solution { public: int countCompleteSubstrings(string s, int k) { int n = s.size(); int res = 0; for (int idx = 1; idx &lt;= 26 && idx * k &lt;= n; idx++) { int len = idx * k; int j = -1; vector&lt;int> cnt(26, 0); int valid = 0; for (int i = 0; i &lt; len; i++) { if (i > 0 && abs(s[i] - s[i-1]) > 2) { j = i-1; } if (++cnt[s[i]-'a'] == k) valid++; } if (valid == idx && j &lt; 0) { res++; } for (int i = len; i &lt; n; i++) { if (abs(s[i] - s[i-1]) > 2) { j = i-1; } if (++cnt[s[i]-'a'] == k) valid++; if (cnt[s[i-len]-'a']-- == k) valid--; if (valid == idx && i-len >= j) { res++; } } } return res; } };</p></div><footer class=entry-footer><span title='2022-10-30 12:00:00 +0800 +0800'>October 30, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2953. Count Complete Substrings" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2953/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2136. Earliest Possible Day of Full Bloom</h2></header><div class=entry-content><p>2136. Earliest Possible Day of Full Bloom
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed take time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:
plantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total. growTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever. From the beginning of day 0, you can plant the seeds in any order.
Return the earliest possible day where all seeds are blooming. Example 1:
...</p></div><footer class=entry-footer><span title='2022-10-30 00:25:25 +0800 +0800'>October 30, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2136. Earliest Possible Day of Full Bloom" href=https://intervalrain.github.io/leetcode/2136/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2156. Find Substring With Given Hash Value</h2></header><div class=entry-content><p>難度分: 2063
這題是 rolling hash，同樣樣到 sliding window 的概念，由左至右需要處理除法問題，會使問題的難度增加，所以這題逆其道而行，從右至左，那就可以把除法問題變成乘法問題了。
在處理商數時，要小心處理負數，由於商數 d 必定介於 0~k之間，可以利用 $$ \boxed{\mod(\mod(a)-\mod(b)+k)} $$
證明： $$ \boxed{ \begin{array}{ll} 0\le\mod(a)&lt;k \\ 0\le\mod(b)&lt;k \\ -k&lt;\mod(a)-\mod(b)&lt;k & 在取 \mod 前先整理成正數\\ 0&lt;\mod(a)-\mod(b)+k&lt; 2k \\ 0&lt;\mod(\mod(a)-\mod(b)+k) &lt; k \end{array} } $$ 令 str = dcba，k = 3，已知 curr = mod(ap^2+bp+c, m) 求 mod(bp^2+cp+d, m)
\(\mod(bp^2+cp+d)\) \(\quad = \mod((ap^2+bp+c)\times p +d-ax^3)\) \(\quad = \mod(\mod(ap^2+bp+c)\times p +d+m-\mod(ax^3))\) \(\quad = \mod(\text{curr}\times p +d+m-\mod(ax^3))\) class Solution { public: string subStrHash(string s, int p, int mod, int k, int val) { int n = s.size(); long pk = 1, curr = 0; for (int i = 0; i &lt; k; i++) { curr = (curr * p + (s[n-1-i]-'a'+1)) % mod; pk = (pk * p) % mod; } int j = n-k; for (int i = k; i &lt; n; i++) { curr = (curr * p + (s[n-1-i]-'a'+1) + mod - ((s[n-1-i+k]-'a'+1) * pk) % mod) % mod; if (curr == val) j = n-1-i; } return s.substr(j, k); } };</p></div><footer class=entry-footer><span title='2022-10-29 12:00:00 +0800 +0800'>October 29, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2156. Find Substring With Given Hash Value" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2156/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 18. 4Sum</h2></header><div class=entry-content><p>18. 4Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
0 &lt;= a, b, c, d &lt; n a, b, c and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Example 1:
Input: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2:
...</p></div><footer class=entry-footer><span title='2022-10-28 23:58:48 +0800 +0800'>October 28, 2022</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 18. 4Sum" href=https://intervalrain.github.io/leetcode/18/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 17. Letter Combinations of a Phone Number</h2></header><div class=entry-content><p>17. Letter Combinations of a Phone Number
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table,String,Backtracking 一、題目 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = “23” Output: [“ad”,“ae”,“af”,“bd”,“be”,“bf”,“cd”,“ce”,“cf”] Example 2:
...</p></div><footer class=entry-footer><span title='2022-10-28 22:59:22 +0800 +0800'>October 28, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 17. Letter Combinations of a Phone Number" href=https://intervalrain.github.io/leetcode/17/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 16. 3Sum Closet</h2></header><div class=entry-content><p>no. &lt;/strong>
&lt;ul> &lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li> &lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Two Pointers&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li> &lt;/ul> &lt;hr> &lt;h3 id="一題目">一、題目&lt;/h3> &lt;p>Given an integer array &lt;code>nums&lt;/code> of length &lt;code>n&lt;/code> and an integer &lt;code>target&lt;/code>, find three integers in &lt;code>nums&lt;/code> such that the sum is closet to &lt;code>target&lt;/code>.
Return *the sum of the three integers`.
You may assume that each input would have exactly one solution.
&lt;p>&lt;strong>Example 1:&lt;/strong>
&lt;ul> &lt;li>&lt;strong>Input:&lt;/strong> nums = [-1,2,1,-4], target = 1&lt;/li> &lt;li>&lt;strong>Output:&lt;/strong> 2&lt;/li> &lt;li>&lt;strong>Explanation:&lt;/strong> The sum that is closet to the target is 2. (-1 + 2 + 1 = 2).&lt;/li> &lt;/ul> &lt;p>&lt;strong>Example 2:&lt;/strong>
...</p></div><footer class=entry-footer><span title='2022-10-28 21:51:20 +0800 +0800'>October 28, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 16. 3Sum Closet" href=https://intervalrain.github.io/leetcode/16/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/tags/leetcode/page/10/>«&nbsp;上一頁&nbsp;
</a><a class=next href=https://intervalrain.github.io/tags/leetcode/page/12/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>