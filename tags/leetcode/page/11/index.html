<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leetcode | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/tags/leetcode/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/tags/leetcode/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/tags/leetcode/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/tags/leetcode/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="Leetcode"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Leetcode"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/tags/>Tags</a></div><h1>Leetcode</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 3. Longest Substring Without Repeating Characters</h2></header><div class=entry-content><p>不定長的 Sliding Window 的 pattern 如下 class Window { public: virtual void add(int num) = 0; virtual void erase(int num) = 0; virtual bool find(int num) = 0; virtual ~Window() {} }; class Bucket : public Window { private:c int _bucketSize; int _valueDiff; int index(int num) { return num &lt; 0 ? (num - _valueDiff) / _bucketSize : num / _bucketSize; } unordered_map&lt;int,int> _map; public: Bucket(int valueDiff): _valueDiff(valueDiff), _bucketSize(valueDiff + 1) {} void add(int num) override { int idx = index(num); _map[idx] = num; } void erase(int num) override { int idx = index(num); _map.erase(idx); } bool find(int num) override { int idx = index(num); return _map.count(idx) || (_map.count(idx-1) && num - _map[idx-1] &lt;= _valueDiff) || (_map.count(idx+1) && _map[idx+1] - num &lt;= _valueDiff); } }; class Solution { private: unique_ptr&lt;Window> _w; public: bool containsNearbyAlmostDuplicate(vector&lt;int>& nums, int indexDiff, int valueDiff) { int n = nums.size(); int k = indexDiff + 1; _w = make_unique&lt;Bucket>(valueDiff); for (int i = 0; i &lt; k && i &lt; n; i++) { if (_w->find(nums[i])) return true; _w->add(nums[i]); } for (int i = k; i &lt; n; i++) { _w->erase(nums[i-k]); if (_w->find(nums[i])) return true; _w->add(nums[i]); } return false; } }; 沒有抽象化的 code class Solution { public: bool containsNearbyAlmostDuplicate(vector&lt;int>& nums, int k, int t) { int n = nums.size(); unordered_map&lt;int,int> map; k++; for (int i = 0; i &lt; n; i++) { int idxin = nums[i] / (t+1); if (nums[i] &lt; 0) idxin--; if (i >= k) { int idxout = nums[i-k] / (t+1); if (nums[i-k] &lt; 0) idxout--; map.erase(idxout); } if (map.count(idxin) || (map.count(idxin-1) && nums[i] - map[idxin-1] &lt;= t) || (map.count(idxin+1) && map[idxin+1] - nums[i] &lt;= t)) return true; map[idxin] = nums[i]; } return false; } };</p></div><footer class=entry-footer><span title='2022-11-01 14:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 3. Longest Substring Without Repeating Characters" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 3090. Maximum Length Substring With Two Occurrences</h2></header><div class=entry-content><p>不定長的 Sliding Window 套 pattern class IWindow { public: virtual void add(char& c) = 0; virtual void erase(char& c) = 0; virtual bool check(char& c) = 0; virtual ~IWindow() {} }; class Window: public IWindow{ private: int cnt[26]; public: Window() { memset(cnt, 0, sizeof(cnt)); } void add(char& c) override { cnt[c-'a']++; } void erase(char& c) override { cnt[c-'a']--; } bool check(char& c) override { return cnt[c-'a'] == 2; } }; class Solution { private: unique_ptr&lt;IWindow> _w; public: Solution(): _w(make_unique&lt;Window>()) {} int maximumLengthSubstring(string s) { int n = s.size(), left = 0, right = 0; int res = 0; while (right &lt; n) { char c = s[right++]; while (_w->check(c)) _w->erase(s[left++]); _w->add(c); res = max(res, right-left); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 14:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 3090. Maximum Length Substring With Two Occurrences" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/3090/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 不定長 Sliding Window Pattern</h2></header><div class=entry-content><p>不定長度的 sliding window pattern 步驟 move sliding window
(1) 滑動左指標直到 window 有效 (2) 加入右指標 (3) 更新 class Window { public: virtual void add(int num) = 0; virtual void erase(int num) = 0; virtual bool check(int num) = 0; virtual ~Window() {} }; class Solution { private: unique_ptr&lt;Window> _w; public: Solution(): _w() {} int solve(vector&lt;int>& nums, int k) { _w = make_unique&lt;WindowImpl>(k); int len = 0; int n = nums.size(), left = 0, right = 0; while (right &lt; n) { int num = nums[right++]; while (_w->check(num)) _w->erase(nums[left++]); _w->add(num); res = max(res, right-left); } return len; } };</p></div><footer class=entry-footer><span title='2022-11-01 14:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 不定長 Sliding Window Pattern" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/pattern_2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 220. Contains Duplicate III</h2></header><div class=entry-content><p>這是一題是很有趣的一題，會用到 bucket sort 結合 sliding window，時間複雜度是 \(O(n)\) 我把 sliding window 的部分拆分開來，讓邏輯更清楚。 class Window { public: virtual void add(int num) = 0; virtual void erase(int num) = 0; virtual bool find(int num) = 0; virtual ~Window() {} }; class Bucket : public Window { private:c int _bucketSize; int _valueDiff; int index(int num) { return num &lt; 0 ? (num - _valueDiff) / _bucketSize : num / _bucketSize; } unordered_map&lt;int,int> _map; public: Bucket(int valueDiff): _valueDiff(valueDiff), _bucketSize(valueDiff + 1) {} void add(int num) override { int idx = index(num); _map[idx] = num; } void erase(int num) override { int idx = index(num); _map.erase(idx); } bool find(int num) override { int idx = index(num); return _map.count(idx) || (_map.count(idx-1) && num - _map[idx-1] &lt;= _valueDiff) || (_map.count(idx+1) && _map[idx+1] - num &lt;= _valueDiff); } }; class Solution { private: unique_ptr&lt;Window> _w; public: bool containsNearbyAlmostDuplicate(vector&lt;int>& nums, int indexDiff, int valueDiff) { int n = nums.size(); int k = indexDiff + 1; _w = make_unique&lt;Bucket>(valueDiff); for (int i = 0; i &lt; k && i &lt; n; i++) { if (_w->find(nums[i])) return true; _w->add(nums[i]); } for (int i = k; i &lt; n; i++) { _w->erase(nums[i-k]); if (_w->find(nums[i])) return true; _w->add(nums[i]); } return false; } }; 沒有抽象化的 code class Solution { public: bool containsNearbyAlmostDuplicate(vector&lt;int>& nums, int k, int t) { int n = nums.size(); unordered_map&lt;int,int> map; k++; for (int i = 0; i &lt; n; i++) { int idxin = nums[i] / (t+1); if (nums[i] &lt; 0) idxin--; if (i >= k) { int idxout = nums[i-k] / (t+1); if (nums[i-k] &lt; 0) idxout--; map.erase(idxout); } if (map.count(idxin) || (map.count(idxin-1) && nums[i] - map[idxin-1] &lt;= t) || (map.count(idxin+1) && map[idxin+1] - nums[i] &lt;= t)) return true; map[idxin] = nums[i]; } return false; } };</p></div><footer class=entry-footer><span title='2022-11-01 13:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 220. Contains Duplicate III" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/220/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1984. Minimum Difference Between Highest and Lowest of K Scores</h2></header><div class=entry-content><p>這是一題簡單的定長度 sliding window。先排序再用滑動窗口求值。時間複雜度是 \(O(n\log(n))\) class Solution { public: int minimumDifference(vector&lt;int>& nums, int k) { sort(nums.begin(), nums.end()); int res = INT_MAX; for (int i = 0; i &lt; nums.size() - k + 1; i++) { res = min(res, nums[i+k-1] - nums[i]); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 12:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1984. Minimum Difference Between Highest and Lowest of K Scores" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1984/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2269. Find the K-Beauty of a Number</h2></header><div class=entry-content><p>這是一題簡單的定長度 sliding window。 class Solution { public: int divisorSubstrings(int num, int k) { int curr = 0; string s = to_string(num); int res = 0; for (int i = 0; i &lt; s.size()-k+1; i++) { int div = stoi(s.substr(i, k)); if (div != 0 && num % div == 0) res++; } return res; } }; 用原本的 pattern 來做，但要注意 1e9 * 10 會爆掉，整數的範圍大概只有 2e9 (2147483647)。可改用先減再 shift 的方式處理。 class Solution { public: int divisorSubstrings(int num, int k) { int curr = 0; string s = to_string(num); int res = 0; int pk = pow(10, k-1); for (int i = 0; i &lt; k; i++) { curr = curr * 10 + (s[i] - '0'); } if (curr != 0 && num % curr == 0) res++; for (int i = k; i &lt; s.size(); i++) { curr = 10 * (curr - (s[i-k] - '0') * pk) + (s[i] - '0'); if (curr != 0 && num % curr == 0) res++; } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 12:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2269. Find the K-Beauty of a Number" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2269/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 766. Toeplitz Matrix</h2></header><div class=entry-content><p>766. Toeplitz Matrix
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Matrix 一、題目 Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.
Example 1:
Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation:
In the above grid, the diagonals are:
“[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”.
In each diagonal all elements are the same, so the answer is True. Example 2: ...</p></div><footer class=entry-footer><span title='2022-11-01 00:40:55 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 766. Toeplitz Matrix" href=https://intervalrain.github.io/leetcode/766/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1016. Binary String With Substrings Representing 1 To N</h2></header><div class=entry-content><p>這一題是滿有趣的一題，我的靈感來自於 zkw 的線段樹(但沒有用到線段樹)。 觀察 1 ~ n 的樹，並將它排成 zkw 的線段樹，可以發現以下規則： 滿足樹的子葉，則必定可以滿足其父節點，例如：找到 "1010"，則可以滿足 "101"、"10"、"1"。 所以可以得到一個數學結論是：我們只需要找到 n ~ n/2+1 的數即可。 [1] len = 1 [10] 11 len = 2 100 [101] 110 111 len = 3 1000 1001 [1010] 1011 1100 1101 1110 1111 len = 4 (8) num mask ^ 1&lt;&lt;3 solution: class Solution { public: bool queryString(string s, int n) { if (n > 1979) return false; // 剪枝：當 n 太大時必為 false, 證明在下面 int len = 32 - __builtin_clz(n); // n 的位元長度 if (s.size() &lt; len) return false; // s 長度連 window 都不夠時 return false int mask = (1 &lt;&lt; len) - 1; // 遮罩 用來控制 window 長度 unordered_set&lt;int> seen; // 用來記錄數字是否出現過 int valid = n - n/2; // 總共需要收集到的數目 // init int curr = 0; for (int i = 0; i &lt; len; i++) { curr = ((curr &lt;&lt; 1) | (s[i] & 1)); if (curr &lt;= n && curr > n/2) seen.insert(curr); if (seen.size() == valid) return true; } // rolling for (int i = len; i &lt; s.size(); i++) { curr = ((curr &lt;&lt; 1) | (s[i] & 1)) & mask; if (curr &lt;= n && curr > n/2) seen.insert(curr); if (seen.size() == valid) return true; } return false; } }; 剪枝的證明： 我來說明 1979 這個臨界值的計算過程： 當字串長度 = 1000 時，我們需要找到滿足以下條件的最大 n：
...</p></div><footer class=entry-footer><span title='2022-10-31 12:00:00 +0800 +0800'>October 31, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1016. Binary String With Substrings Representing 1 To N" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1016/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 19. Remove Nth Node From End of List</h2></header><div class=entry-content><p>19. Remove Nth Node From End of List
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Two Pointers 一、題目 Given the head of a linked list, remove the nth node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Example 3:
Input: head = [1,2], n = 1 Output: [1] Constraints:
...</p></div><footer class=entry-footer><span title='2022-10-31 00:05:10 +0800 +0800'>October 31, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 19. Remove Nth Node From End of List" href=https://intervalrain.github.io/leetcode/19/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination</h2></header><div class=entry-content><p>1293. Shortest Path in a Grid with Obstacles Elimination
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.
Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.
...</p></div><footer class=entry-footer><span title='2022-10-30 21:29:37 +0800 +0800'>October 30, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination" href=https://intervalrain.github.io/leetcode/1293/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/tags/leetcode/page/10/>«&nbsp;上一頁&nbsp;
</a><a class=next href=https://intervalrain.github.io/tags/leetcode/page/12/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>