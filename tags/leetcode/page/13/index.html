<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leetcode | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/tags/leetcode/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/tags/leetcode/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/tags/leetcode/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/tags/leetcode/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="Leetcode"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Leetcode"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/tags/>Tags</a></div><h1>Leetcode</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1888. Minimum Number of Flips to Make the Binary String Alternating</h2></header><div class=entry-content><p>難度分: 2006 這一題如果沒有條件一，則很簡單，根據奇偶數索引位置，判斷是否要 flip 就可以了。 int minFlips(string s) { int n = s.size(); int ans1 = 0, ans2 = 0; for (int i = 0; i &lt; n; i++) { if ((i % 2 == 0 && s[i] != '1') || (i % 2 == 1 && s[i] != '0')) ++ans1; if ((i % 2 == 0 && s[i] != '0') || (i % 2 == 1 && s[i] != '1')) ++ans2; } int ans = min(ans1, ans2); } 但這一題加上條件一，可以用很精巧的手法，把它轉成 sliding window 的問題，將字串重覆兩次，以原字串長度作為 window size，可解這題。 class Solution { public: int minFlips(string s) { int k = s.size(); s += s; int ans1 = 0, ans2 = 0; for (int i = 0; i &lt; k; i++) { if ((i % 2 == 0 && s[i] != '1') || (i % 2 == 1 && s[i] != '0')) ++ans1; if ((i % 2 == 0 && s[i] != '0') || (i % 2 == 1 && s[i] != '1')) ++ans2; } int ans = min(ans1, ans2); for (int i = k; i &lt; s.size(); i++) { if ((i % 2 == 0 && s[i] != '1') || (i % 2 == 1 && s[i] != '0')) ++ans1; if ((i % 2 == 0 && s[i] != '0') || (i % 2 == 1 && s[i] != '1')) ++ans2; if (((i - k) % 2 == 0 && s[i - k] != '1') || ((i - k) % 2 == 1 && s[i - k] != '0')) --ans1; if (((i - k) % 2 == 0 && s[i - k] != '0') || ((i - k) % 2 == 1 && s[i - k] != '1')) --ans2; ans = min({ans1, ans2, ans}); } return ans; } };</p></div><footer class=entry-footer><span title='2022-10-28 12:00:00 +0800 +0800'>October 28, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1888. Minimum Number of Flips to Make the Binary String Alternating" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1888/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Leetcode] 14. Longest Common Prefix</h2></header><div class=entry-content><p>14. Longest Common Prefix
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String 一、題目 Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string "".
Example 1:
Input: strs = [“flower”, “flow”, “flight”] Output: “fl” Example 2:
Input: strs = [“dog”, “racecar”, “car”] Output: "" Explanation: There is no common prefix among the input strings. Constraints:
1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] consists of only lowercase English letters. 二、分析 簡單的字串比對問題。 需熟悉 string 的函數 substr() 的使用方式，常用以下兩種 s.substr(int start, int len)，從 start 起取長度為 len 的子字串。 s.substr(int start) 從 start 起取到字串的結尾。 三、解題 1. String Time complexity: \(O(m\times n)，\text{m }為\text{ strs }的長度，\text{n }為\text{ strs[i] }的長度\)， Space complexity: \(O(1)\) string longestCommonPrefix(vector&lt;string>& strs) { string res = strs[0]; for (int i = 1; i &lt; strs.size(); i++) { int j = 0; for (; j &lt; min(strs[i].length(), res.length()); j++) { if (strs[i][j] != res[j]) break; } res = res.substr(0, j); } return res; } 回目錄 Catalog
...</p></div><footer class=entry-footer><span title='2022-10-28 00:00:08 +0800 +0800'>October 28, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Leetcode] 14. Longest Common Prefix" href=https://intervalrain.github.io/leetcode/14/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Leetcode] 13. Roman to Integer</h2></header><div class=entry-content><p>13. Roman to Integer
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.
\(\boxed{\begin{array}{ll} \textbf{Symbol}&\textbf{Value}\\ \texttt{I}&amp;1\\ \texttt{V}&amp;5\\ \texttt{X}&amp;10\\ \texttt{L}&amp;50\\ \texttt{C}&amp;100\\ \texttt{D}&amp;500\\ \texttt{M}&amp;1000\\ \end{array}}\)
For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:
...</p></div><footer class=entry-footer><span title='2022-10-27 21:58:08 +0800 +0800'>October 27, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Leetcode] 13. Roman to Integer" href=https://intervalrain.github.io/leetcode/13/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Leetcode] 835. Image Overlap</h2></header><div class=entry-content><p>835. Image Overlap
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Matrix 一、題目 You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.
We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images. Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix bordered are erased.
Return the largest possible overlap.
...</p></div><footer class=entry-footer><span title='2022-10-27 17:35:25 +0800 +0800'>October 27, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Leetcode] 835. Image Overlap" href=https://intervalrain.github.io/leetcode/835/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2653. Sliding Subarray Beauty</h2></header><div class=entry-content><p>難度分: 1786 我覺得這一題稍有難度，主要在處理 findKth 方法時，有一些技巧，如果單純用 vector 來記錄 window，會 LTE，因為 nums[i] 的範圍滿小的(-50~50之間)，可以用 bucket sort，如果數字再更大一點，可以使用 fenwick tree 或是 segment tree 範圍求和，使 update 與 query 的複雜度都是 \(\log(n)\) Bucket Sort class NumberTracker { public: virtual void update(int num, int delta) = 0; virtual int findKth(int k) = 0; virtual ~NumberTracker() {} }; class BucketSort : public NumberTracker { private: vector&lt;int> cnt; int left_; int right_; int n_; public: BucketSort(int left, int right) { left_ = left; right_ = right; n_ = right - left + 1; cnt.assign(n_, 0); } void update(int num, int delta) override { cnt[num - left_] += delta; } int findKth(int k) override { int total = 0; for (int i = 0; i &lt;= n_; i++) { total += cnt[i]; if (total >= k) { return i + left_; } } return -1; } }; class Solution { private: unique_ptr&lt;NumberTracker> tracker; public: Solution() : tracker(make_unique&lt;BucketSort>(-50, 50)) {} vector&lt;int> getSubarrayBeauty(vector&lt;int>& nums, int k, int x) { int n = nums.size(); vector&lt;int> res; for (int i = 0; i &lt; k; i++) { tracker->update(nums[i], 1); } int ans = tracker->findKth(x); res.push_back(min(ans, 0)); for (int i = k; i &lt; n; i++) { tracker->update(nums[i-k], -1); tracker->update(nums[i], 1); ans = tracker->findKth(x); res.push_back(min(ans, 0)); } return res; } }; Fenwick Tree class FenwickTree : public NumberTracker { private: int left_; int right_; int n_; vector&lt;int> bit; int lowbit(int a) { return a & (-a); } void add(int idx, int diff) { idx++; int n = bit.size(); while (idx &lt; n) { bit[idx] += diff; idx += lowbit(idx); } } int query(int idx) { int sum = 0; idx++; while (idx > 0) { sum += bit[idx]; idx -= lowbit(idx); } return sum; } public: FenwickTree(int left, int right) { left_ = left; right_ = right; n_ = right - left + 1; bit.assign(n_ + 1, 0); } void update(int num, int delta) { num -= left_; add(num, delta); } int findKth(int k) { int left = 0; int right = n_; while (left &lt; right) { int mid = (left + right) >> 1; if (query(mid) >= k) right = mid; else left = mid + 1; } return min(0, left + left_); } }; Segment Tree (zkw tree) class NumberTracker { public: virtual void build(vector&lt;int> nums) = 0; virtual void update(int num, int delta) = 0; virtual int findKth(int k) = 0; virtual ~NumberTracker() {} }; class SegmentTree : public NumberTracker { private: int n_; int m_; vector&lt;int> tree_; unordered_map&lt;int,int> num_to_idx; unordered_map&lt;int,int> idx_to_num; int lowbit(int a) { return a & (-a); } public: SegmentTree() {} void build(vector&lt;int> nums) override { sort(nums.begin(), nums.end()); for (int i = 0, j = 0; i &lt; nums.size(); i++) { if (i > 0 && nums[i] == nums[i-1]) continue; num_to_idx[nums[i]] = j; idx_to_num[j++] = nums[i]; } for (n_ = 1; n_ &lt; num_to_idx.size(); n_ &lt;&lt;= 1); m_ = n_ &lt;&lt; 1; tree_.assign(m_, 0); } void update(int num, int delta) override { int idx = num_to_idx[num]; idx += n_; while (idx > 0) { tree_[idx] += delta; idx >>= 1; } } int findKth(int k) override { int idx = 1; while (idx &lt; n_) { idx &lt;&lt;= 1; if (tree_[idx] &lt; k) { k -= tree_[idx]; idx++; } } return idx_to_num[idx - n_]; } }; class Solution { private: unique_ptr&lt;NumberTracker> tracker; public: Solution() : tracker(make_unique&lt;SegmentTree>()) {} vector&lt;int> getSubarrayBeauty(vector&lt;int>& nums, int k, int x) { tracker->build(nums); int n = nums.size(); vector&lt;int> res; for (int i = 0; i &lt; k; i++) { tracker->update(nums[i], 1); } int ans = tracker->findKth(x); res.push_back(min(ans, 0)); for (int i = k; i &lt; n; i++) { tracker->update(nums[i-k], -1); tracker->update(nums[i], 1); ans = tracker->findKth(x); res.push_back(min(ans, 0)); } return res; } };</p></div><footer class=entry-footer><span title='2022-10-27 12:00:00 +0800 +0800'>October 27, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2653. Sliding Subarray Beauty" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2653/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Leetcode] 12. Integer to Roman</h2></header><div class=entry-content><p>12. Integer to Roman
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.
\(\boxed{\begin{array}{ll} \textbf{Symbol}&\textbf{Value}\\ \texttt{I}&amp;1\\ \texttt{V}&amp;5\\ \texttt{X}&amp;10\\ \texttt{L}&amp;50\\ \texttt{C}&amp;100\\ \texttt{D}&amp;500\\ \texttt{M}&amp;1000\\ \end{array}}\)
For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:
...</p></div><footer class=entry-footer><span title='2022-10-26 20:36:08 +0800 +0800'>October 26, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Leetcode] 12. Integer to Roman" href=https://intervalrain.github.io/leetcode/12/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Leetcode] 11. Container With Most Water</h2></header><div class=entry-content><p>11. Container With Most Water
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Greedy 一、題目 You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.
Notive that you may not slant the container.
...</p></div><footer class=entry-footer><span title='2022-10-26 19:36:06 +0800 +0800'>October 26, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Leetcode] 11. Container With Most Water" href=https://intervalrain.github.io/leetcode/11/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Leetcode] 10. Regular Expression Matching</h2></header><div class=entry-content><p>10. Regular Expression Matching
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: String、Dynamic Programming、Recursion 一、題目 Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:
'.' Matches any single character. '*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial). Example 1:
Input: s = “aa”, p = “a” Output: false Explanation: “a” does not match the entire string “aa”. Example 2:
...</p></div><footer class=entry-footer><span title='2022-10-26 18:36:01 +0800 +0800'>October 26, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Leetcode] 10. Regular Expression Matching" href=https://intervalrain.github.io/leetcode/10/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2134. Minimum Swaps to Group All 1's Together II</h2></header><div class=entry-content><p>難度分: 1748 遇到 circular 的問題都可以換位思考，這題可以想成「min swaps to group all 1」或「min swaps to group all 0」 class Solution { public: int minSwaps(vector&lt;int>& nums) { int n = nums.size(); int k = accumulate(nums.begin(), nums.end(), 0); return min(minSwapsHelper(nums, 1, k), minSwapsHelper(nums, 0, n-k)); } int minSwapsHelper(vector&lt;int>& nums, int target, int k) { int n = nums.size(); int curr = 0; for (int i = 0; i &lt; k; i++) { if (nums[i] == target) curr++; } int cnt = curr; for (int i = k; i &lt; n; i++) { if (nums[i] == target) curr++; if (nums[i-k] == target) curr--; cnt = max(cnt, curr); } return k - cnt; } };</p></div><footer class=entry-footer><span title='2022-10-26 12:00:00 +0800 +0800'>October 26, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2134. Minimum Swaps to Group All 1's Together II" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2134/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Leetcode] 9. Palindrome Number</h2></header><div class=entry-content><p>9. Palindrome Number
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math 一、題目 Given an integer x, return true if x is palindrome number.
An integer is a palindrome when it reads the same backward as forward.
For example, 121 is a palindrome while 123 is not. Example 1:
Input: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2:
Input: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:
...</p></div><footer class=entry-footer><span title='2022-10-26 10:20:08 +0800 +0800'>October 26, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Leetcode] 9. Palindrome Number" href=https://intervalrain.github.io/leetcode/9/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/tags/leetcode/page/12/>«&nbsp;上一頁&nbsp;
</a><a class=next href=https://intervalrain.github.io/tags/leetcode/page/14/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>