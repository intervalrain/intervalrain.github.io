<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming | Rain Hu's Workspace</title><meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/tags/programming/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/tags/programming/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/tags/programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/tags/programming/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="Programming"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Programming"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/tags/>Tags</a></div><h1>Programming</h1></header><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] The C++ Standard Template Library(STL) - vector</h2></header><div class=entry-content><p>vector Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\(O(1)\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\(O(n)\)。 迭代器(Iterators) 1. vec.begin() 回傳指向 vector 中第一個元素的迭代器 (vec[0]) 2. vec.end() 回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n+1]) 3. vec.rbegin() 回傳指向 vector 中最後一個元素的反向迭代器 (vec[n]) 4. vec.rend() 回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1]) 5. vec.cbegin() 回傳指向 vector 中第一個元素的常數迭代器 (vec[0]) 6. vec.cend() 回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n+1]) 7. vec.crbegin() 回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n]) 8. vec.crend() 回傳指向 vector 中第一個元素之前一個的反向常數迭代器 (vec[-1]) #include &lt;bits/stdc++.h> using namespace std; int main(){ int arr[] = {1,1,2,3,5,8,13,21,34,55}; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int> vec(arr, arr + n); // initialize with array cout &lt;&lt; "Output of begin() and end(): "; for (auto i = vec.begin(); i != vec.end(); ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; "\nOutput of rbegin() and rend(): "; for (auto i = vec.rbegin(); i != vec.rend(); ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; "\nOutput of cbegin() and cend(): "; for (auto i = vec.cbegin(); i != vec.cend(); ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; "\nOutput of crbegin() and crend(): "; for (auto i = vec.crbegin(); i != vec.crend(); ++i) cout &lt;&lt; *i &lt;&lt; " "; return 0; } 結果：
...</p></div><footer class=entry-footer><span title='2022-04-16 22:08:37 +0800 +0800'>April 16, 2022</span>&nbsp;·&nbsp;5 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] The C++ Standard Template Library(STL) - vector" href=https://intervalrain.github.io/c++/stl_vector/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] The C++ Standard Template Library(STL) - Container</h2></header><div class=entry-content><p>容器(Containers) C++ container 基本上分為四大類： Sequence containers Container adaptors Associative containers Unordered associative containers 還有兩個特殊 containers: valarray, bitset \(\begin{array}{|l|l|l|l|l|l|}\hline \text{Name}&\text{Iterators}&\text{Capacity}&\text{Access}&\text{Modifiers}&\text{Others} \\\hline \text{array}&\text{begin}&\text{size}&\text{[]}&\text{swap} \\&\text{end}&\text{empty}&\text{at} \\&&&\text{front} \\&&&\text{back} \\\hline \text{vector}&\text{begin}&\text{size}&\text{[]}&\text{push\_back}&\text{} \\&\text{end}&\text{empty}&\text{at}&\text{pop\_back} \\&&\text{capacity}&\text{front}&\text{insert} \\&&&\text{back}&\text{erase} \\&&&&\text{swap} \\&&&&\text{clear} \\\hline \text{deque}&\text{begin}&\text{size}&\text{[]}&\text{push\_back}&\text{} \\&\text{end}&\text{empty}&\text{at}&\text{pop\_back} \\&&&\text{front}&\text{insert} \\&&&\text{back}&\text{erase} \\&&&&\text{swap} \\&&&&\text{clear} \\\hline \text{list}&\text{begin}&\text{size}&\text{front}&\text{push\_back}&\text{sort} \\&\text{end}&\text{empty}&\text{back}&\text{pop\_back}&\text{reverse} \\&&&&\text{insert} \\&&&&\text{erase} \\&&&&\text{swap} \\&&&&\text{clear} \\\hline \text{forward\_list}&\text{begin}&\text{empty}&\text{front}&\text{push\_front}&\text{sort} \\&\text{end}&&&\text{pop\_back}&\text{reverse} \\&&&&\text{insert\_after} \\&&&&\text{erase\_after} \\&&&&\text{swap} \\&&&&\text{clear} \\\hline \end{array} \)
基礎容器 pair 序列式容器(Sequence Containers) 特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。 vector list, forward_list deque arrays 容器適配器(Container Adaptors) 用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。 queue priority_queue stack 關聯性容器(Associative Containers) 又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。 set multiset map multimap 無序關聯容器(Unordered Associative Containers(C++11)) 通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。 unordered_set unordered_multiset unordered_map unordered_mutlimap 你可能會想繼續閱讀… 演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library</p></div><footer class=entry-footer><span title='2022-04-15 01:09:18 +0800 +0800'>April 15, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] The C++ Standard Template Library(STL) - Container" href=https://intervalrain.github.io/c++/stl_container/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[IDAS+] Optimize Summary Table Function</h2></header><div class=entry-content><p>前言 在做 WAT 量測後的資料處理時，IDAS 老舊的 VBA macro 執行時間實在過於久，且佔用大量的記憶體，於是就下了一個命題，想減少產生報表的時間。 想法 通常量測多片 wafer 的狀況下，不同 wafer 的排列順序是一致的，如果可以加入 Java 中 HashMap 的資料結構來處理 VBA 中 Lookup()，便可大幅減少 summary table 時，對 rawdata 做搜尋的時間。 令時間複雜度從\(O(n)\)進步到\(O(1)\)。 做法 產生 Dictionary 物件 由於 VBA 預設並沒有 Dictionary 的物，所以需要用 CreateObject("Scritping.Dictionary") 的程式碼，引入 Dictionary。 其 Dictionary 物件的 method 可參考 Microsoft 的文件：點此 在此先預先定義一個 function setDict() 可以對初始化 Dictionary。 接著宣告兩個 Dictionary 物件來存取 spec 和 data 工作頁的列數(row)。 Dim SpecDict As Object ' Claim a dict to store spec rows in worksheet SPEC. Dim DataDict As Object ' Claim a dict to store rawdata rows in worksheet Data. Set SpecDict = CreateObject("Scripting.Dictionary") Set DataDict = CreateObject("Scripting.Dictionary") Call setDict("SPEC", 3, SpecDict, Worksheets("SPEC").UsedRange, True) Call setDict("Data", 2, DataDict, Range(Worksheets("Data").Names(1)), True) 實作 setDict() 函數 利用 HashTable 的概念對不同的 parameter 列數先做一次記錄，因為只需一次迴圈，故時間複雜度是 \(O(n)\)，其中 n = SPEC 的列數 或是 量測的 parameter 數。 在此設計了五個 arguments，方便在未來如果還有使用到 Dictionary 的需求時，可以方便使用。 sheetName 字串，需要作儲存的工作頁(worksheet)。 Target 要儲存的列數(row)或欄數(column)。 Dict 要存放的 Dictionary 物件。 mRange 要做儲存的資料範圍，若表頭並是在第一列或第一欄時可指定。 若表頭是第一列或第一欄時，可直接代入 Worksheets("工作頁名稱").UsedRange byRows 看要儲存的對象是列(row)或是欄(column)，預設是以列來搜尋。 Public Function setDict(ByVal sheetName As String, ByVal Target As Integer, ByRef Dict As Object, ByVal mRange As Range, Optional ByVal byRows As Boolean = True) Dim nowSheet As Worksheet If Not IsExistSheet(sheetName) Then Exit Function Set nowSheet = Worksheets(sheetName) Dim i As Long Dim n As Long On Error Resume Next If byRows = True Then For i = 1 To mRange.Rows.Count If Not Trim(mRange.Cells(i, Target).Value) = "" Then Dict.Add mRange.Cells(i, Target).Value, i End If Next i Else For i = 1 To mRange.Columns.Count If Not Trim(mRange.Cells(Target, i).Value) = "" Then Dict.Add mRange.Cells(Target, i).Value, i End If Next i End If End Function 對 getSPECByPara() 做重製 將 parameter or SPEC 做 hashing 的處理後，可以用 Dictionary 物件來查值，時間複雜度為 \(O(1)\)。 在此不對原本的設計做更動，只做單純的 implement。 nowPara 要搜尋的 parameter 字串。 n 要搜尋的欄數(column)，specColumn是原作者預設的 enum，存放工作頁 SPEC 的每一欄的表頭。 sheetName 要搜尋的工作頁，預設為 SPECTEMP，是按完 initial，從 SPEC 工作頁複製出來的隱藏工作頁。 Public Function getSPECByPara(ByVal nowPara As String, ByVal n As specColumn, Optional sheetName As String = "SPECTEMP") Dim reValue Dim nowRange As Range Dim TargetSheet As Worksheet If Left(nowPara, 1) = "'" Then nowPara = Mid(nowPara, 2) Set TargetSheet = Worksheets(sheetName) Set nowRange = TargetSheet.UsedRange On Error Resume Next reValue = TargetSheet.Cells(SpecDict(nowPara), n) If Not IsEmpty(reValue) Then If Trim(reValue) = "" Then Set reValue = Nothing End If getSPECByPara = reValue End Function 對 getRangeByPara() 做重製 將 parameter or SPEC 做 hashing 的處理後，可以用 Dictionary 物件來查值，時間複雜度為 \(O(1)\)。 Public Function getRangeByPara(nowWafer As String, nowPara As String, Optional dieNum As Integer = 0) Dim nowRow As Long Dim nowRange As Range Set nowRange = Worksheets("Data").Range("wafer_" & nowWafer) Set getRangeByPara = Nothing If DataDict.Exists(nowPara) Then nowRow = DataDict(nowPara) Set getRangeByPara = nowRange.Range(N2L(4) & CStr(nowRow) & ":" & N2L(dieNum + 3) & CStr(nowRow)) End If End Function 解析 優點：較快的執行速度。經測試可以將 2~3 分鐘的執行時間縮短到 30 秒內。 缺點：若修改 rawdata，會發生錯誤。但若針對每一片 wafer 都做 setDict()的話，會浪費太多 memory。</p></div><footer class=entry-footer><span title='2022-04-14 00:39:50 +0800 +0800'>April 14, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IDAS+] Optimize Summary Table Function" href=https://intervalrain.github.io/vba/idas+_record/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] 如何產生 random 值</h2></header><div class=entry-content><p>rand() 函數 在 C/C++ 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 &lt;stdlib.h> 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C++ 幾乎一樣，只差在表頭檔的使用。 C-style #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;time.h> int main(){ srand(time(NULL)); // random seed int x = rand(); printf("x = %d\n", x); return 0; } Cpp-style #include &lt;iostream> #include &lt;cstdlib> #include &lt;ctime> using namespace std; int main(){ srand(time(NULL)); int x = rand(); cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; "x is between 0 and " &lt;&lt; RAND_MAX &lt;&lt; endl; return 0; } 亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話， 固定亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。 [0, 1) 浮點數亂數 [0, 1) 代表 0 &lt;= x &lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫： #include &lt;iostream> #include &lt;cstdlib> #include &lt;ctime> using namespace std; int main(){ srand(time(NULL)); double x = (double)rand()/(RAND_MAX + 1.0); cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; endl; return 0; } [a, b)特定範圍浮點數亂數 [a, b) 表 a &lt;= x &lt; b #include &lt;iostream> #include &lt;cstdlib> #include &lt;ctime> using namespace std; int main(){ srand(time(NULL)); double x = (double)rand()/(RAND_MAX + 1.0); cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; endl; return 0; } [a, b)特定範圍整數亂數 #include &lt;iostream> #include &lt;cstdlib> #include &lt;ctime> using namespace std; int main(){ srand(time(NULL)); int a = 1; // min int b = 100; // max int x = rand() % (b - a + 1) + a; cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; endl; return 0; } 上面這種使用餘數運算（%）的方式只是比較方便的寫法，事實上使用餘數運算所產生的整數亂數在理論上不是標準的均勻分布。
...</p></div><footer class=entry-footer><span title='2022-04-14 00:26:23 +0800 +0800'>April 14, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] 如何產生 random 值" href=https://intervalrain.github.io/c++/random/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] Cout functions</h2></header><div class=entry-content><p>cout Functions 設定顯示小數點位數 setprecision(int n) and fixed #include &lt;iostream> #include &lt;iomanip> using namespace std; int main(){ double a = 5.43/2.653; cout &lt;&lt; a &lt;&lt; endl; // 2.04674 cout &lt;&lt; setprecision(3) &lt;&lt; fixed; cout &lt;&lt; a &lt;&lt; endl; // 2.047 return 0; } 顯示 Boolean 值 std::boolalpha #include &lt;iostream> using namespace std; int main(){ bool a = true; cout &lt;&lt; a &lt;&lt; endl; // 1 cout &lt;&lt; std::boolalpha; cout &lt;&lt; a &lt;&lt; endl; // true return 0; }</p></div><footer class=entry-footer><span title='2022-04-08 10:20:38 +0800 +0800'>April 8, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] Cout functions" href=https://intervalrain.github.io/c++/cout/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] The C++ Standard Template Library(STL) - Algorithm</h2></header><div class=entry-content><p>演算法(Algorithms) Non-Manupulating Algorithms 1. sort() sort(first_iterator, last_iterator) 對 vector 作排序 2. reverse() reverse(first_iterator, last_iterator) 反轉 vector 的排序 3. *max_element() *max_element(first_iterator, last_iterator) 找出 vector 的最大值 4. *min_element() *min_element(first_iterator, last_iterator)` 找出 vector 的最小值 5. accumulate accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和 #include &lt;iostream> #include &lt;algorithm> #include &lt;vector> #include &lt;numeric> using namespace std; void print(vector&lt;int>& vec){ for (vector&lt;int>::iterator it = vec.begin(); it != vec.end(); it++){ cout &lt;&lt; *it &lt;&lt; " "; } cout &lt;&lt; endl; } int main(){ int arr[] = {10, 20, 5, 23, 42, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int> vec(arr, arr + n); // print initial vector print(vec); // [10, 20, 5, 23, 42, 15] // sort sort(vec.begin(), vec.end()); // [5, 10, 15, 20, 23, 42] print(vec); // reverse reverse(vec.begin(), vec.end()); // [42, 23, 20, 15, 10, 5] print(vec); // max & min cout &lt;&lt; *max_element(vec.begin(), vec.end()) &lt;&lt; endl; // 42 cout &lt;&lt; *min_element(vec.begin(), vec.end()) &lt;&lt; endl; // 5 // accumulate cout &lt;&lt; accumulate(vec.begin(), vec.end(), 0) &lt;&lt; endl; // 115 return 0; } 6. count() count(first_iterator, last_iterator, x) 計算 vector 中 x 的數量 7. find() find(fist_iterator, last_iterator, x) 回傳 vector 中第一個符合的 iterator，若無則傳回 v.end()。 #include &lt;algorithm> #include &lt;iostream> #include &lt;vector> using namespace std; int main() { int arr[] = {10, 20, 5, 23 ,42, 20, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int> vec(arr, arr + n); cout &lt;&lt; count(vec.begin(), vec.end(), 20); // 2 find(vec.begin(), vec.end(),5) != vec.end() ? // Element found cout &lt;&lt; "\nElement found": cout &lt;&lt; "\nElement not found"; return 0; } 8. binary_search() binary_search(first_iterator, last_iterator, x) 測試 x 是否存在已排序的 vector 中 9. lower_bound() lower_bound(first_iterator, last_iterator, x) 傳回指向不大於 x 的元素的 iterator 10. upper_bound() upper_bound(first_iterator, last_iterator, x) 傳回指向大於 x 的元素的 iterator #include &lt;iostream> #include &lt;algorithm> #include &lt;vector> using namespace std; int main(){ int arr[] = {5, 10, 15, 20, 20, 23, 42, 45}; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int> vec(arr, arr + n); sort(vec.begin(), vec.end()); cout &lt;&lt; binary_search(vec.begin(), vec.end(), 20) &lt;&lt; endl; // 1 cout &lt;&lt; (lower_bound(vec.begin(), vec.end(), 20) - vec.begin()) &lt;&lt; endl; // 3 cout &lt;&lt; (upper_bound(vec.begin(), vec.end(), 20) - vec.begin()) &lt;&lt; endl; // 5 return 0; } Manipulating Algorithms 1. vec.erase() arr.erase(position_to_be_deleted) 移除指定位置的元素 2. vec.erase(unique()) arr.erase(unique(arr.begin(), arr.end()), arr.end()) 移除已排序的 vector 中重複的元素 #include &lt;iostream> #include &lt;algorithm> #include &lt;vector> using namespace std; int main(){ int arr[] = {5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20}; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int> vec(arr, arr + n); // [5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20] vec.erase(vec.begin() + 1); // [5, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20] sort(vec.begin(), vec.end()); // [5, 15, 20, 20, 20, 20, 20, 20, 20, 23, 42, 45] vec.erase(unique(vec.begin(), vec.end()), vec.end()); // [5, 15, 20, 23, 42, 45] return 0; } 3. next_permutation() next_permutation(first_iterator, last_iterator) 對 vector 作動成下一個字典排序 4. prev_permutation() prev_permutation(first_iterator, last_iterator) 對 vector 作動成上一個字典排序 #include &lt;iostream> #include &lt;algorithm> #include &lt;vector> using namespace std; int main(){ int arr[] = {1,2,3,4,5,6,7}; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int> vec(arr, arr + n); // [1,2,3,4,5,6,7] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,5,7,6] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,5,7] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,7,5,6] prev_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5] return 0; } 5. distance() distance(first_iterator, last_iterator) #include &lt;iostream> #include &lt;algorithm> #include &lt;vector> #include "print.cc" using namespace std; int main(){ int arr[] = {5,10,15,20,20,23,42,45}; int n = sizeof(arr)/sizeof(arr[0]); vector&lt;int> vec(arr, arr + n); cout &lt;&lt; distance(vec.begin(), max_element(vec.begin(), vec.end())) &lt;&lt; endl; // 7 // == max_element(vec.begin(), vec.end()) - vec.begin(); return 0; } Array algorithms 1. any_of() any_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否有任何元素滿足條件 2. all_of() all(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否有全部元素滿足條件 3 none_of() none_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否沒有元素滿足條件 #include &lt;iostream> #include &lt;vector> #include &lt;algorithm> using namespace std; int main(){ vector&lt;int> vec1 {1,3,7,9,11,17,23}; all_of(vec1.begin(), vec1.end(), [](int x) { return (x & 1) == 1;}) ? cout &lt;&lt; "All odds\n" : cout &lt;&lt; "Not all odds\n"; vector&lt;int> vec2 {1,3,6,8,9,11,13}; any_of(vec2.begin(), vec2.end(), [](int x) { return (x & 1) == 0;}) ? cout &lt;&lt; "There are at least one even\n" : cout &lt;&lt; "There are no any even\n"; none_of(vec1.begin(), vec1.end(), [](int x) { return (x & 1) == 0;}) ? cout &lt;&lt; "There are no any even\n" : cout &lt;&lt; "There are at least one even\n"; return 0; } 4. copy_n() copy_n(source_array, array_size, target_array) 複製陣列 #include &lt;iostream> #include &lt;algorithm> using namespace std; int main(){ int arr[] = {1,2,3,4,5,6}; int arr2[6]; copy_n(arr, 6, arr2); for (int i : arr2){ cout &lt;&lt; i &lt;&lt; " "; } return 0; } 5. iota() iota(array_name, array_size, starting_number) 逐一增加並寫入指定大小的陣列 // C++ code to demonstrate working of iota() #include&lt;iostream> #include&lt;numeric> // for iota() using namespace std; int main(){ // Initializing array with 0 values int ar[6] = {0}; // Using iota() to assign values iota(ar, ar+6, 20); // Displaying the new array cout &lt;&lt; "The new array after assigning values is : "; for (int i=0; i&lt;6 ; i++) cout &lt;&lt; ar[i] &lt;&lt; " "; return 0; } Partition operations C++ 在標準模板資料庫(STL)中有一個 class 可以來做 partition 的演算法。 Partition 就是用來將容器裡面的元素依指定的條件做分隔。 1. partition() partition(begin, end, conditon) 依照指定條件做分隔。 2. is_partition() is_partitioned(begin, end, condition 判斷元素是否依照條件分開。 #include &lt;iostream> #include &lt;algorithm> #include &lt;vector> using namespace std; int main(){ vector&lt;int> vec = {2,1,5,6,8,7}; is_partitioned(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; }) ? cout &lt;&lt; "Vector is partitioned": cout &lt;&lt; "Vector is not partitioned"; cout &lt;&lt; endl; partition(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; }) ? cout &lt;&lt; "The partitioned vector is : "; for (int &amp;x : vec) cout &lt;&lt; x &lt;&lt; " "; return 0; } 3. stable_partition() stable_partition(begin, end, condition) 依指定條件作分隔，同時保留元素的相對位置。 4. partition_point() partition_point(begin, end, condition) 返回指向分隔位置的迭代器，也就是在 [begin, end] 範圍內的第一個元素。 This function returns an iterator pointing to the partition point of container i.e. the first element in the partitioned range [beg,end) for which condition is not true. The container should already be partitioned for this function to work. // C++ code to demonstrate the working of // stable_partition() and partition_point() #include&lt;iostream> #include&lt;algorithm> // for partition algorithm #include&lt;vector> // for vector using namespace std; int main() { // Initializing vector vector&lt;int> vect = { 2, 1, 5, 6, 8, 7 }; // partitioning vector using stable_partition() // in sorted order stable_partition(vect.begin(), vect.end(), [](int x) { return x%2 == 0; }); // Displaying partitioned Vector cout &lt;&lt; "The partitioned vector is : "; for (int &amp;x : vect) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; // Declaring iterator vector&lt;int>::iterator it1; // using partition_point() to get ending position of partition auto it = partition_point(vect.begin(), vect.end(), [](int x) { return x%2==0; }); // Displaying partitioned Vector cout &lt;&lt; "The vector elements returning true for condition are : "; for ( it1= vect.begin(); it1!=it; it1++) cout &lt;&lt; *it1 &lt;&lt; " "; cout &lt;&lt; endl; return 0; } 5. partition_copy() partition_copy(begin, end, begin1, begin2, condition) This function copies the partitioned elements in the different containers mentioned in its arguments. It takes 5 arguments. Beginning and ending position of container, beginning position of new container where elements have to be copied (elements returning true for condition), beginning position of new container where other elements have to be copied (elements returning false for condition) and the condition. Resizing new containers is necessary for this function. // C++ code to demonstrate the working of // partition_copy() #include&lt;iostream> #include&lt;algorithm> // for partition algorithm #include&lt;vector> // for vector using namespace std; int main() { // Initializing vector vector&lt;int> vect = { 2, 1, 5, 6, 8, 7 }; // Declaring vector1 vector&lt;int> vect1; // Declaring vector1 vector&lt;int> vect2; // Resizing vectors to suitable size using count_if() and resize() int n = count_if (vect.begin(), vect.end(), [](int x) { return x%2==0; } ); vect1.resize(n); vect2.resize(vect.size()-n); // Using partition_copy() to copy partitions partition_copy(vect.begin(), vect.end(), vect1.begin(), vect2.begin(), [](int x) { return x%2==0; }); // Displaying partitioned Vector cout &lt;&lt; "The elements that return true for condition are : "; for (int &amp;x : vect1) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; // Displaying partitioned Vector cout &lt;&lt; "The elements that return false for condition are : "; for (int &amp;x : vect2) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0; } Numeric algorithms 1. apply() apply([](int x){return operation;}) 對陣列所有元素做運算 2. arr.sum() arr.sum() 計算陣列所有元素的總合 // C++ code to demonstrate the working of // apply() and sum() #include&lt;iostream> #include&lt;valarray> // for valarray functions using namespace std; int main() { // Initializing valarray valarray&lt;int> varr = { 10, 2, 20, 1, 30 }; // Declaring new valarray valarray&lt;int> varr1 ; // Using apply() to increment all elements by 5 varr1 = varr.apply([](int x){return x=x+5;}); // Displaying new elements value cout &lt;&lt; "The new valarray with manipulated values is : "; for (int &amp;x: varr1) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; // Displaying sum of both old and new valarray cout &lt;&lt; "The sum of old valarray is : "; cout &lt;&lt; varr.sum() &lt;&lt; endl; cout &lt;&lt; "The sum of new valarray is : "; cout &lt;&lt; varr1.sum() &lt;&lt; endl; return 0; } 3. arr.min() arr.min() 傳回陣列中最小的元素 4. arr.max() arr.max() 傳回陣列中最大的元素 // C++ code to demonstrate the working of // max() and min() #include&lt;iostream> #include&lt;valarray> // for valarray functions using namespace std; int main() { // Initializing valarray valarray&lt;int> varr = { 10, 2, 20, 1, 30 }; // Displaying largest element of valarray cout &lt;&lt; "The largest element of valarray is : "; cout &lt;&lt; varr.max() &lt;&lt; endl; // Displaying smallest element of valarray cout &lt;&lt; "The smallest element of valarray is : "; cout &lt;&lt; varr.min() &lt;&lt; endl; return 0; } 5. arr.shift() arr.shift(int n) 對陣列做 n 個位的移動，正為向右移，負為向左移，缺位補零。 6. cshift() arr.cshift(int n) 對陣列做 n 個位的移動，正為向右移，負為向左移，缺位使用循環補位。 // C++ code to demonstrate the working of // shift() and cshift() #include&lt;iostream> #include&lt;valarray> // for valarray functions using namespace std; int main() { // Initializing valarray valarray&lt;int> varr = { 10, 2, 20, 1, 30 }; // Declaring new valarray valarray&lt;int> varr1; // using shift() to shift elements to left // shifts valarray by 2 position varr1 = varr.shift(2); // Displaying elements of valarray after shifting cout &lt;&lt; "The new valarray after shifting is : "; for ( int&amp;x : varr1) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; // using cshift() to circulary shift elements to right // rotates valarray by 3 position varr1 = varr.cshift(-3); // Displaying elements of valarray after circular shifting cout &lt;&lt; "The new valarray after circular shifting is : "; for ( int&amp;x : varr1) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0; } 7. arr1.swap(arr2) arr1.swap(arr2) 陣列做交換 // C++ code to demonstrate the working of // swap() #include&lt;iostream> #include&lt;valarray> // for valarray functions using namespace std; int main(){ // Initializing 1st valarray valarray&lt;int> varr1 = {1, 2, 3, 4}; // Initializing 2nd valarray valarray&lt;int> varr2 = {2, 4, 6, 8}; // Displaying valarrays before swapping cout &lt;&lt; "The contents of 1st valarray " "before swapping are : "; for (int &amp;x : varr1) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; cout &lt;&lt; "The contents of 2nd valarray " "before swapping are : "; for (int &amp;x : varr2) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; // Use of swap() to swap the valarrays varr1.swap(varr2); // Displaying valarrays after swapping cout &lt;&lt; "The contents of 1st valarray " "after swapping are : "; for (int &amp;x : varr1) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; cout &lt;&lt; "The contents of 2nd valarray " "after swapping are : "; for (int &amp;x : varr2) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0; } 你可能會想繼續閱讀… 容器(Containers) 函式(Functions) 迭代器(Iterators) Utility Library</p></div><footer class=entry-footer><span title='2022-04-06 16:04:36 +0800 +0800'>April 6, 2022</span>&nbsp;·&nbsp;9 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] The C++ Standard Template Library(STL) - Algorithm" href=https://intervalrain.github.io/c++/stl_algo/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] The C++ Standard Template Library(STL)</h2></header><div class=entry-content><p>STL 標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。
STL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。
STL 的四大組成 演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators) 補充 Utility Library</p></div><footer class=entry-footer><span title='2022-04-05 01:09:42 +0800 +0800'>April 5, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] The C++ Standard Template Library(STL)" href=https://intervalrain.github.io/c++/stl/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] STL: Vector 的使用與實作</h2></header><div class=entry-content><p>vector 的介紹 vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include &lt;vector> vector 的使用 建構式 constructor vector&lt;int> v1; // 不進行初始化 vector&lt;int> v2 = {1,2,3}; // 像陣列一樣初始化 vector&lt;int> v3(v2); // 利用vector初始化 vector&lt;int> v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector&lt;int> v5(3, 0); // 含有3個0的vector 談一下特殊的二維vector，其實就是二維矩陣，寫法為 vector&lt;vector&lt;int>> vv(3, vector&lt;int>(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse 遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。 vector&lt;int> v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3}; // 1. iterator vector&lt;int>::iterator it = v.begin(); while (it != v.end()){ cout &lt;&lt; *it &lt;&lt; " "; it++; } cout &lt;&lt; endl; // 2. for loop for (int e : v){ cout &lt;&lt; e &lt;&lt; " "; cout &lt;&lt; endl; } // 3. [] for (size_t i = 0; i &lt; v.size(); ++i){ cout &lt;&lt; v[i] &lt;&lt; " "; cout &lt;&lt; endl; } 資料的資刪查改 \( \def\arraystrecth{1.4}\begin{array}{|l|l|}\hline \text{methods}&\text{description}\\\hline\hline \text{push\_back}&\text{Add element at the end}\\\hline \text{pop\_back}&\text{Delete last element}\\\hline \text{insert}&\text{Insert elements}\\\hline \text{erase}&\text{Erase elements}\\\hline \end{array} \)
...</p></div><footer class=entry-footer><span title='2022-04-03 18:14:14 +0800 +0800'>April 3, 2022</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] STL: Vector 的使用與實作" href=https://intervalrain.github.io/c++/vector/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[TCAD] 工具語言</h2></header><div class=entry-content><p>TCAD 常用的三種程式語言 工具語言 用於操作 Sentaurus 工具的指令，例如： snmesh sdevice 預處理語言 Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro) 例如： #define __x__ 1 // 將所有 __x__ 字串取代成字串 1 TCL 公用語言，通常用來處理字串與數據。 範例 SPP 語言：@...@、#開頭的敘述都是 SPP 語言 #if "@tunneling@ == "Hurkx" #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif "@tunneling@ == "E1" #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif "@tunneling@ == "E1_5" #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif "@tunneling@ == "E2" #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif TCL 語言：set 與 puts 其中 @…@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .cmd 檔。 set A [expr -@BF_Thick@-@AB_Thick@-@GR_Thick@-@CH_Thick@-@ML_Thick@] puts "DOE: Xmin [format %.2f $A]"</p></div><footer class=entry-footer><span title='2022-03-26 21:46:26 +0800 +0800'>March 26, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [TCAD] 工具語言" href=https://intervalrain.github.io/device/tcad/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[Java] 面試常見問題</h2></header><div class=entry-content><p>1. 請說明 Final, Finally, Finalize 三者不同? Final: 一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。 Finally: 例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。 Finalize: 是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。 2. 請說明 String 字串中 == 與 .equals() 哪裡不同? ==:
比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。 equals():
是 String 覆寫後的 equals 方法，比較值。 補充：
Java 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。 若使用 String s1 = "Hello World"; 來宣告，則會透過字串池。 若使用 String s2 = new String("Hello World") 來宣告，則字串會存在 Heap 中，與上者的址不同。 3. 使用 “abc”.equals(s) 比較好還是 s.equals(“abc”)? 等效。 前者不會出現 NullPointerException。 4. Arrays 與 ArrayList 的差異? Arrays 可包含原始(primitive)及物件(object)，ArrayList只允許物件。 Arrays 大小固定，ArrayList 可動態調整。 ArrayList 提供許多方法，如 removeAll、iterator等。 5. stack 與 heap 的區別? stack: 可被預測生命週期的變數或函數資訊都放在 stack，例如：區域變數(local variable)、物件或陣列的返回位址(function/method return address)等資訊。 heap: 動態配置的記憶體空間，放置被 new 出來的物件以及內含的成員變數。 6. Arrays 與 String 的大小 Arrays 有 length 這個屬性。 String 有 legnth() 這個方法。 7. throw 與 throws 的區別 throws: throws 關鍵字通常被應用在聲明方法時，放在方法的大括號前，用來拋出異常，多個異常可以使用逗號隔開。後續使用者要調用方法時必須要拋出異常或者使用 try-catch 語句處理異常。 throw: throw 關鍵字通常用在設計方法時，預先宣告可能會產生的例外，後續方法使用者需要使用 try-catch 處理例外，或者使用 throws 關鍵字再拋出例外。 補充： throw 用於方法內，throws 用於方法的聲明。 throw 用於方法內拋出異常，throws 用於方法聲明上拋出異常。 throw 後面只能有一個異常，throws 可以聲明多個異常。 8. int 和 Integer 何者會占用更多記憶體? Integer，Integer 是一個物件，會在 heap 中儲存，並儲存址的值到 stack 中，而 int 只會保存值在 stack 中。 9. 是否能將 int 強制轉型為 byte? 可以，可以使用 b = (byte) a 來進行強制轉換，但是超過範圍的部分會被丟棄。 10. 是否能保證 gc 的執行? 否，垃報回收機制程式設計師無法保證，但可以透過 System.gc() 呼叫。 11. abstract class 與 interface 的區別? abstract class 可以宣告抽象方法，提供子類別實作。 interface 的方法必定是抽象方法。 一個類別可以繼承多個介面，但只能繼承一個抽象類別。 12. List 與 Set 區別? List: 有順序性(索引值)。 可重複。 ArrayList 實作了 List 介面。 ArrayList: 插入、刪除速度 \(O(n)\)，走訪速度\(O(1)\)。 LinkedList: 插入、刪除速度 \O(1)\)，走訪速度\(O(n)\)。 Set 無順序性(配合 iterator) 不可重複，走訪速度\(O(1)\)。 HashSet 實作了 Set 介面。 HashSet: 無順序性，查找速度快。 LinkedHashSet: 有順序性 TreeSet: 有排序性(依字母) Map 1.有元素鍵值(Key-Value)，搜尋快 2.元素可重複，鍵值如果重複新加入值會覆蓋舊有值 3.HashMap: 查找速度慢，插入刪除速度快 4.TreeMap: 有排序性</p></div><footer class=entry-footer><span title='2022-03-16 02:45:45 +0800 +0800'>March 16, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Java] 面試常見問題" href=https://intervalrain.github.io/java/interviewq/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/tags/programming/page/2/>«&nbsp;上一頁&nbsp;
</a><a class=next href=https://intervalrain.github.io/tags/programming/page/4/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>