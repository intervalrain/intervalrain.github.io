<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[DXP] 在 spotfire 中創建自定義視覺化工具 | Rain Hu's Workspace</title>
<meta name=keywords content="spotfire,dxp,custom visualization,visual"><meta name=description content="在 spotfire 中創建自定義的視覺化工具"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/dxp/customvisualization/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/dxp/customvisualization/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[DXP] 在 spotfire 中創建自定義視覺化工具"><meta property="og:description" content="在 spotfire 中創建自定義的視覺化工具"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="dxp"><meta property="article:published_time" content="2023-08-14T22:54:55+08:00"><meta property="article:modified_time" content="2023-08-14T22:54:55+08:00"><meta property="article:tag" content="Spotfire"><meta property="article:tag" content="Dxp"><meta name=twitter:card content="summary"><meta name=twitter:title content="[DXP] 在 spotfire 中創建自定義視覺化工具"><meta name=twitter:description content="在 spotfire 中創建自定義的視覺化工具"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Dxps","item":"https://intervalrain.github.io/dxp/"},{"@type":"ListItem","position":2,"name":"[DXP] 在 spotfire 中創建自定義視覺化工具","item":"https://intervalrain.github.io/dxp/customvisualization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[DXP] 在 spotfire 中創建自定義視覺化工具","name":"[DXP] 在 spotfire 中創建自定義視覺化工具","description":"在 spotfire 中創建自定義的視覺化工具","keywords":["spotfire","dxp","custom visualization","visual"],"articleBody":"簡介 Spotifre 的視覺化工具(visualization)是可以被擴展的。已在 Spotfire 環境中部署的自定義視覺化工具將會出現在相同的位置並以相同的方式運作，就像 Spotfire 原生的視覺化工具一樣：它們可以從視覺化選單(visualization menu)、繪圖文本選單(plot context menus)、工具列中被訪問，並且可以與其它繪圖(plots)共享數據集(data sets)、標記(marking)和篩選(filtering)。 需要擴充的點 可視化框架的擴充點包括：\nCustomVisual, CustomVisualization - custom visuals 的基礎類別，custom visualization 是 custom visual 的子類別，具有一此額外的功能。 CustomVisualFactory - custom visualizations 的工廠基類(Factory base)，用於創建自定義可視化工具的實例。 CustomVisualView - CustomVisual 視圖的基類。 實作 建立模型 模型部分繼承自 CustomVisual 或 CustomVisualization。 CustomVisualization 是 CustomVisual 的子類別，並添加了指定 data table 和 marking 的功能。能夠指定當前 data table 和當前 marking 使視覺化能夠參與主細節情境。它還使框架能夠在 marking 記錄上實現命令並在狀態欄中顯示有關 filtering 和 marking 的行數的訊息。\nCustomVisualization 的 model資料可以來源自一個或一個以上的 data tables；而 CustomVisual 則是可以在 Page 中實作原生的 Text Area 和其它各種控制面板。\nThe model achieves this dual requirement by overriding two virtual methods defined by CustomVisual: 視覺化工具應該要能自行渲染，它應該要能感知到外觀變化並能通知環境產生對應動作。模型透該 overrides 兩個虛擬方法(virtual methods)來實現這兩個需求：\n覆寫 RenderCore 方法以執行繪圖。 覆寫 GetRenderTriggerCore 以定義何時需要重新繪製視覺區。 以下範例展示了一個最簡單的 visualization。它有兩個屬性(PropertyName)，代表資料表(data table)和標記(marking)。範例會繪製一個字串，說明在資料表中被標記的行數。\n[Serializable] [PersistenceVersion(1, 0)] public class MyVisualization : CustomVisualization { public new abstract class PropertyNames : CustomVisualization.PropertyNames { public static readonly PropertyName DataTableReference = CreatePropertyName(\"DataTableReference\"); public static readonly PropertyName MarkingReference = CreatePropertyName(\"MarkingReference\"); } private readonly UndoableCrossReferenceProperty dataTableReference; private readonly UndoableCrossReferenceProperty markingReference; internal MyVisualization() { CreateProperty(PropertyNames.DataTableReference, out this.dataTableReference, null); CreateProperty(PropertyNames.MarkingReference, out this.markingReference, null); } public DataTable DataTableReference { get { return this.dataTableReference.Value; } set { this.dataTableReference.Value = value; } } public DataMarkingSelection MarkingReference { get { return this.markingReference.Value; } set { this.markingReference.Value = value; } } protected override void RenderCore(RenderArgs renderArgs) { // Clear our drawing surface. renderArgs.Graphics.FillRectangle(Brushes.White, renderArgs.Bounds); // Draw a string showing the number of marked rows. if (this.DataTableReference != null \u0026\u0026 this.MarkingReference != null) { int markedRowsCount = this.MarkingReference.GetSelection(this.DataTableReference).IncludedRowCount; string message = string.Format( \"{0} marked rows in table {1}\", markedRowsCount, this.DataTableReference.Name); renderArgs.Graphics.DrawString(message, SystemFonts.DefaultFont, Brushes.Black, renderArgs.Bounds); } } protected override Trigger GetRenderTriggerCore() { // Return a trigger that fires when the data table or marking properties change // or when the content of the marking changes. return Trigger.CreateCompositeTrigger( Trigger.CreatePropertyTrigger( this, PropertyNames.DataTableReference, PropertyNames.MarkingReference ), Trigger.CreateMutablePropertyTrigger( this, PropertyNames.MarkingReference, DataMarkingSelection.PropertyNames.Selection ) ); } protected override DataTable GetActiveDataTableReference() { return this.dataTableReference.Value; } protected override Trigger GetActiveDataTableReferenceTriggerCore() { return Trigger.CreatePropertyTrigger(this, PropertyNames.DataTableReference); } protected override DataMarkingSelection GetActiveMarkingReferenceCore() { return this.markingReference.Value; } protected override Trigger GetActiveMarkingReferenceTriggerCore() { return Trigger.CreatePropertyTrigger(this, PropertyNames.MarkingReference); } private MyVisualization(SerializationInfo info, StreamingContext context) : base(info, context) { DeserializeProperty(info, context, PropertyNames.DataTableReference, out this.dataTableReference); DeserializeProperty(info, context, PropertyNames.MarkingReference, out this.markingReference); } protected override void GetObjectData(SerializationInfo info, StreamingContext context) { base.GetObjectData(info, context); SerializeProperty(info, context, this.dataTableReference); SerializeProperty(info, context, this.markingReference); } } 建立工廠 為了創建可視化工具，必須為其指定自定義工廠(custom factory)。該工廠負責創建和初始配置。還包含一些 metadata 如 UI commands 和 type identifier。\npublic sealed class MyCustomIdentifiers : CustomTypeIdentifiers { public static readonly CustomTypeIdentifier MyVisualizationIdentifier = CreateTypeIdentifier( \"Acme.MyVisualization\", // Name \"My Visualization\", // Display name \"This is a description\"); // Description } internal sealed class MyVisualizationFactory : CustomVisualFactory { internal MyVisualizationFactory() : base( MyCustomIdentifiers.MyVisualizationIdentifier, VisualCategory.Visualization, Properties.Resources.MyVisualizationImage, null) { } protected override void AutoConfigureCore(MyVisualization visualization) { // Find good default values for properties. DataManager dataManager = visualization.Context.GetService(); visualization.DataTableReference = dataManager.Tables.DefaultTableReference; visualization.MarkingReference = dataManager.Markings.DefaultMarkingReference; } } 可視化工廠是從 CustomVisualFactory 衍生而來的。請注意，自定義工廠類別並不會實例化可視化。實例化可視化是透過可視化的無參數建構函式由工廠基底類別來完成的。建構函式不必是公開的；但事實上，它不應該是公開的，因為讓 API 使用者建立可視化，然後將其插入到文件中是不合理的。\n當視覺化已經被創建並插入到文件節點層次結構中時，框架會在工廠上調用兩個虛擬方法：\nInitializeCore：它設置與數據無直接關係的屬性。 AutoConfigureCore：它使用適當的默認值為數據相關屬性（例如數據表、標記和列）配置視覺化。在上面的例子中，只有AutoConfigureCore方法被覆蓋。 註冊 Visualization 最後，視覺化工廠必須在框架中註冊。透過 overrides Add-in 中的 RegisterVisuals 完成。\npublic sealed class MyVisualizationAddIn : AddIn { protected override void RegisterVisuals(AddIn.VisualRegistrar registrar) { registrar.Register(new MyVisualizationFactory()); } } 現在，可以在 TIBCO Spotfire 中創建 visualization 了。然而，無法以任何方式配置視覺化或與之互動。為了進行這樣的操作，必須為之一個視圖(view)。\n建立視圖 自訂視覺化檢視 API 是在 Spotfire 應用程式中建立自訂視覺化的統一 API。隨著 TIBCO Spotfire 7.5 中修改的架構，帶來了代碼共享的好處。現在建議只使用基於 Web 的方法，而不是在 TIBCO Spotfire Analyst 和 TIBCO Spotfire Consumer 和 Business Author 中維護一個自訂代碼。基於 Web 的自訂視覺化將嵌入 TIBCO Spotfire Analyst 中，就像任何內部視覺化一樣。\n如果希望任何先前創建的自定義視覺化與新的 API 配合使用，則需要進行轉換。有關更多信息，請參閱將自定義 Web 視覺化轉換為 CustomVisualView API。\n一個自訂的視圖類別是從基礎類別 CustomVisualView 繼承而來。在 AddIn 類別中，該視圖在 RegisterViews 方法中註冊，例如：\nprotected override void RegisterViews(ViewRegistrar registrar) { base.RegisterViews(registrar); registrar.Register(typeof(CustomVisualView), typeof(MyVisual), typeof(MyVisualView)); } 初始化 Visualization CustomVisualView 的一個實例可以被視為一個嵌入式 Web 伺服器，通常會提供一個 HTML 檔案，以及一些資源，例如 JavaScript 檔案、圖片等。 為了初始化視覺化，要 override GetResourceCore 方法：\nprotected override HttpContent GetResourceCore(string path, NameValueCollection query, MyVisual snapshotNode) { if (string.IsNullOrEmpty(path)) { path = \"MyVisual.html\"; } var bytes = GetEmbeddedResource(\"SpotfireDeveloper.CustomVisualsExample.webroot.\" + path); return new HttpContent(\"text/html\", bytes); } 從技術上講，當最終用戶創建自定義類型的可視化時，內部將發生的是一個“嵌入式 Web 客戶端”（一個 iFrame HTML 元素）將出現在當前頁面上，並且該 Web 客戶端將使用 URL “/” 進行 HTTP 請求。該請求將被路由到調用上面的 GetResourceCore 方法。在上面的示例中，將檢索 MyVisual.html。該 HTML 文件可能反過來加載任何資源：\n\u003cscript src=”http://code.jquery.com/jquery-1.11.2.min.js”\u003e\u003c/script\u003e \u003cscript src=”myscript.js”\u003e\u003c/script\u003e 請求 myscript.js 是使用相對路徑指定的，因此它將由被覆蓋的 GetResourceCore 方法處理。在上面的示例中，查找 webroot 文件夾中 JavaScript 文件的位置並嵌入該文件。但是，JavaScript 文件可以以任何方式獲取。例如，在調試的情況下，從硬編碼的路徑獲取文件可能很有用，以避免重建項目。\n客戶導向互動 您的自訂視覺化可以被視為分為客戶端和服務器端，其中客戶端是“視圖”，服務器端是“模型”。 提供了一些工具來簡化與伺服器的通訊。\n讀取資料 當「SpotfireLoaded」事件被觸發時，客戶端和伺服器之間的通訊通道就會開啟。在這個例子中，Spotfire.read 函數會從伺服器取回資料。\n$(window).on(\"SpotfireLoaded\", function() { Spotfire.read(\"GetData\", {\"argument\": \"value\"}, function(data) { if (data) { // typically re-render the visualization, but this example // just displays the returned value alert(data); } }); }); Spotfire.read 函數需要三個參數：\n一個方法識別符(method identifier)。 一個參數物件(argument object) 一個 callback 在伺服器端，讀取呼叫由ReadCore方法處理： protected override string ReadCore(string method, string args, MyVisual snapshotNode) { if (method.Equals(\"GetData\", StringComparison.OrdinalIgnoreCase)) { // typically retrieve some data from the document, // but this example just echoes the input argument return args; } return base.ReadCore(method, args, snapshotNode); } 請注意，當讀取數據時，服務代碼會在後台線程上執行。這允許多個同時讀取操作。\n寫入數據 當客戶需要修改文件時，例如標記數據時，請使用：\nSpotfire.modify(\"Mark\", {'rectangle': someObject}); 在伺服器端，修改呼叫由 ModifyCore 方法處理：\nprotected override void ModifyCore(string method, string args, MyVisual liveNode) { if (\"Mark\".Equals(method, StringComparison.Ordinal)) { liveNode.MarkArea(/* … */); } } 請注意，文件的修改是在主線程上執行的，因此修改文件是安全的。\n伺服器驅動的互動 從伺服器端，可以觸發客戶端的事件處理程序，例如：\nprotected override void OnUpdateRequiredCore() { this.InvokeClientEventHandler(\"render\", null); } 如需更多資訊，請參閱 OnUpdateRequiredCore。 當客戶端必須更新時，此代碼將運行，通過觸發\"渲染\"事件。 在客戶端：\nvar render = function(data) { // Typically call Spotfire.read(...) // data will be the argument from the server invocation - null in this example }; Spotfire.addEventHandler(\"render\", render); 匯出時呈現自訂視覺效果。 在使用 7.10 中引入的新匯出框架進行匯出時，有一些事情需要考慮，以使自訂視覺效果呈現得漂亮。在此處了解更多。\n","wordCount":"757","inLanguage":"zh-tw","datePublished":"2023-08-14T22:54:55+08:00","dateModified":"2023-08-14T22:54:55+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/dxp/customvisualization/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/dxp/>Dxps</a></div><h1 class="post-title entry-hint-parent">[DXP] 在 spotfire 中創建自定義視覺化工具</h1><div class=post-description>在 spotfire 中創建自定義的視覺化工具</div><div class=post-meta><span title='2023-08-14 22:54:55 +0800 +0800'>August 14, 2023</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//dxp/customVisualization.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e7%b0%a1%e4%bb%8b aria-label=簡介>簡介</a></li><li><a href=#%e9%9c%80%e8%a6%81%e6%93%b4%e5%85%85%e7%9a%84%e9%bb%9e aria-label=需要擴充的點>需要擴充的點</a></li><li><a href=#%e5%af%a6%e4%bd%9c aria-label=實作>實作</a><ul><li><a href=#%e5%bb%ba%e7%ab%8b%e6%a8%a1%e5%9e%8b aria-label=建立模型>建立模型</a></li><li><a href=#%e5%bb%ba%e7%ab%8b%e5%b7%a5%e5%bb%a0 aria-label=建立工廠>建立工廠</a></li><li><a href=#%e8%a8%bb%e5%86%8a-visualization aria-label="註冊 Visualization">註冊 Visualization</a></li><li><a href=#%e5%bb%ba%e7%ab%8b%e8%a6%96%e5%9c%96 aria-label=建立視圖>建立視圖</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96-visualization aria-label="初始化 Visualization">初始化 Visualization</a></li><li><a href=#%e5%ae%a2%e6%88%b6%e5%b0%8e%e5%90%91%e4%ba%92%e5%8b%95 aria-label=客戶導向互動>客戶導向互動</a></li><li><a href=#%e8%ae%80%e5%8f%96%e8%b3%87%e6%96%99 aria-label=讀取資料>讀取資料</a></li><li><a href=#%e5%af%ab%e5%85%a5%e6%95%b8%e6%93%9a aria-label=寫入數據>寫入數據</a></li><li><a href=#%e4%bc%ba%e6%9c%8d%e5%99%a8%e9%a9%85%e5%8b%95%e7%9a%84%e4%ba%92%e5%8b%95 aria-label=伺服器驅動的互動>伺服器驅動的互動</a></li><li><a href=#%e5%8c%af%e5%87%ba%e6%99%82%e5%91%88%e7%8f%be%e8%87%aa%e8%a8%82%e8%a6%96%e8%a6%ba%e6%95%88%e6%9e%9c aria-label=匯出時呈現自訂視覺效果。>匯出時呈現自訂視覺效果。</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=簡介>簡介<a hidden class=anchor aria-hidden=true href=#簡介>#</a></h2><ul><li>Spotifre 的視覺化工具(visualization)是可以被擴展的。已在 Spotfire 環境中部署的自定義視覺化工具將會出現在相同的位置並以相同的方式運作，就像 Spotfire 原生的視覺化工具一樣：它們可以從視覺化選單(visualization menu)、繪圖文本選單(plot context menus)、工具列中被訪問，並且可以與其它繪圖(plots)共享數據集(data sets)、標記(marking)和篩選(filtering)。</li></ul><h2 id=需要擴充的點>需要擴充的點<a hidden class=anchor aria-hidden=true href=#需要擴充的點>#</a></h2><p>可視化框架的擴充點包括：</p><ul><li><code>CustomVisual</code>, <code>CustomVisualization</code> - custom visuals 的基礎類別，custom visualization 是 custom visual 的子類別，具有一此額外的功能。</li><li><code>CustomVisualFactory</code> - custom visualizations 的工廠基類(Factory base)，用於創建自定義可視化工具的實例。</li><li><code>CustomVisualView</code> - CustomVisual 視圖的基類。</li></ul><h2 id=實作>實作<a hidden class=anchor aria-hidden=true href=#實作>#</a></h2><h3 id=建立模型>建立模型<a hidden class=anchor aria-hidden=true href=#建立模型>#</a></h3><p>模型部分繼承自 <code>CustomVisual</code> 或 <code>CustomVisualization</code>。 <code>CustomVisualization</code> 是 <code>CustomVisual</code> 的子類別，並添加了指定 data table 和 marking 的功能。能夠指定當前 data table 和當前 marking 使視覺化能夠參與主細節情境。它還使框架能夠在 marking 記錄上實現命令並在狀態欄中顯示有關 filtering 和 marking 的行數的訊息。</p><p>CustomVisualization 的 model資料可以來源自一個或一個以上的 data tables；而 CustomVisual 則是可以在 Page 中實作原生的 Text Area 和其它各種控制面板。</p><p>The model achieves this dual requirement by overriding two virtual methods defined by CustomVisual:
視覺化工具應該要能自行渲染，它應該要能感知到外觀變化並能通知環境產生對應動作。模型透該 overrides 兩個虛擬方法(virtual methods)來實現這兩個需求：</p><ul><li>覆寫 <code>RenderCore</code> 方法以執行繪圖。</li><li>覆寫 <code>GetRenderTriggerCore</code> 以定義何時需要重新繪製視覺區。</li></ul><p>以下範例展示了一個最簡單的 visualization。它有兩個屬性(PropertyName)，代表資料表(data table)和標記(marking)。範例會繪製一個字串，說明在資料表中被標記的行數。</p><pre tabindex=0><code class=language-Cs data-lang=Cs>[Serializable]
[PersistenceVersion(1, 0)]
public class MyVisualization : CustomVisualization
{
    public new abstract class PropertyNames : CustomVisualization.PropertyNames
    {
        public static readonly PropertyName DataTableReference = CreatePropertyName(&#34;DataTableReference&#34;);
        public static readonly PropertyName MarkingReference = CreatePropertyName(&#34;MarkingReference&#34;);
    }

    private readonly UndoableCrossReferenceProperty&lt;DataTable&gt; dataTableReference;
    private readonly UndoableCrossReferenceProperty&lt;DataMarkingSelection&gt; markingReference;

    internal MyVisualization()
    {
        CreateProperty(PropertyNames.DataTableReference, out this.dataTableReference, null);
        CreateProperty(PropertyNames.MarkingReference, out this.markingReference, null);
    }

    public DataTable DataTableReference
    {
        get { return this.dataTableReference.Value; }
        set { this.dataTableReference.Value = value; }
    }

    public DataMarkingSelection MarkingReference
    {
        get { return this.markingReference.Value; }
        set { this.markingReference.Value = value; }
    }

    protected override void RenderCore(RenderArgs renderArgs)
    {
        // Clear our drawing surface.
        renderArgs.Graphics.FillRectangle(Brushes.White, renderArgs.Bounds);
        
        // Draw a string showing the number of marked rows.
        if (this.DataTableReference != null &amp;&amp; this.MarkingReference != null)
        {
            int markedRowsCount = this.MarkingReference.GetSelection(this.DataTableReference).IncludedRowCount;
            string message = string.Format(
                &#34;{0} marked rows in table {1}&#34;,
                markedRowsCount,
                this.DataTableReference.Name);

            renderArgs.Graphics.DrawString(message,
                SystemFonts.DefaultFont,
                Brushes.Black,
                renderArgs.Bounds);
        }
    }

    protected override Trigger GetRenderTriggerCore()
    {
        // Return a trigger that fires when the data table or marking properties change
        // or when the content of the marking changes.
        return Trigger.CreateCompositeTrigger(
            Trigger.CreatePropertyTrigger(
                this, PropertyNames.DataTableReference, PropertyNames.MarkingReference
            ),
            Trigger.CreateMutablePropertyTrigger&lt;DataMarkingSelection&gt;(
                this, PropertyNames.MarkingReference, DataMarkingSelection.PropertyNames.Selection
            )
        );
    }

    protected override DataTable GetActiveDataTableReference()
    {
        return this.dataTableReference.Value;
    }

    protected override Trigger GetActiveDataTableReferenceTriggerCore()
    {
        return Trigger.CreatePropertyTrigger(this, PropertyNames.DataTableReference);
    }

    protected override DataMarkingSelection GetActiveMarkingReferenceCore()
    {
        return this.markingReference.Value;
    }

    protected override Trigger GetActiveMarkingReferenceTriggerCore()
    {
        return Trigger.CreatePropertyTrigger(this, PropertyNames.MarkingReference);
    }

    private MyVisualization(SerializationInfo info, StreamingContext context)
        : base(info, context)
    {
        DeserializeProperty(info, context, PropertyNames.DataTableReference, out this.dataTableReference);
        DeserializeProperty(info, context, PropertyNames.MarkingReference, out this.markingReference);
    }

    protected override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        base.GetObjectData(info, context);

        SerializeProperty(info, context, this.dataTableReference);
        SerializeProperty(info, context, this.markingReference);
    }
}
</code></pre><h3 id=建立工廠>建立工廠<a hidden class=anchor aria-hidden=true href=#建立工廠>#</a></h3><p>為了創建可視化工具，必須為其指定自定義工廠(custom factory)。該工廠負責創建和初始配置。還包含一些 metadata 如 UI commands 和 type identifier。</p><pre tabindex=0><code class=language-Cs data-lang=Cs>public sealed class MyCustomIdentifiers : CustomTypeIdentifiers
{
    public static readonly CustomTypeIdentifier MyVisualizationIdentifier =
        CreateTypeIdentifier(
            &#34;Acme.MyVisualization&#34;,    // Name
            &#34;My Visualization&#34;,        // Display name
            &#34;This is a description&#34;);  // Description
}
 
internal sealed class MyVisualizationFactory : CustomVisualFactory&lt;MyVisualization&gt;
{
    internal MyVisualizationFactory()
        : base(
        MyCustomIdentifiers.MyVisualizationIdentifier,    
        VisualCategory.Visualization,                  
        Properties.Resources.MyVisualizationImage,     
        null)                                          
    {
    }
 
    protected override void AutoConfigureCore(MyVisualization visualization)
    {
        // Find good default values for properties.
        DataManager dataManager = visualization.Context.GetService&lt;DataManager&gt;();
        visualization.DataTableReference = dataManager.Tables.DefaultTableReference;
        visualization.MarkingReference = dataManager.Markings.DefaultMarkingReference;
    }
}
</code></pre><p>可視化工廠是從 CustomVisualFactory 衍生而來的。請注意，自定義工廠類別並不會實例化可視化。實例化可視化是透過可視化的無參數建構函式由工廠基底類別來完成的。建構函式不必是公開的；但事實上，它不應該是公開的，因為讓 API 使用者建立可視化，然後將其插入到文件中是不合理的。</p><p>當視覺化已經被創建並插入到文件節點層次結構中時，框架會在工廠上調用兩個虛擬方法：</p><ul><li><code>InitializeCore</code>：它設置與數據無直接關係的屬性。</li><li><code>AutoConfigureCore</code>：它使用適當的默認值為數據相關屬性（例如數據表、標記和列）配置視覺化。在上面的例子中，只有AutoConfigureCore方法被覆蓋。</li></ul><h3 id=註冊-visualization>註冊 Visualization<a hidden class=anchor aria-hidden=true href=#註冊-visualization>#</a></h3><p>最後，視覺化工廠必須在框架中註冊。透過 overrides Add-in 中的 <code>RegisterVisuals</code> 完成。</p><pre tabindex=0><code class=language-Cs data-lang=Cs>public sealed class MyVisualizationAddIn : AddIn
{
    protected override void RegisterVisuals(AddIn.VisualRegistrar registrar)
    {
        registrar.Register(new MyVisualizationFactory());
    }
}
</code></pre><p>現在，可以在 TIBCO Spotfire 中創建 visualization 了。然而，無法以任何方式配置視覺化或與之互動。為了進行這樣的操作，必須為之一個視圖(view)。</p><h3 id=建立視圖>建立視圖<a hidden class=anchor aria-hidden=true href=#建立視圖>#</a></h3><p>自訂視覺化檢視 API 是在 Spotfire 應用程式中建立自訂視覺化的統一 API。隨著 TIBCO Spotfire 7.5 中修改的架構，帶來了代碼共享的好處。現在建議只使用基於 Web 的方法，而不是在 TIBCO Spotfire Analyst 和 TIBCO Spotfire Consumer 和 Business Author 中維護一個自訂代碼。基於 Web 的自訂視覺化將嵌入 TIBCO Spotfire Analyst 中，就像任何內部視覺化一樣。</p><p>如果希望任何先前創建的自定義視覺化與新的 API 配合使用，則需要進行轉換。有關更多信息，請參閱<a href=https://community.tibco.com/s/article/convert-custom-web-visualization-customvisualview-api-tibco-spotfire-75>將自定義 Web 視覺化轉換為 CustomVisualView API</a>。</p><p>一個自訂的視圖類別是從基礎類別 CustomVisualView 繼承而來。在 AddIn 類別中，該視圖在 RegisterViews 方法中註冊，例如：</p><pre tabindex=0><code class=language-Cs data-lang=Cs>protected override void RegisterViews(ViewRegistrar registrar)
{
      base.RegisterViews(registrar);
      registrar.Register(typeof(CustomVisualView), typeof(MyVisual), typeof(MyVisualView));
}
</code></pre><h3 id=初始化-visualization>初始化 Visualization<a hidden class=anchor aria-hidden=true href=#初始化-visualization>#</a></h3><p>CustomVisualView 的一個實例可以被視為一個嵌入式 Web 伺服器，通常會提供一個 HTML 檔案，以及一些資源，例如 JavaScript 檔案、圖片等。
為了初始化視覺化，要 override <code>GetResourceCore</code> 方法：</p><pre tabindex=0><code class=language-Cs data-lang=Cs>protected override HttpContent GetResourceCore(string path, NameValueCollection query, MyVisual snapshotNode)
{
    if (string.IsNullOrEmpty(path))
    {
        path = &#34;MyVisual.html&#34;;
    }

    var bytes = GetEmbeddedResource(&#34;SpotfireDeveloper.CustomVisualsExample.webroot.&#34; + path);
    return new HttpContent(&#34;text/html&#34;, bytes);
}
</code></pre><p>從技術上講，當最終用戶創建自定義類型的可視化時，內部將發生的是一個“嵌入式 Web 客戶端”（一個 iFrame HTML 元素）將出現在當前頁面上，並且該 Web 客戶端將使用 URL &ldquo;/&rdquo; 進行 HTTP 請求。該請求將被路由到調用上面的 GetResourceCore 方法。在上面的示例中，將檢索 MyVisual.html。該 HTML 文件可能反過來加載任何資源：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>”http://code.jquery.com/jquery-1.11.2.min.js”</span>&gt;&lt;/<span style=color:#f92672>script</span>&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>”myscript.js”</span>&gt;&lt;/<span style=color:#f92672>script</span>&gt;
</span></span></code></pre></div><p>請求 myscript.js 是使用相對路徑指定的，因此它將由被覆蓋的 <code>GetResourceCore</code> 方法處理。在上面的示例中，查找 webroot 文件夾中 JavaScript 文件的位置並嵌入該文件。但是，JavaScript 文件可以以任何方式獲取。例如，在調試的情況下，從硬編碼的路徑獲取文件可能很有用，以避免重建項目。</p><h3 id=客戶導向互動>客戶導向互動<a hidden class=anchor aria-hidden=true href=#客戶導向互動>#</a></h3><p>您的自訂視覺化可以被視為分為客戶端和服務器端，其中客戶端是“視圖”，服務器端是“模型”。
提供了一些工具來簡化與伺服器的通訊。</p><h3 id=讀取資料>讀取資料<a hidden class=anchor aria-hidden=true href=#讀取資料>#</a></h3><p>當「SpotfireLoaded」事件被觸發時，客戶端和伺服器之間的通訊通道就會開啟。在這個例子中，Spotfire.read 函數會從伺服器取回資料。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#a6e22e>$</span>(window).<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;SpotfireLoaded&#34;</span>, <span style=color:#66d9ef>function</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Spotfire</span>.<span style=color:#a6e22e>read</span>(<span style=color:#e6db74>&#34;GetData&#34;</span>, {<span style=color:#e6db74>&#34;argument&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;value&#34;</span>}, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// typically re-render the visualization, but this example
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// just displays the returned value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>alert</span>(<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><p>Spotfire.read 函數需要三個參數：</p><ul><li>一個方法識別符(method identifier)。</li><li>一個參數物件(argument object)</li><li>一個 callback
在伺服器端，讀取呼叫由ReadCore方法處理：</li></ul><pre tabindex=0><code class=language-Cs data-lang=Cs>protected override string ReadCore(string method, string args, MyVisual snapshotNode)
{
    if (method.Equals(&#34;GetData&#34;, StringComparison.OrdinalIgnoreCase))
    {
        // typically retrieve some data from the document, 
        // but this example just echoes the input argument
        return args;
    }
        
    return base.ReadCore(method, args, snapshotNode);
}
</code></pre><p>請注意，當讀取數據時，服務代碼會在後台線程上執行。這允許多個同時讀取操作。</p><h3 id=寫入數據>寫入數據<a hidden class=anchor aria-hidden=true href=#寫入數據>#</a></h3><p>當客戶需要修改文件時，例如標記數據時，請使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#a6e22e>Spotfire</span>.<span style=color:#a6e22e>modify</span>(<span style=color:#e6db74>&#34;Mark&#34;</span>, {<span style=color:#e6db74>&#39;rectangle&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>someObject</span>});
</span></span></code></pre></div><p>在伺服器端，修改呼叫由 <code>ModifyCore</code> 方法處理：</p><pre tabindex=0><code class=language-Cs data-lang=Cs>protected override void ModifyCore(string method, string args, MyVisual liveNode)
{
    if (&#34;Mark&#34;.Equals(method, StringComparison.Ordinal))
    { 
        liveNode.MarkArea(/* … */);
    }
}
</code></pre><p>請注意，文件的修改是在主線程上執行的，因此修改文件是安全的。</p><h3 id=伺服器驅動的互動>伺服器驅動的互動<a hidden class=anchor aria-hidden=true href=#伺服器驅動的互動>#</a></h3><p>從伺服器端，可以觸發客戶端的事件處理程序，例如：</p><pre tabindex=0><code class=language-Cs data-lang=Cs>protected override void OnUpdateRequiredCore()
{
    this.InvokeClientEventHandler(&#34;render&#34;, null);
}
</code></pre><p>如需更多資訊，請參閱 <a href="https://docs.tibco.com/pub/doc_remote/sfire_dev/area/doc/api/TIB_sfire-analyst_api/?topic=html/M_Spotfire_Dxp_Application_Extension_CustomVisualView_OnUpdateRequiredCore.htm&_ga=2.219012633.123850125.1692024818-1463462807.1662359000">OnUpdateRequiredCore</a>。
當客戶端必須更新時，此代碼將運行，通過觸發"渲染"事件。
在客戶端：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>render</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>{                
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Typically call Spotfire.read(...)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// data will be the argument from the server invocation - null in this example
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Spotfire</span>.<span style=color:#a6e22e>addEventHandler</span>(<span style=color:#e6db74>&#34;render&#34;</span>, <span style=color:#a6e22e>render</span>);
</span></span></code></pre></div><h3 id=匯出時呈現自訂視覺效果>匯出時呈現自訂視覺效果。<a hidden class=anchor aria-hidden=true href=#匯出時呈現自訂視覺效果>#</a></h3><p>在使用 7.10 中引入的新匯出框架進行匯出時，有一些事情需要考慮，以使自訂視覺效果呈現得漂亮。在<a href=https://community.tibco.com/s/article/making-tibco-spotfire-custom-visuals-render-nicely-when-exporting>此處</a>了解更多。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/spotfire/>Spotfire</a></li><li><a href=https://intervalrain.github.io/tags/dxp/>Dxp</a></li></ul><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>