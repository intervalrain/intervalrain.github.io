<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Leetcode on Rain Hu's Workspace</title><link>https://intervalrain.github.io/categories/leetcode/</link><description>Recent content in Leetcode on Rain Hu's Workspace</description><generator>Hugo -- 0.143.0</generator><language>zh-tw</language><lastBuildDate>Sat, 01 Feb 2025 01:09:32 +0800</lastBuildDate><atom:link href="https://intervalrain.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>[LeetCode] Grid 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/grid/</link><pubDate>Sat, 01 Feb 2025 01:09:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/grid/</guid><description/></item><item><title>[LeetCode] String 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/string/</link><pubDate>Sat, 01 Feb 2025 00:00:08 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/string/</guid><description/></item><item><title>[LeetCode] Greedy 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/greedy/</link><pubDate>Sat, 01 Feb 2025 00:00:07 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/greedy/</guid><description/></item><item><title>[LeetCode] Linked List and Binary Tree 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/linked_list_binary_tree/</link><pubDate>Sat, 01 Feb 2025 00:00:07 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/linked_list_binary_tree/</guid><description/></item><item><title>[LeetCode] Math 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/math/</link><pubDate>Sat, 01 Feb 2025 00:00:06 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/math/</guid><description/></item><item><title>[LeetCode] Common Data Structure 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/common_data_structure/</link><pubDate>Sat, 01 Feb 2025 00:00:05 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/common_data_structure/</guid><description/></item><item><title>[LeetCode] Dynamic Programming 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/dynamic_programming/</link><pubDate>Sat, 01 Feb 2025 00:00:04 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/dynamic_programming/</guid><description/></item><item><title>[LeetCode] Graph 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/graph/</link><pubDate>Sat, 01 Feb 2025 00:00:03 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/graph/</guid><description/></item><item><title>[LeetCode] Bit Manipulation 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/bit_manipulation/</link><pubDate>Sat, 01 Feb 2025 00:00:02 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/bit_manipulation/</guid><description/></item><item><title>[LeetCode] Monotonic Stack 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/monotonic_stack/</link><pubDate>Sat, 01 Feb 2025 00:00:01 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/monotonic_stack/</guid><description/></item><item><title>[LeetCode] Binary Search 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/binary_search/</link><pubDate>Sat, 01 Feb 2025 00:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/binary_search/</guid><description/></item><item><title>[ML] General guide on ML</title><link>https://intervalrain.github.io/ml/general_guide/</link><pubDate>Sun, 14 Jan 2024 14:31:56 +0800</pubDate><guid>https://intervalrain.github.io/ml/general_guide/</guid><description>general guide on machine learning</description></item><item><title>[Leetcode] Arrangement</title><link>https://intervalrain.github.io/leetcode/summary/</link><pubDate>Fri, 06 Oct 2023 16:30:47 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/summary/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">題號&lt;/th>
&lt;th style="text-align: left">題目&lt;/th>
&lt;th style="text-align: left">類別&lt;/th>
&lt;th style="text-align: left">題解&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">1&lt;/td>
&lt;td style="text-align: left">&lt;a href="../../leetcode/1">Two Sum&lt;/a>&lt;/td>
&lt;td style="text-align: left">Hash Table&lt;/td>
&lt;td style="text-align: left">Hash Table&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">2&lt;/td>
&lt;td style="text-align: left">&lt;a href="../../leetcode/2">Add Two numbers&lt;/a>&lt;/td>
&lt;td style="text-align: left">Linked List&lt;/td>
&lt;td style="text-align: left">Recursion&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">201&lt;/td>
&lt;td style="text-align: left">Bitwise AND of Numbers Range&lt;/td>
&lt;td style="text-align: left">Bitwise Operation&lt;/td>
&lt;td style="text-align: left">Lowbit = x&amp;amp;(~x+1)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">204&lt;/td>
&lt;td style="text-align: left">Count Primes&lt;/td>
&lt;td style="text-align: left">Math Thetory&lt;/td>
&lt;td style="text-align: left">The Sieve of Eratosthenes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">408&lt;/td>
&lt;td style="text-align: left">Valid Word Abbreviation&lt;/td>
&lt;td style="text-align: left">Two Pointers&lt;/td>
&lt;td style="text-align: left">字串轉數字&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>[LeetCode] 132. Palindrome Partitioning II</title><link>https://intervalrain.github.io/leetcode/132/</link><pubDate>Sat, 18 Mar 2023 16:10:36 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/132/</guid><description>&lt;p>&lt;strong>132. Palindrome Partitioning II&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>string&lt;/code>, &lt;code>dynamic programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a string &lt;code>s&lt;/code>, partition &lt;code>s&lt;/code> such that every substring of the partition is a palindrome.&lt;br>
Return &lt;em>the &lt;strong>minimum&lt;/strong> cuts needed for a palindrome partitioning of&lt;/em> &lt;code>s&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;aab&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 1&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The palindrome partitioning [&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;b&amp;rdquo;] could be produced using 1 cut.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;a&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 0&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;ab&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 1&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p></description></item><item><title>[Algo] 2-3. 分治法 Divide and Conquer</title><link>https://intervalrain.github.io/cs/algo/divide_and_conquer/</link><pubDate>Fri, 27 Jan 2023 10:48:42 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/divide_and_conquer/</guid><description>演算法設計，介紹什麼是分治法，分治法的核心思想與例題，與常見的一些技巧。</description></item><item><title>[LeetCode] 491. Non-decreasing Subsequences</title><link>https://intervalrain.github.io/leetcode/491/</link><pubDate>Fri, 20 Jan 2023 21:39:50 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/491/</guid><description>&lt;p>&lt;strong>491. Non-decreasing Subsequences&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Backtracking&lt;/code>、&lt;code>Bit Manipulation&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array &lt;code>nums&lt;/code>, return &lt;em>all the different possible non-decreasing subsequences of the given array with at least two elements.&lt;/em> You may return the answer in &lt;strong>any order&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [4,6,7,7]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [4,4,3,2,1]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [[4,4]]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code> &amp;lt;= nums.length &amp;lt;= 15&lt;/code>&lt;/li>
&lt;li>&lt;code>-100 &amp;lt;= nums[i] &amp;lt;= 100&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="二分析">二、分析&lt;/h3>
&lt;ul>
&lt;li>這一很典型的是一個 &lt;code>backtrack&lt;/code> 的問題，只要熟悉回溯法的框架並注意&lt;strong>終止條件&lt;/strong>與&lt;strong>處理重覆子序列&lt;/strong>即可。&lt;/li>
&lt;li>終止條件為 &lt;code>i == nums.size()&lt;/code>，此時將遍歷過的 &lt;code>path&lt;/code> 加入 &lt;code>res&lt;/code>，但要注意題目有規定至少要 &lt;code>2&lt;/code> 個元素的子序列，故需要再加入前做確認。&lt;/li>
&lt;li>注意題目傳回的子序列不可重覆，故需要額外做處理。&lt;/li>
&lt;/ul>
&lt;h3 id="三解題">三、解題&lt;/h3>
&lt;h4 id="1-backtracking">1. Backtracking&lt;/h4>
&lt;ul>
&lt;li>Time complexity: \(O(2^n)\)&lt;/li>
&lt;li>Space complexity: \(O(n)\)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> findSubsequences(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(nums, &lt;span style="color:#ae81ff">0&lt;/span>, path, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sort(res.begin(), res.end()); &lt;span style="color:#75715e">// 先做排序後
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> res.size()&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">--&lt;/span>) { &lt;span style="color:#75715e">// 從後面往前迭代
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (res[i] &lt;span style="color:#f92672">==&lt;/span> res[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.erase(res.begin()&lt;span style="color:#f92672">+&lt;/span>i); &lt;span style="color:#75715e">// 刪除重覆的序列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> i, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> path, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> res) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> nums.size()) { &lt;span style="color:#75715e">// 終止條件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (path.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) { &lt;span style="color:#75715e">// 滿足子序列元素大於等於2個，則加入答案
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> res.push_back(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (path.size() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> nums[i] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> path.back()) { &lt;span style="color:#75715e">// 注意需滿足題意為上升序列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> path.push_back(nums[i]); &lt;span style="color:#75715e">// 加入子序列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dfs(nums, i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, path, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.pop_back(); &lt;span style="color:#75715e">// 回溯法需將元素 pop 掉
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(nums, i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, path, res); &lt;span style="color:#75715e">// 跳過不取
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-backtrackingoptimized">2. Backtracking(optimized)&lt;/h4>
&lt;ul>
&lt;li>Time complexity: \(O(2^n)\)&lt;/li>
&lt;li>Space complexity: \(O(n)\)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> findSubsequences(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(nums, &lt;span style="color:#ae81ff">0&lt;/span>, path, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> i, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> path, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> res) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> nums.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (path.size() &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.push_back(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (path.size() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> nums[i] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> path.back()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.push_back(nums[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(nums, i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, path, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.pop_back();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (path.size() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> nums[i] &lt;span style="color:#f92672">!=&lt;/span> path.back()) { &lt;span style="color:#75715e">// 處理重覆子序列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dfs(nums, i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, path, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://intervalrain.github.io/leetcode">回目錄 Catalog&lt;/a>&lt;/p></description></item><item><title>[LeetCode] 974. Subarray Sums Divisible by K</title><link>https://intervalrain.github.io/leetcode/974/</link><pubDate>Thu, 19 Jan 2023 13:50:19 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/974/</guid><description>&lt;p>&lt;strong>974. Subarray Sums Divisible by K&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Prefix Sum&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return &lt;em>the number of non-empty&lt;/em> &lt;strong>subarrays&lt;/strong> &lt;em>that have a sum divisible by&lt;/em> &lt;code>k&lt;/code>.&lt;br>
A &lt;strong>subarray&lt;/strong> is a &lt;strong>contiguous&lt;/strong> part of an array.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [4,5,0,-2,-3,1], k = 5&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 7&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> There are 7 subarrays with a sum divisible by k = 5:&lt;br>
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 53. Maximum Subarray</title><link>https://intervalrain.github.io/leetcode/53/</link><pubDate>Wed, 18 Jan 2023 23:20:08 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/53/</guid><description>&lt;p>&lt;strong>53. Maxmimum Subarray&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Divide and Conquer&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array &lt;code>num&lt;/code>, find the subarray with the largest sum, and return &lt;em>its sum&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 6&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The subarray [4,-1,2,1] has the largest sum 6.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [1]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 1&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The subarray [1] has the largest sum 1.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> [5,4,-1,7,8]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 23&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The subarray [5,4,-1,7,8] has the largest sum 23.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 918. Maximum Sum Circular Subarray</title><link>https://intervalrain.github.io/leetcode/918/</link><pubDate>Wed, 18 Jan 2023 23:07:56 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/918/</guid><description>&lt;p>&lt;strong>918. Maximum Sum Circular Subarray&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Divide and Conquer&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Queue&lt;/code>、&lt;code>Monotonic Queue&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a &lt;strong>circular integer array&lt;/strong> &lt;code>nums&lt;/code> of length &lt;code>n&lt;/code>, return &lt;em>the maximum possible sum of a non-empty &lt;em>&lt;strong>subarray&lt;/strong>&lt;/em> of&lt;/em> &lt;code>nums&lt;/code>.&lt;br>
A &lt;strong>circular array&lt;/strong> means the end of the array connects to the beginning of the array. Formally, the next element of &lt;code>nums[i]&lt;/code> is &lt;code>nums[(i + 1) % n]&lt;/code> and the previous element of &lt;code>nums[i]&lt;/code> is &lt;code>nums[(i - 1 + n) % n]&lt;/code>.&lt;br>
A &lt;strong>subarray&lt;/strong> may only include each element of the fixed buffer &lt;code>nums&lt;/code> at most once. Formally, for a subarray &lt;code>nums[i], nums[i + 1], ..., nums[j]&lt;/code>, there does not exist &lt;code>i &amp;lt;= k1&lt;/code>, &lt;code>k2 &amp;lt;= j&lt;/code> with &lt;code>k1 % n == k2 % n&lt;/code>.&lt;/p></description></item><item><title>[LeetCode] 926. Flip String to Monotone Increasing</title><link>https://intervalrain.github.io/leetcode/926/</link><pubDate>Tue, 17 Jan 2023 16:36:26 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/926/</guid><description>&lt;p>&lt;strong>926. Flip String to Monotone Increasing&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>A binary string is monotone increasing if it consists of some number of &lt;code>0&lt;/code>&amp;rsquo;s (possibly none), followed by some number of &lt;code>1&lt;/code>&amp;rsquo;s (also possibly none).&lt;br>
You are given a binary string &lt;code>s&lt;/code>. You can flip &lt;code>s[i]&lt;/code> changing &lt;code>0&lt;/code> to &lt;code>1&lt;/code> or from &lt;code>1&lt;/code> to &lt;code>0&lt;/code>.&lt;br>
Return &lt;em>the minimum number of flips to make&lt;/em> &lt;code>s&lt;/code> &lt;em>monotone increasing&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1519. Number of Nodes in the Sub-Tree With the Same Level</title><link>https://intervalrain.github.io/leetcode/1519/</link><pubDate>Thu, 12 Jan 2023 22:56:18 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1519/</guid><description>&lt;p>&lt;strong>1519. Number of Nodes in the Sub-Tree With the Same Level&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Hash Table&lt;/code>、&lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Breadth-First Search&lt;/code>、&lt;code>Counting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of &lt;code>n&lt;/code> nodes numbered from &lt;code>0&lt;/code> to &lt;code>n - 1&lt;/code> and exactly &lt;code>n - 1&lt;/code> &lt;code>edges&lt;/code>. The &lt;strong>root&lt;/strong> of the tree is the node &lt;code>0&lt;/code>, and each node of the tree has &lt;strong>a label&lt;/strong> which is a lower-case character given in the string &lt;strong>labels&lt;/strong> (i.e. The node with the number &lt;code>i&lt;/code> has the label &lt;code>labels[i]&lt;/code>).&lt;br>
The &lt;code>edges&lt;/code> array is given on the form &lt;code>edges[i] = [ai, bi]&lt;/code>, which means there is an edge between nodes &lt;code>ai&lt;/code> and &lt;code>bi&lt;/code> in the tree.&lt;br>
Return &lt;em>an array of size &lt;code>n&lt;/code>&lt;/em> where &lt;code>ans[i]&lt;/code> is the number of nodes in the subtree of the &lt;code>ith&lt;/code> node which have the same label as node &lt;code>i&lt;/code>.&lt;br>
A subtree of a tree &lt;code>T&lt;/code> is the tree consisting of a node in &lt;code>T&lt;/code> and all of its descendant nodes.&lt;/p></description></item><item><title>[LeetCode] 100. Same Tree</title><link>https://intervalrain.github.io/leetcode/100/</link><pubDate>Tue, 10 Jan 2023 21:48:09 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/100/</guid><description>&lt;p>&lt;strong>100. Same Tree&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Breadth-First Search&lt;/code>、&lt;code>Binary Tree&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the roots of two binary tree &lt;code>p&lt;/code> and &lt;code>q&lt;/code>, write a function to check if they are the same or not.&lt;br>
Two binary tree are considered the same if they are structurally iedntical, and the nodes have the same value.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="ex1" loading="lazy" src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> p = [1,2,3], q = [1,2,3]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> true&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;br>
&lt;img alt="ex2" loading="lazy" src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> p = [1,2], q = [1,null,2]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> false&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>
&lt;img alt="ex3" loading="lazy" src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg">&lt;/p></description></item><item><title>[LeetCode] 149. Max Points on a Line</title><link>https://intervalrain.github.io/leetcode/149/</link><pubDate>Sun, 08 Jan 2023 23:44:07 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/149/</guid><description>&lt;p>&lt;strong>149. Max Points on a Line&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Math&lt;/code>、&lt;code>Geometry&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an array of &lt;code>points&lt;/code> where &lt;code>points[i] = [xi, yi]&lt;/code> represents a point on the &lt;strong>X-Y&lt;/strong> plane, return &lt;em>the maximum number of points that lie on the same straight line&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="plane1" loading="lazy" src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> points = [[1,1],[2,2],[3,3]]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 3&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>
&lt;img alt="plane2" loading="lazy" src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 4&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= points.length &amp;lt;= 300&lt;/code>&lt;/li>
&lt;li>&lt;code>points[i].length == 2&lt;/code>&lt;/li>
&lt;li>&lt;code>-10^4 &amp;lt;= xi, yi &amp;lt;= 10^4&lt;/code>&lt;/li>
&lt;li>All the &lt;code>points&lt;/code> are &lt;strong>unique&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="二分析">二、分析&lt;/h3>
&lt;ul>
&lt;li>若干點在同一條線上，表示這些點的斜率都相同，注意題目有提示不會有相同的點，故兩點間必定有斜率。
&lt;ul>
&lt;li>特別注意當分母為 &lt;code>0&lt;/code> 時要特別處理。&lt;/li>
&lt;li>題目有限制 &lt;code>-10^4 &amp;lt;= xi, yi &amp;lt;= 10^4&lt;/code>，故斜率最大 &lt;code>10^8&lt;/code>，所以我們可以將分母為零的斜率暫定為 &lt;code>INT_MAX(2147483647)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>遍歷每個點，並統計該點與其它點之間的斜率，將斜率用 &lt;code>unordered_map&lt;/code> 記錄下來，其每個斜率的直線上總共會有 &lt;code>m+1&lt;/code> (加上自己)。&lt;/li>
&lt;/ul>
&lt;h3 id="三解題">三、解題&lt;/h3>
&lt;h4 id="1">1.&lt;/h4>
&lt;ul>
&lt;li>Time complexity: \(O(n^2)\)&lt;/li>
&lt;li>Space complexity: \(O(n)\)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maxPoints&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> points) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> points.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> x0 &lt;span style="color:#f92672">=&lt;/span> points[i][&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> y0 &lt;span style="color:#f92672">=&lt;/span> points[i][&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> j) &lt;span style="color:#66d9ef">continue&lt;/span>; &lt;span style="color:#75715e">// 若等於自己則跳過
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> x1 &lt;span style="color:#f92672">=&lt;/span> points[j][&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> y1 &lt;span style="color:#f92672">=&lt;/span> points[j][&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x0 &lt;span style="color:#f92672">==&lt;/span> x1) { &lt;span style="color:#75715e">// 當分母為 0 時特別處理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>map[INT_MAX];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, cnt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> (y1&lt;span style="color:#f92672">-&lt;/span>y0)&lt;span style="color:#f92672">/&lt;/span>(&lt;span style="color:#ae81ff">1.0&lt;/span>&lt;span style="color:#f92672">*&lt;/span>(x1&lt;span style="color:#f92672">-&lt;/span>x0)); &lt;span style="color:#75715e">// 注意將斜率轉成 double
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>map[m];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, cnt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 答案記得加 1，加上自己
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://intervalrain.github.io/leetcode">回目錄 Catalog&lt;/a>&lt;/p></description></item><item><title>[LeetCode] 452. Minimum Number of Arrows to Burst Balloons</title><link>https://intervalrain.github.io/leetcode/452/</link><pubDate>Thu, 05 Jan 2023 20:19:49 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/452/</guid><description>&lt;p>&lt;strong>452. Minimum Number of Arrows to Burst Balloons&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>,&lt;code>Greedy&lt;/code>,&lt;code>Sorting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array &lt;code>points&lt;/code> where &lt;code>points[i] = [x_start, x_end]&lt;/code> denotes a balloon whose &lt;strong>horizontal diameter&lt;/strong> stretches between &lt;code>x_start&lt;/code> and &lt;code>x_end&lt;/code>. You do not know the exact y-coordinates of the balloons.&lt;br>
Arrows can be shot up &lt;strong>directly vertically&lt;/strong> (in the positive y-direction) from different points along the x-axis. A balloon with &lt;code>x_start&lt;/code> and &lt;code>x_end&lt;/code> is &lt;strong>burst&lt;/strong> by an arrow shot at &lt;code>x&lt;/code> if &lt;code>x_start &amp;lt;= x &amp;lt;= x_end&lt;/code>. There is &lt;strong>no limit&lt;/strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.&lt;br>
Given the array &lt;code>points&lt;/code>, return &lt;em>the &lt;em>&lt;strong>minimum&lt;/strong>&lt;/em> number of arrows that must be shot to burst all balloons&lt;/em>.&lt;/p></description></item><item><title>[LeetCode] 944. Delete Columns to Make Sorted</title><link>https://intervalrain.github.io/leetcode/944/</link><pubDate>Tue, 03 Jan 2023 20:09:30 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/944/</guid><description>&lt;p>&lt;strong>944. Delete Columns to Make Sorted&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an array of &lt;code>n&lt;/code> string &lt;code>strs&lt;/code>, all of the same length.&lt;br>
The string s can be arranged such that there is one on each line, making a grid. For example, &lt;code>strs = [&amp;quot;abc&amp;quot;, &amp;quot;bce&amp;quot;, &amp;quot;cae&amp;quot;&lt;/code> can be arranged as :&lt;/p>
&lt;pre tabindex="0">&lt;code>abc
bce
cae
&lt;/code>&lt;/pre>&lt;p>You want to &lt;strong>delete&lt;/strong> the columns that are &lt;strong>not sorted lexicographically&lt;/strong>. In the aove example (0-indexed), columns 0(&lt;code>'a'&lt;/code>,&lt;code>'b'&lt;/code>,&lt;code>'c'&lt;/code>) and 2(&lt;code>'c'&lt;/code>,&lt;code>'e'&lt;/code>,&lt;code>'e'&lt;/code>) are sorted while column 1(&lt;code>'b'&lt;/code>,&lt;code>'c'&lt;/code>,&lt;code>'a'&lt;/code>) is not, so you would delete column 1.&lt;br>
Return &lt;em>the number of columns that you will delete&lt;/em>.&lt;/p></description></item><item><title>[LeetCode] 2522. Partition String Into Substrings With Values at Most K</title><link>https://intervalrain.github.io/leetcode/2522/</link><pubDate>Mon, 02 Jan 2023 23:15:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2522/</guid><description>&lt;p>&lt;strong>2522. Partition String Into Substrings With Values at Most K&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics:&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 323}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a string &lt;code>s&lt;/code> consisting of digits from &lt;code>1&lt;/code> to &lt;code>9&lt;/code> and an integer &lt;code>k&lt;/code>.&lt;br>
A partition of a string &lt;code>s&lt;/code> is called &lt;strong>good&lt;/strong> if:&lt;/p>
&lt;ul>
&lt;li>Each digit of &lt;code>s&lt;/code> is part of &lt;strong>exactly&lt;/strong> one substring.&lt;/li>
&lt;li>The value of each substring is less than or equal to &lt;code>k&lt;/code>.
Return &lt;em>the &lt;em>&lt;strong>minimum&lt;/strong>&lt;/em> number of substrings in a &lt;em>&lt;strong>good&lt;/strong>&lt;/em> partition of&lt;/em> &lt;code>s&lt;/code>. If no &lt;strong>good&lt;/strong> partition of &lt;code>s&lt;/code> exists, return &lt;code>-1&lt;/code>.&lt;br>
&lt;strong>Note&lt;/strong> that:&lt;/li>
&lt;li>The &lt;strong>value&lt;/strong> of a string is its result when interpreted as an integer. For example, the value of &lt;code>&amp;quot;123&amp;quot;&lt;/code> is &lt;code>123&lt;/code> and the value of &lt;code>&amp;quot;1&amp;quot;&lt;/code> is &lt;code>1&lt;/code>.&lt;/li>
&lt;li>A &lt;strong>substring&lt;/strong> is a contiguous sequence of characters within a string.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2523. Closest Prime Numbers in Range</title><link>https://intervalrain.github.io/leetcode/2523/</link><pubDate>Mon, 02 Jan 2023 16:33:40 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2523/</guid><description>&lt;p>&lt;strong>2523. Closest Prime Numbers in Range&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics:&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 323}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given two positive integers &lt;code>left&lt;/code> and &lt;code>right&lt;/code>, find the two integers num1 and num2 such that:&lt;/p>
&lt;ul>
&lt;li>&lt;code>left &amp;lt;= nums1 &amp;lt; nums2 &amp;lt;= right&lt;/code>.&lt;/li>
&lt;li>&lt;code>nums1&lt;/code> and &lt;code>nums2&lt;/code> are both &lt;strong>prime&lt;/strong> numbers.&lt;/li>
&lt;li>&lt;code>nums2 - nums1&lt;/code> is the &lt;strong>minimum&lt;/strong> amongst all other pairs satisfying the above conditions.&lt;br>
Return &lt;em>the positive integer array&lt;/em> &lt;code>ans = [nums1, nums2]&lt;/code>. &lt;em>If there are multiple pairs satisfying these conditions, return the one with the minimum&lt;/em> &lt;code>nums1&lt;/code> &lt;em>value or&lt;/em> &lt;code>[-1, -1]&lt;/code> &lt;em>if such numbers do not exist.&lt;/em>&lt;br>
A number greater than &lt;code>1&lt;/code> is called &lt;strong>prime&lt;/strong> if it is only divisible by &lt;code>1&lt;/code> and itself.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 520. Detect Capital</title><link>https://intervalrain.github.io/leetcode/520/</link><pubDate>Mon, 02 Jan 2023 11:05:30 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/520/</guid><description>&lt;p>&lt;strong>520. Detect Capital&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>We define the usage of capitals in a word to be right when one of the following cases holds:&lt;/p>
&lt;ul>
&lt;li>All letters in this word are capitals, like &lt;code>&amp;quot;USA&amp;quot;&lt;/code>.&lt;/li>
&lt;li>All letters in this word are not capitals, like &lt;code>&amp;quot;leetcode&amp;quot;&lt;/code>.&lt;/li>
&lt;li>Only the first letter in this word is capital, like &lt;code>&amp;quot;Google&amp;quot;&lt;/code>.&lt;br>
Given a string &lt;code>word&lt;/code>, return &lt;code>true&lt;/code> if the usage of capitals in it is right.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2521. Distinct Prime Factors of Product of Array</title><link>https://intervalrain.github.io/leetcode/2521/</link><pubDate>Sun, 01 Jan 2023 23:52:02 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2521/</guid><description>&lt;p>&lt;strong>2521. Distinct Prime Factors of Product of Array&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics:&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 323}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an array of positive integers &lt;code>nums&lt;/code>, return &lt;em>the number of &lt;em>&lt;strong>distinct prime factors&lt;/strong>&lt;/em> in the product of the elements of&lt;/em> &lt;code>nums&lt;/code>.&lt;br>
&lt;strong>Note&lt;/strong> that:&lt;/p>
&lt;ul>
&lt;li>A number greater than &lt;code>1&lt;/code> is called &lt;strong>prime&lt;/strong> if it is divisible by only &lt;code>1&lt;/code> and itself.&lt;/li>
&lt;li>An integer &lt;code>val1&lt;/code> is a factor of another integer val2 if &lt;code>val2 / val1&lt;/code> is an integer.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2520. Count the Digits That Divide a Number</title><link>https://intervalrain.github.io/leetcode/2520/</link><pubDate>Sun, 01 Jan 2023 23:41:54 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2520/</guid><description>&lt;p>&lt;strong>2520. Count the Digits That Divide a Number&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics:&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 323}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer &lt;code>num&lt;/code>, return &lt;em>the number of digits in &lt;code>num&lt;/code> that divide &lt;code>num&lt;/code>.&lt;/em>
An integer &lt;code>val&lt;/code> divides &lt;code>nums&lt;/code> if &lt;code>nums % val == 0&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> num = 7&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 1&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> 7 divides itself, hence the answer is 1.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> num = 121&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 2&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 290. Word Pattern</title><link>https://intervalrain.github.io/leetcode/290/</link><pubDate>Sun, 01 Jan 2023 23:14:56 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/290/</guid><description>&lt;p>&lt;strong>290. Word Pattern&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Hash Table&lt;/code>、&lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a &lt;code>pattern&lt;/code> and a string &lt;code>s&lt;/code>, find if &lt;code>s&lt;/code> follows the same pattern.&lt;br>
Here &lt;strong>follow&lt;/strong> means a full match, such that there is a bijection between a letter in &lt;code>pattern&lt;/code> and &lt;strong>non-empty&lt;/strong> word in &lt;code>s&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> pattern = &amp;ldquo;abba&amp;rdquo;, s = &amp;ldquo;dog cat cat dog&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> true&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> pattern = &amp;ldquo;abba&amp;rdquo;, s = &amp;ldquo;dog cat cat fish&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> false&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1834. Single-Threaded CPU</title><link>https://intervalrain.github.io/leetcode/1834/</link><pubDate>Thu, 29 Dec 2022 22:49:27 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1834/</guid><description>&lt;p>&lt;strong>1834. Single-Threaded CPU&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Sorting&lt;/code>、&lt;code>Heap (Priority Queue&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given &lt;code>n&lt;/code>​​​​ tasks labeled from &lt;code>0&lt;/code> to &lt;code>n - 1&lt;/code> represented by a 2D integer array &lt;code>tasks&lt;/code>, where &lt;code>tasks[i] = [enqueueTimei, processingTimei]&lt;/code> means that the &lt;code>i​​​​​​th​​​​&lt;/code> task will be available to process at &lt;code>enqueueTimei&lt;/code> and will take &lt;code>processingTimei&lt;/code> to finish processing.&lt;br>
You have a single-threaded CPU that can process &lt;strong>at most one&lt;/strong> task at a time and will act in the following way:&lt;/p></description></item><item><title>[LeetCode] 1962. Remove Stones to Minimize the Total</title><link>https://intervalrain.github.io/leetcode/1962/</link><pubDate>Thu, 29 Dec 2022 00:03:22 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1962/</guid><description>&lt;p>&lt;strong>1962. Remove Stones to Minimize the Total&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Heap (Priority Queue)&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a &lt;strong>0-indexed&lt;/strong> integer array &lt;code>piles&lt;/code>, where &lt;code>piles[i]&lt;/code> represents the number of stones in the &lt;code>ith&lt;/code> pile, and an integer &lt;code>k&lt;/code>. You should apply the following operation &lt;strong>exactly&lt;/strong> &lt;code>k&lt;/code> times:&lt;br>
Choose any &lt;code>piles[i]&lt;/code> and &lt;strong>remove&lt;/strong> &lt;code>floor(piles[i] / 2)&lt;/code> stones from it.
&lt;strong>Notice&lt;/strong> that you can apply the operation on the &lt;strong>same&lt;/strong> pile more than once.&lt;br>
Return &lt;em>the minimum possible total number of stones remaining after applying the&lt;/em> &lt;code>k&lt;/code> &lt;em>operations.&lt;/em>&lt;br>
&lt;code>floor(x)&lt;/code> is the &lt;strong>greatest&lt;/strong> integer that is &lt;strong>smaller&lt;/strong> than or &lt;strong>equal&lt;/strong> to &lt;code>x&lt;/code> (i.e., rounds &lt;code>x&lt;/code> down).&lt;/p></description></item><item><title>[LeetCode] 2279. Maximum Bags With Full Capacity of Rocks</title><link>https://intervalrain.github.io/leetcode/2279/</link><pubDate>Tue, 27 Dec 2022 20:48:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2279/</guid><description>&lt;p>&lt;strong>2279. Maximum Bags With Full Capacity of Rocks&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Greedy&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You have &lt;code>n&lt;/code> bags numbered from &lt;code>0&lt;/code> to &lt;code>n - 1&lt;/code>. You are given two &lt;strong>0-indexed&lt;/strong> integer arrays &lt;code>capacity&lt;/code> and &lt;code>rocks&lt;/code>. The &lt;code>ith&lt;/code> bag can hold a maximum of &lt;code>capacity[i]&lt;/code> rocks and currently contains &lt;code>rocks[i]&lt;/code> rocks. You are also given an integer &lt;code>additionalRocks&lt;/code>, the number of additional rocks you can place in &lt;strong>any&lt;/strong> of the bags.&lt;br>
Return &lt;em>the &lt;strong>maximum&lt;/strong> number of bags that could have full capacity after placing the additional rocks in some bags.&lt;/em>&lt;/p></description></item><item><title>[LeetCode] 2389. Longest Subsequence With Limited Sum</title><link>https://intervalrain.github.io/leetcode/2389/</link><pubDate>Sun, 25 Dec 2022 20:07:51 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2389/</guid><description>&lt;p>&lt;strong>2389. Longest Subsequence With Limited Sum&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Binary Search&lt;/code>、&lt;code>Greedy&lt;/code>、&lt;code>Sorting&lt;/code>、&lt;code>Prefix Sum&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an integer array &lt;code>nums&lt;/code> of length &lt;code>n&lt;/code>, and an integer array queries of length &lt;code>m&lt;/code>.&lt;br>
Return &lt;em>an array&lt;/em> &lt;code>answer&lt;/code> &lt;em>of length&lt;/em> &lt;code>m&lt;/code> &lt;em>where&lt;/em> &lt;code>answer[i]&lt;/code> &lt;em>is the&lt;/em> &lt;em>&lt;strong>maximum&lt;/strong>&lt;/em> &lt;em>size of a&lt;/em> &lt;em>&lt;strong>subsequence&lt;/strong>&lt;/em> &lt;em>that you can take from&lt;/em> &lt;code>nums&lt;/code> &lt;em>such that the&lt;/em> &lt;em>&lt;strong>sum&lt;/strong>&lt;/em> &lt;em>of its elements is less than or equal to&lt;/em> &lt;code>queries[i]&lt;/code>.&lt;br>
A &lt;strong>subsequence&lt;/strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.&lt;/p></description></item><item><title>[LeetCode] 790. Domino and Tromino Tiling</title><link>https://intervalrain.github.io/leetcode/790/</link><pubDate>Sat, 24 Dec 2022 23:53:10 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/790/</guid><description>&lt;p>&lt;strong>790. Domino and Tromino Tiling&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You have two types of tiles: a &lt;code>2 x 1&lt;/code> domino shape and a tromino shape. You may rotate these shapes.&lt;br>
&lt;img alt="domino" loading="lazy" src="https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg">
Given an integer n, return &lt;em>the number of ways to tile an&lt;/em> &lt;code>2 x n&lt;/code> &lt;em>board&lt;/em>. Since the answer may be very large, return it &lt;strong>modulo&lt;/strong> &lt;code>10^9 + 7&lt;/code>.&lt;br>
In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.&lt;/p></description></item><item><title>[LeetCode] 841. Keys and Rooms</title><link>https://intervalrain.github.io/leetcode/841/</link><pubDate>Tue, 20 Dec 2022 23:00:22 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/841/</guid><description>&lt;p>&lt;strong>841. Keys and Rooms&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Depth-First Search&lt;/code>、&lt;code>Breadth-First Search&lt;/code>、&lt;code>Graph&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>There are &lt;code>n&lt;/code> rooms labeled from &lt;code>0&lt;/code> to &lt;code>n - 1&lt;/code> and all the rooms are locked except for room &lt;code>0&lt;/code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.&lt;br>
When you visit a room, you may find a set of &lt;strong>distinct keys&lt;/strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.&lt;br>
Given an array &lt;code>rooms&lt;/code> where &lt;code>rooms[i]&lt;/code> is the set of keys that you can obtain if you visited room &lt;code>i&lt;/code>, return &lt;code>true&lt;/code> &lt;em>if you can visit all the rooms, or&lt;/em> &lt;code>false&lt;/code> &lt;em>otherwise&lt;/em>.&lt;/p></description></item><item><title>[LeetCode] 25. Reverse Nodes in k-Group</title><link>https://intervalrain.github.io/leetcode/25/</link><pubDate>Fri, 16 Dec 2022 23:32:48 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/25/</guid><description>&lt;p>&lt;strong>25. Reverse Nodes in k-Group&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Linked List&lt;/code>、&lt;code>Recursion&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the &lt;code>head&lt;/code> of a linked list, reverse the nodes of the list &lt;code>k&lt;/code> at a time, and return &lt;em>the modified list&lt;/em>.&lt;br>
&lt;code>k&lt;/code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of &lt;code>k&lt;/code> then left-out nodes, in the end, should remain as it is.&lt;br>
You may not alter the values in the list&amp;rsquo;s nodes, only nodes themselves may be changed.&lt;/p></description></item><item><title>[LeetCode] 24. Swap Nodes in Pairs</title><link>https://intervalrain.github.io/leetcode/24/</link><pubDate>Wed, 14 Dec 2022 23:35:28 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/24/</guid><description>&lt;p>&lt;strong>24. Swap Nodes in Pairs&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Linked List&lt;/code>、&lt;code>Recursion&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&amp;rsquo;s nodes (i.e., only nodes themselves may be changed.)&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="swap_ex1" loading="lazy" src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> head = [1,2,3,4]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [2,1,4,3]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> head = []&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> []&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> head = [1]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [1]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 931. Minimum Falling Path Sum</title><link>https://intervalrain.github.io/leetcode/931/</link><pubDate>Tue, 13 Dec 2022 21:53:27 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/931/</guid><description>&lt;p>&lt;strong>931. Minimum Falling Path Sum&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Matrix&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an &lt;code>n x n&lt;/code> array of integers &lt;code>matrix&lt;/code>, return &lt;em>the &lt;strong>minimum sum&lt;/strong> of any &lt;strong>falling path&lt;/strong> through&lt;/em> &lt;code>matrix&lt;/code>.&lt;br>
A &lt;strong>falling path&lt;/strong> starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position &lt;code>(row, col)&lt;/code> will be &lt;code>(row + 1, col - 1)&lt;/code>, &lt;code>(row + 1, col)&lt;/code>, or &lt;code>(row + 1, col + 1)&lt;/code>.&lt;/p></description></item><item><title>[LeetCode] 70. Climbing Stairs</title><link>https://intervalrain.github.io/leetcode/70/</link><pubDate>Mon, 12 Dec 2022 22:43:20 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/70/</guid><description>&lt;p>&lt;strong>70. Climbing Stairs&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Math&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Memoization&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are climbing a staircase. It takes &lt;code>n&lt;/code> steps to reach the top.&lt;br>
Each time you can either climb &lt;code>1&lt;/code> or &lt;code>2&lt;/code> steps. In how many distinct ways can you climb to the top?&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> n = 2&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 2&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> There are two ways to climb to the top.&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>1 step + 1 step&lt;/li>
&lt;li>2 steps&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2501. Longest Square Streak in an Array</title><link>https://intervalrain.github.io/leetcode/2501/</link><pubDate>Sun, 11 Dec 2022 22:42:14 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2501/</guid><description>&lt;p>&lt;strong>2501. Longest Square Streak in an Array&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Binary Search&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 323}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an integer array &lt;code>nums&lt;/code>. A subsequence of &lt;code>nums&lt;/code> is called a &lt;strong>square streak&lt;/strong> if:&lt;/p>
&lt;ul>
&lt;li>The length of the subsequence is at least &lt;code>2&lt;/code>, and&lt;/li>
&lt;li>&lt;strong>after&lt;/strong> sorting the subsequence, each element (except the first element) is the &lt;strong>square&lt;/strong> of the previous number.&lt;br>
Return &lt;em>the length of the &lt;strong>longest square streak&lt;/strong> in &lt;code>nums&lt;/code>, or return &lt;code>-1&lt;/code> if there is no &lt;strong>square streak&lt;/strong>&lt;/em>.&lt;br>
A &lt;strong>subsequence&lt;/strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2500. Delete Greatest Value in Each Row</title><link>https://intervalrain.github.io/leetcode/2500/</link><pubDate>Sun, 11 Dec 2022 22:42:12 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2500/</guid><description>&lt;p>&lt;strong>2500. Delete Greatest Value in Each Row&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Binary Search&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 323}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an &lt;code>m x n&lt;/code> matrix &lt;code>grid&lt;/code> consisting of positive integers.&lt;br>
Perform the following operation until &lt;code>grid&lt;/code> becomes empty:&lt;/p>
&lt;ul>
&lt;li>Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.&lt;/li>
&lt;li>Add the maximum of deleted elements to the answer.&lt;br>
&lt;strong>Note&lt;/strong> that the number of columns decreases by one after each operation.&lt;br>
Return &lt;em>the answer after performing the operations described above&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="q1ex1" loading="lazy" src="https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg">&lt;/p></description></item><item><title>[LeetCode] 124. Binary Tree Maximum Path Sum</title><link>https://intervalrain.github.io/leetcode/124/</link><pubDate>Sun, 11 Dec 2022 21:53:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/124/</guid><description>&lt;p>&lt;strong>124. Binary Tree Maximum Path Sum&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Dynamic Programming&lt;/code>、&lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Binary Tree&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;ul>
&lt;li>A &lt;strong>path&lt;/strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence &lt;strong>at most once&lt;/strong>. Note that the path does not need to pass through the root.&lt;br>
The &lt;strong>path sum&lt;/strong> of a path is the sum of the node&amp;rsquo;s values in the path.&lt;br>
Given the &lt;code>root&lt;/code> of a binary tree, return &lt;em>the maximum &lt;strong>path sum&lt;/strong> of any &lt;strong>non-empty&lt;/strong> path&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="exx1" loading="lazy" src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg">&lt;/p></description></item><item><title>[LeetCode] 1339. Maximum Product of Splitted Binary Tree</title><link>https://intervalrain.github.io/leetcode/1339/</link><pubDate>Sat, 10 Dec 2022 20:12:36 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1339/</guid><description>&lt;p>&lt;strong>1339. Maximum Product of Splitted Binary Tree&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Binary Tree&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the &lt;code>root&lt;/code> of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.&lt;br>
Return &lt;em>the maximum product of the sums of the two subtrees&lt;/em>. Since the answer may be too large, return it &lt;strong>modulo&lt;/strong> &lt;code>10^9 + 7&lt;/code>.&lt;br>
&lt;strong>Note&lt;/strong> that you need to maximize the answer before taking the mod and not after taking it.&lt;/p></description></item><item><title>[LeetCode] 1026. Maximum Difference Between Node and Ancestor</title><link>https://intervalrain.github.io/leetcode/1026/</link><pubDate>Sat, 10 Dec 2022 00:49:10 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1026/</guid><description>&lt;p>&lt;strong>1026. Maximum Difference Between Node and Ancestor&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Binary Tree&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the &lt;code>root&lt;/code> of a binary tree, find the maximum value &lt;code>v&lt;/code> for which there exist &lt;strong>different&lt;/strong> nodes &lt;code>a&lt;/code> and &lt;code>b&lt;/code> where &lt;code>v = |a.val - b.val|&lt;/code> and &lt;code>a&lt;/code> is an ancestor of &lt;code>b&lt;/code>.&lt;br>
A node &lt;code>a&lt;/code> is an ancestor of &lt;code>b&lt;/code> if either: any child of &lt;code>a&lt;/code> is equal to &lt;code>b&lt;/code> or any child of &lt;code>a&lt;/code> is an ancestor of &lt;code>b&lt;/code>.&lt;/p></description></item><item><title>[LeetCode] 872. Leaf-Similar Trees</title><link>https://intervalrain.github.io/leetcode/872/</link><pubDate>Thu, 08 Dec 2022 21:41:10 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/872/</guid><description>&lt;p>&lt;strong>872. Leaf-Similar Trees&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Binary Tree&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Consider all the leaves of a binary tree, from left to right order, the values of those leaves form &lt;strong>a leaf value sequence&lt;/strong>.
&lt;img alt="tree" loading="lazy" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png">
For example, in the given tree above, the leaf value sequence is &lt;code>(6, 7, 4, 9, 8)&lt;/code>.&lt;br>
Two binary trees are considered leaf-similar if their leaf value sequence is the same.&lt;br>
Return &lt;code>true&lt;/code> if and only if the two given trees with head nodes &lt;code>root1&lt;/code> and &lt;code>root2&lt;/code> are leaf-similar.&lt;/p></description></item><item><title>[LeetCode] 938. Range Sum of BST</title><link>https://intervalrain.github.io/leetcode/938/</link><pubDate>Wed, 07 Dec 2022 23:41:31 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/938/</guid><description>&lt;p>&lt;strong>938. Range Sum of BST&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Binary Search Tree&lt;/code>、&lt;code>Binary Tree&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the &lt;code>root&lt;/code> node of a binary search tree and two integers &lt;code>low&lt;/code> and &lt;code>high&lt;/code>, return &lt;em>the sum of values of all nodes with a value in the &lt;em>&lt;strong>inclusive&lt;/strong>&lt;/em> range&lt;/em> &lt;code>[low, high]&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="bst1" loading="lazy" src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> root = [10,5,15,3,7,null,18], low = 7, high = 15&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 32&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>
&lt;img alt="bst2" loading="lazy" src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg">&lt;/p></description></item><item><title>[LeetCode] 328. Odd Even Linked List</title><link>https://intervalrain.github.io/leetcode/328/</link><pubDate>Tue, 06 Dec 2022 23:56:11 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/328/</guid><description>&lt;p>&lt;strong>328. Odd Even Linked List&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Linked List&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the &lt;code>head&lt;/code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return &lt;em>the reordered list&lt;/em>.&lt;br>
The &lt;strong>first&lt;/strong> node is considered &lt;strong>odd&lt;/strong>, and the &lt;strong>second&lt;/strong> node is &lt;strong>even&lt;/strong>, and so on.&lt;br>
Note that the relative order inside both the even and odd groups should remain as it was in the input.&lt;br>
You must solve the problem in &lt;code>O(1)&lt;/code> extra space complexity and &lt;code>O(n)&lt;/code> time complexity.&lt;/p></description></item><item><title>[LeetCode] 2472. Maximum Number of Non-overlapping Palindrome Substrings</title><link>https://intervalrain.github.io/leetcode/2472/</link><pubDate>Tue, 29 Nov 2022 23:55:22 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2472/</guid><description>&lt;p>&lt;strong>2472. Maximum Number of Non-overlapping Palindrome Substrings&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{weekly Contest 319}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a string &lt;code>s&lt;/code> and a &lt;strong>positive&lt;/strong> integer &lt;code>k&lt;/code>.
Select a set of &lt;strong>non-overlapping&lt;/strong> substrings from the string &lt;code>s&lt;/code> that satisfy the following conditions:&lt;/p>
&lt;ul>
&lt;li>The &lt;strong>length&lt;/strong> of each substring is &lt;strong>at least&lt;/strong> &lt;code>k&lt;/code>.&lt;/li>
&lt;li>Each substring is a &lt;strong>palindrome&lt;/strong>.
Return &lt;em>the &lt;em>&lt;strong>maximum&lt;/strong>&lt;/em> number of substrings in an optimal selection&lt;/em>.
A &lt;strong>substring&lt;/strong> is a contiguous sequence of characters within a string.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level</title><link>https://intervalrain.github.io/leetcode/2471/</link><pubDate>Tue, 29 Nov 2022 23:55:20 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2471/</guid><description>&lt;p>&lt;strong>2471. Minimum Number of Operations to Sort a Binary Tree by Level&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Tree&lt;/code>、&lt;code>Breadth-First Search&lt;/code>、&lt;code>Binary Tree&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{weekly Contest 319}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given the &lt;code>root&lt;/code> of a binary tree with &lt;strong>unique values&lt;/strong>.
In one operation, you can choose any two nodes &lt;strong>at the same level&lt;/strong> and swap their values.
Return &lt;em>the minimum number of operations needed to make the values at each level sorted in a &lt;em>&lt;strong>strictly increasing order&lt;/strong>&lt;/em>&lt;/em>.
The &lt;strong>level&lt;/strong> of a node is the number of edges along the path between it and the root node.&lt;/p></description></item><item><title>[LeetCode] 2470. Number of Subarrays With LCM Equal to K</title><link>https://intervalrain.github.io/leetcode/2470/</link><pubDate>Tue, 29 Nov 2022 23:55:18 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2470/</guid><description>&lt;p>&lt;strong>2470. Number of Subarrays With LCM Equal to K&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Math&lt;/code>、&lt;code>Number Theory&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{weekly Contest 319}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return &lt;em>the number of &lt;em>&lt;strong>subarrays&lt;/strong>&lt;/em> of &lt;code>nums&lt;/code> where the least common multiple of the subarray&amp;rsquo;s elements is&lt;/em> &lt;code>k&lt;/code>.
A &lt;strong>subarray&lt;/strong> is a contiguous non-empty sequence of elements within an array.
The &lt;strong>least common multiple of an array&lt;/strong> is the smallest positive integer that is divisible by all the array elements.&lt;/p></description></item><item><title>[LeetCode] 2469. Convert the Temperature</title><link>https://intervalrain.github.io/leetcode/2469/</link><pubDate>Tue, 29 Nov 2022 23:55:11 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2469/</guid><description>&lt;p>&lt;strong>2469. Convert the Temperature&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Math&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{weekly Contest 319}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a non-negative floating point number rounded to two decimal places &lt;code>celsius&lt;/code>, that denotes the &lt;strong>temperature in Celsius&lt;/strong>.
You should convert Celsius into &lt;strong>Kelvin&lt;/strong> and &lt;strong>Fahrenheit&lt;/strong> and return it as an array &lt;code>ans = [kelvin, fahrenheit]&lt;/code>.
Return &lt;em>the array &lt;code>ans&lt;/code>&lt;/em>. Answers within &lt;code>10^-5&lt;/code> of the actual answer will be accepted.
&lt;strong>Note that:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>Kelvin = Celsius + 273.15&lt;/code>&lt;/li>
&lt;li>&lt;code>Fahrenheit = Celsius * 1.80 + 32.00&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 446. Arithmetic Slices II - Subsequence</title><link>https://intervalrain.github.io/leetcode/446/</link><pubDate>Mon, 28 Nov 2022 23:39:03 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/446/</guid><description>&lt;p>&lt;strong>446. Arithmetic Slices II - Subsequence&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array &lt;code>nums&lt;/code>, return &lt;em>the number of all the &lt;em>&lt;strong>arithmetic subsequences&lt;/strong>&lt;/em> of&lt;/em> &lt;code>nums&lt;/code>.
A sequence of numbers is called arithmetic if it consists of &lt;strong>at least three elements&lt;/strong> and if the difference between any two consecutive elements is the same.&lt;/p>
&lt;ul>
&lt;li>For example, &lt;code>[1, 3, 5, 7, 9]&lt;/code>, &lt;code>[7, 7, 7, 7]&lt;/code>, and &lt;code>[3, -1, -5, -9]&lt;/code> are arithmetic sequences.&lt;/li>
&lt;li>For example, &lt;code>[1, 1, 2, 5, 7]&lt;/code> is not an arithmetic sequence.
A &lt;strong>subsequence&lt;/strong> of an array is a sequence that can be formed by removing some elements (possibly none) of the array.&lt;/li>
&lt;li>For example, &lt;code>[2,5,10]&lt;/code> is a subsequence of &lt;code>[1,2,1,2,4,1,5,10]&lt;/code>.
The test cases are generated so that the answer fits in &lt;strong>32-bit&lt;/strong> integer.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2488. Count Subarrays With Median K</title><link>https://intervalrain.github.io/leetcode/2488/</link><pubDate>Sun, 27 Nov 2022 21:04:55 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2488/</guid><description>&lt;p>&lt;strong>2488. Count Subarrays With Median K&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Prefix Sum&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 321}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an array &lt;code>nums&lt;/code> of size &lt;code>n&lt;/code> consisting of &lt;strong>distinct&lt;/strong> integers from &lt;code>1&lt;/code> to &lt;code>n&lt;/code> and a positive integer &lt;code>k&lt;/code>.&lt;br>
Return &lt;em>the number of non-empty subarrays in &lt;code>nums&lt;/code> that have a &lt;em>&lt;strong>median&lt;/strong>&lt;/em> equal to k.&lt;/em>
&lt;strong>Note:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>The median of an array is the &lt;strong>middle&lt;/strong> element after sorting the array in &lt;strong>ascending&lt;/strong> order. If the array is of even length, the median is the &lt;strong>left&lt;/strong> middle element.
&lt;ul>
&lt;li>For example, the median of &lt;code>[2,3,1,4]&lt;/code> is &lt;code>2&lt;/code>, and the median of &lt;code>[8,4,3,5,1]&lt;/code> is &lt;code>4&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>A subarray is a contiguous part of an array.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2487. Remove Nodes From Linked List</title><link>https://intervalrain.github.io/leetcode/2487/</link><pubDate>Sun, 27 Nov 2022 21:04:51 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2487/</guid><description>&lt;p>&lt;strong>2487. Remove Nodes From Linked List&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Linked List&lt;/code>、&lt;code>Stack&lt;/code>、&lt;code>Recursion&lt;/code>、&lt;code>Monotonic Stack&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 321}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given the &lt;code>head&lt;/code> of a linked list.&lt;br>
Remove every node which has a node with &lt;strong>strictly greater&lt;/strong> value anywhere to the right side of it.&lt;br>
Return &lt;em>the &lt;code>head&lt;/code> of the modified linked list&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="drawio" loading="lazy" src="https://assets.leetcode.com/uploads/2022/10/02/drawio.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> head = [5,2,13,3,8]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [13,8]&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The nodes that should be removed are 5, 2 and 3.&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>Node 13 is to the right of node 5.&lt;/li>
&lt;li>Node 13 is to the right of node 2.&lt;/li>
&lt;li>Node 8 is to the right of node 3.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2486. Accept Characters to String to Make Subsequence</title><link>https://intervalrain.github.io/leetcode/2486/</link><pubDate>Sun, 27 Nov 2022 21:04:50 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2486/</guid><description>&lt;p>&lt;strong>2486. Accept Characters to String to Make Subsequence&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Two Pointer&lt;/code>、&lt;code>String&lt;/code>、&lt;code>Greedy&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 321}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;ul>
&lt;li>You are given two strings &lt;code>s&lt;/code> and &lt;code>t&lt;/code> consisting of only lowercase English letters.
Return &lt;em>the minimum number of characters that need to be appended to the end of &lt;code>s&lt;/code> so that &lt;code>t&lt;/code> becomes a &lt;em>&lt;strong>subsequence&lt;/strong>&lt;/em> of &lt;code>s&lt;/code>.&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>A &lt;strong>subsequence&lt;/strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.&lt;/p></description></item><item><title>[LeetCode] 2485. Find the Pivot Integer</title><link>https://intervalrain.github.io/leetcode/2485/</link><pubDate>Sun, 27 Nov 2022 21:04:47 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2485/</guid><description>&lt;p>&lt;strong>2485. Find the Pivot Integer&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Math&lt;/code>、&lt;code>Prefix Sum&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 321}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a positive integer &lt;code>n&lt;/code>, find the &lt;strong>pivot integer&lt;/strong> &lt;code>x&lt;/code> such that:&lt;/p>
&lt;ul>
&lt;li>The sum of all elements between &lt;code>1&lt;/code> and &lt;code>x&lt;/code> inclusively equals the sum of all elements between &lt;code>x&lt;/code> and &lt;code>n&lt;/code> inclusively.
Return &lt;em>the pivot integer&lt;/em> &lt;code>x&lt;/code>. If no such integer exists, return &lt;code>-1&lt;/code>. It is guaranteed that there will be at most one pivot index for the given input.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1235. Maximum Profit in Job Scheduling</title><link>https://intervalrain.github.io/leetcode/1235/</link><pubDate>Sat, 26 Nov 2022 14:09:56 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1235/</guid><description>&lt;p>&lt;strong>1235. Maximum Profit in Job Scheduling&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Binary Search&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>We have &lt;code>n&lt;/code> jobs, where every job is scheduled to be done from &lt;code>startTime[i]&lt;/code> to &lt;code>endTime[i]&lt;/code>, obtaining a profit of &lt;code>profit[i]&lt;/code>.&lt;br>
You&amp;rsquo;re given the &lt;code>startTime&lt;/code>, &lt;code>endTime&lt;/code> and &lt;code>profit&lt;/code> arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.&lt;br>
If you choose a job that ends at time &lt;code>X&lt;/code> you will be able to start another job that starts at time &lt;code>X&lt;/code>.&lt;/p></description></item><item><title>[LeetCode] 1143. Longest Common Subsequence</title><link>https://intervalrain.github.io/leetcode/1143/</link><pubDate>Thu, 24 Nov 2022 23:15:24 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1143/</guid><description>&lt;p>&lt;strong>1143. Longest Common Subsequence&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given two strings &lt;code>text1&lt;/code> and &lt;code>text2&lt;/code>, return &lt;em>the length of their longest &lt;strong>common subsequence&lt;/strong>&lt;/em>. If there is no &lt;strong>common subsequence&lt;/strong>, return &lt;code>0&lt;/code>.
A &lt;strong>subsequence&lt;/strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.&lt;/p>
&lt;ul>
&lt;li>For example, &lt;code>&amp;quot;ace&amp;quot;&lt;/code> is a subsequence of &lt;code>&amp;quot;abcde&amp;quot;&lt;/code>.
A &lt;strong>common subsequence&lt;/strong> of two strings is a subsequence that is common to both strings.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 300. Longest Increasing Subsequence</title><link>https://intervalrain.github.io/leetcode/300/</link><pubDate>Thu, 24 Nov 2022 20:59:40 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/300/</guid><description>&lt;p>&lt;strong>300. Longest Increasing Subsequence&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Binary Search&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array &lt;code>nums&lt;/code>, return &lt;em>the length of the longest &lt;em>&lt;strong>strictly increasing subsequence&lt;/strong>&lt;/em>&lt;/em>&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [10,9,2,5,3,7,101,18]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 4&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [0,1,0,3,2,3]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 4&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [7,7,7,7,7,7,7]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 1&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= nums.length &amp;lt;= 2500&lt;/code>&lt;/li>
&lt;li>&lt;code>-104 &amp;lt;= nums[i] &amp;lt;= 104&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Follow up:&lt;/strong> Can you come up with an algorithm that runs in &lt;code>O(n log n)&lt;/code> time complexity&lt;/p></description></item><item><title>[LeetCode] 2468. Split Message Based on Limit</title><link>https://intervalrain.github.io/leetcode/2468/</link><pubDate>Thu, 24 Nov 2022 01:09:57 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2468/</guid><description>&lt;p>&lt;strong>2468. Split Message Based on Limit&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Binary Search&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Biweekly Contest 91}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a string, &lt;code>message&lt;/code>, and a positive integer, &lt;code>limit&lt;/code>.&lt;/p>
&lt;p>You must &lt;strong>split&lt;/strong> &lt;code>message&lt;/code> into one or more &lt;strong>parts&lt;/strong> based on &lt;code>limit&lt;/code>. Each resulting part should have the suffix &lt;code>&amp;quot;&amp;lt;a/b&amp;gt;&amp;quot;&lt;/code>, where &lt;code>&amp;quot;b&amp;quot;&lt;/code> is to be &lt;strong>replaced&lt;/strong> with the total number of parts and &lt;code>&amp;quot;a&amp;quot;&lt;/code> is to be &lt;strong>replaced&lt;/strong> with the index of the part, starting from &lt;code>1&lt;/code> and going up to &lt;code>b&lt;/code>. Additionally, the length of each resulting part (including its suffix) should be &lt;strong>equal&lt;/strong> to &lt;code>limit&lt;/code>, except for the last part whose length can be &lt;strong>at most&lt;/strong> &lt;code>limit&lt;/code>.&lt;/p></description></item><item><title>[LeetCode] 2467. Most Profitable Path in a Tree</title><link>https://intervalrain.github.io/leetcode/2467/</link><pubDate>Thu, 24 Nov 2022 01:09:51 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2467/</guid><description>&lt;p>&lt;strong>2467. Most Profitable Path in a Tree&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Breadth-First Search&lt;/code>、&lt;code>Graph&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Biweekly Contest 91}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>There is an undirected tree with &lt;code>n&lt;/code> nodes labeled from &lt;code>0&lt;/code> to &lt;code>n - 1&lt;/code>, rooted at node &lt;code>0&lt;/code>. You are given a 2D integer array &lt;code>edges&lt;/code> of length &lt;code>n - 1&lt;/code> where &lt;code>edges[i] = [ai, bi]&lt;/code> indicates that there is an edge between nodes &lt;code>ai&lt;/code> and &lt;code>bi&lt;/code> in the tree.
At every node &lt;code>i&lt;/code>, there is a gate. You are also given an array of even integers &lt;code>amount&lt;/code>, where &lt;code>amount[i]&lt;/code> represents:&lt;/p></description></item><item><title>[LeetCode] 1926. Nearest Exit from Entrance in Maze</title><link>https://intervalrain.github.io/leetcode/1926/</link><pubDate>Tue, 22 Nov 2022 23:41:58 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1926/</guid><description>&lt;p>&lt;strong>1926. Nearest Exit from Entrance in Maze&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Breadth-First Search&lt;/code>、&lt;code>Matrix&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an &lt;code>m x n&lt;/code> matrix &lt;code>maze&lt;/code> (&lt;strong>0-indexed&lt;/strong>) with empty cells (represented as &lt;code>'.'&lt;/code>) and walls (represented as &lt;code>'+'&lt;/code>). You are also given the &lt;code>entrance&lt;/code> of the maze, where &lt;code>entrance = [entrancerow, entrancecol]&lt;/code> denotes the row and column of the cell you are initially standing at.&lt;/p>
&lt;p>In one step, you can move one cell &lt;strong>up&lt;/strong>, &lt;strong>down&lt;/strong>, &lt;strong>left&lt;/strong>, or &lt;strong>right&lt;/strong>. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the &lt;code>entrance&lt;/code>. An &lt;strong>exit&lt;/strong> is defined as an &lt;strong>empty cell&lt;/strong> that is at the &lt;strong>border&lt;/strong> of the &lt;code>maze&lt;/code>. The &lt;code>entrance&lt;/code> &lt;strong>does not count&lt;/strong> as an exit.&lt;/p></description></item><item><title>[LeetCode] 279. Perfect Squares</title><link>https://intervalrain.github.io/leetcode/279/</link><pubDate>Tue, 22 Nov 2022 19:40:18 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/279/</guid><description>&lt;p>&lt;strong>279. Perfect Squares&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Math&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Breadth-First Search&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer &lt;code>n&lt;/code>, return &lt;em>the least number of perfect square numbers that sum to&lt;/em> &lt;code>n&lt;/code>.
A &lt;strong>perfect square&lt;/strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, &lt;code>1&lt;/code>, &lt;code>4&lt;/code>, &lt;code>9&lt;/code>, and &lt;code>16&lt;/code> are perfect squares while &lt;code>3&lt;/code> and &lt;code>11&lt;/code> are not.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 337. House Robber III</title><link>https://intervalrain.github.io/leetcode/337/</link><pubDate>Sat, 19 Nov 2022 21:43:08 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/337/</guid><description>&lt;p>&lt;strong>337. House Robber III&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Dynamic Programming&lt;/code>、&lt;code>Tree&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Binary Tree&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called &lt;code>root&lt;/code>.
Besides the &lt;code>root&lt;/code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if &lt;strong>two directly-linked houses were broken into on the same night&lt;/strong>.
Given the &lt;code>root&lt;/code> of the binary tree, return &lt;em>the maximum amount of money the thief can rob &lt;em>&lt;strong>without alerting the police&lt;/strong>&lt;/em>&lt;/em>.&lt;/p></description></item><item><title>[LeetCode] 587. Erect the Fence</title><link>https://intervalrain.github.io/leetcode/587/</link><pubDate>Sat, 19 Nov 2022 16:56:09 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/587/</guid><description>&lt;p>&lt;strong>587. Erect the Rence&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Math&lt;/code>、&lt;code>Geometry&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an array &lt;code>trees&lt;/code> where &lt;code>trees[i] = [xi, yi]&lt;/code> represents the location of a tree in the garden.
You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only &lt;strong>if all the trees are enclosed&lt;/strong>.
Return &lt;em>the coordinates of trees that are exactly located on the fence perimeter&lt;/em>.&lt;/p></description></item><item><title>[LeetCode] 322. Coin Change</title><link>https://intervalrain.github.io/leetcode/322/</link><pubDate>Thu, 17 Nov 2022 21:31:45 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/322/</guid><description>&lt;p>&lt;strong>322. Coin Change&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Breadth-First Search&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an integer array &lt;code>coins&lt;/code> representing coins of different denominations and an integer &lt;code>amount&lt;/code> representing a total amount of money.
Return &lt;em>the fewest number of coins that you need to make up that amount&lt;/em>. If that amount of money cannot be made up by any combination of the coins, return &lt;code>-1&lt;/code>.
You may assume that you have an infinite number of each kind of coin.&lt;/p></description></item><item><title>[LeetCode] 2466. Count Ways To Build Good Strings</title><link>https://intervalrain.github.io/leetcode/2466/</link><pubDate>Thu, 17 Nov 2022 21:23:24 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2466/</guid><description>&lt;p>&lt;strong>2466. Count Ways To Build Good Strings&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Biweekly Contest 91}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the integers &lt;code>zero&lt;/code>, &lt;code>one&lt;/code>, &lt;code>low&lt;/code>, and &lt;code>high&lt;/code>, we can construct a string by starting with an empty string, and then at each step perform either of the following:&lt;/p>
&lt;ul>
&lt;li>Append the character &lt;code>'0'&lt;/code> &lt;code>zero&lt;/code> times.&lt;/li>
&lt;li>Append the character &lt;code>'1'&lt;/code> &lt;code>one&lt;/code> times.
This can be performed any number of times.
A &lt;strong>good&lt;/strong> string is a string constructed by the above process having a &lt;strong>length&lt;/strong> between &lt;code>low&lt;/code> and &lt;code>high&lt;/code> (&lt;strong>inclusive&lt;/strong>).
Return &lt;em>the number of &lt;em>&lt;strong>different&lt;/strong>&lt;/em> good strings that can be constructed satisfying these properties&lt;/em>. Since the answer can be large, return it &lt;strong>modulo&lt;/strong> &lt;code>10^9 + 7&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2465. Number of Distinct Averages</title><link>https://intervalrain.github.io/leetcode/2465/</link><pubDate>Thu, 17 Nov 2022 21:00:05 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2465/</guid><description>&lt;p>&lt;strong>2465. Number of Distinct Averages&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Two Pointers&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Biweekly Contest 91}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a &lt;strong>0-indexed&lt;/strong> integer array &lt;code>nums&lt;/code> of &lt;strong>even&lt;/strong> length.
As long as &lt;code>nums&lt;/code> is &lt;strong>not&lt;/strong> empty, you must repetitively:&lt;/p>
&lt;ul>
&lt;li>Find the minimum number in &lt;code>nums&lt;/code> and remove it.&lt;/li>
&lt;li>Find the maximum number in &lt;code>nums&lt;/code> and remove it.&lt;/li>
&lt;li>Calculate the average of the two removed numbers.
The &lt;strong>average&lt;/strong> of two numbers &lt;code>a&lt;/code> and &lt;code>b&lt;/code> is &lt;code>(a + b) / 2&lt;/code>.&lt;/li>
&lt;li>For example, the average of &lt;code>2&lt;/code> and &lt;code>3&lt;/code> is &lt;code>(2 + 3) / 2 = 2.5&lt;/code>.
Return &lt;em>the number of &lt;em>&lt;strong>distinct&lt;/strong>&lt;/em> averages calculated using the above process&lt;/em>.
&lt;strong>Note&lt;/strong> that when there is a tie for a minimum or maximum number, any can be removed.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 223. Rectangle Area</title><link>https://intervalrain.github.io/leetcode/223/</link><pubDate>Thu, 17 Nov 2022 20:39:17 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/223/</guid><description>&lt;p>&lt;strong>223. Rectangle Area&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Math&lt;/code>、&lt;code>Geometry&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the coordinates of two &lt;strong>rectilinear&lt;/strong> rectangles in a 2D plane, return &lt;em>the total area covered by the two rectangles.&lt;/em>
The first rectangle is defined by its &lt;strong>bottom-left&lt;/strong> corner &lt;code>(ax1, ay1)&lt;/code> and its &lt;strong>top-right&lt;/strong> corner &lt;code>(ax2, ay2)&lt;/code>.
The second rectangle is defined by its &lt;strong>bottom-left&lt;/strong> corner &lt;code>(bx1, by1)&lt;/code> and tis &lt;strong>top-right&lt;/strong> corner &lt;code>(bx2, by2)&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="rectangle-plane" loading="lazy" src="https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 45&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 374. Guess Number Higher or Lower</title><link>https://intervalrain.github.io/leetcode/374/</link><pubDate>Wed, 16 Nov 2022 22:57:11 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/374/</guid><description>&lt;p>&lt;strong>374. Guess Number Higher or Lower&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Binary Search&lt;/code>、&lt;code>Interactive&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>We are playing the Guess Game. The game is as follows:
I pick a number from &lt;code>1&lt;/code> to &lt;code>n&lt;/code>. You have to guess which number I picked.
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
You call a pre-defined API &lt;code>int guess(int num)&lt;/code>, which returns three possible results:&lt;/p></description></item><item><title>[LeetCode] 213. House Robber II</title><link>https://intervalrain.github.io/leetcode/213/</link><pubDate>Tue, 15 Nov 2022 23:45:49 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/213/</guid><description>&lt;p>&lt;strong>213. House Robber II&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are &lt;strong>arranged in a circle&lt;/strong>. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and &lt;strong>it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 198. House Robber</title><link>https://intervalrain.github.io/leetcode/198/</link><pubDate>Tue, 15 Nov 2022 23:33:01 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/198/</guid><description>&lt;p>&lt;strong>198. House Robber&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and &lt;strong>it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/strong>
Given an integer array &lt;code>nums&lt;/code> representing the amount of money of each house, return &lt;em>the maximum amount of money you can rob tonight&lt;/em> &lt;em>&lt;strong>without alerting the police&lt;/strong>&lt;/em>.&lt;/p></description></item><item><title>[LeetCode] 947. Most Stones Removed with Same Row or Column</title><link>https://intervalrain.github.io/leetcode/947/</link><pubDate>Tue, 15 Nov 2022 00:12:30 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/947/</guid><description>&lt;p>&lt;strong>947. Most Stones Removed with Same Row or Column&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Depth-First Search&lt;/code>、&lt;code>Union Find&lt;/code>、&lt;code>Graph&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>On a 2D plane, we place &lt;code>n&lt;/code> stones at some integer coordinate points. Each coordinate point may have at most one stone.
A stone can be removed if it shares either &lt;strong>the same row or the same column&lt;/strong> as another stone that has not been removed.
Given an array &lt;code>stones&lt;/code> of length &lt;code>n&lt;/code> where &lt;code>stones[i] = [xi, yi]&lt;/code> represents the location of the &lt;code>ith&lt;/code> stone, return &lt;em>the largest possible number of stones that can be removed&lt;/em>.&lt;/p></description></item><item><title>[LeetCode] 151. Reverse Words in a String</title><link>https://intervalrain.github.io/leetcode/151/</link><pubDate>Sun, 13 Nov 2022 17:35:59 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/151/</guid><description>&lt;p>&lt;strong>151. Reverse Words in a String&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Two Pointers&lt;/code>、&lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an input string &lt;code>s&lt;/code>, reverse the order of the &lt;strong>words&lt;/strong>.&lt;br>
A &lt;strong>word&lt;/strong> is defined as a sequence of non-space characters. The &lt;strong>words&lt;/strong> in &lt;code>s&lt;/code> will be separated by at least one space.&lt;br>
Return &lt;em>a string of the words in reverse order concatenated by a single space&lt;/em>.
&lt;strong>Note&lt;/strong> that &lt;code>s&lt;/code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.&lt;/p></description></item><item><title>[LeetCode] 23. Merge k Sorted Lists</title><link>https://intervalrain.github.io/leetcode/23/</link><pubDate>Fri, 11 Nov 2022 00:24:47 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/23/</guid><description>&lt;p>&lt;strong>23. Merge k Sorted Lists&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Linked List&lt;/code>、&lt;code>Divide and Conquer&lt;/code>、&lt;code>Heap (Priority Queue)&lt;/code>、&lt;code>Merge Sort&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an array of &lt;code>k&lt;/code> linked-lists &lt;code>lists&lt;/code>, each linked-list is sorted in ascending order.
&lt;em>Merge all the linked-lists into one sorted linked-list and return it&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> lists = [[1,4,5],[1,3,4],[2,6]]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [1,1,2,3,4,4,5,6]&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The linked-lists are:&lt;br>
[&lt;br>
1-&amp;gt;4-&amp;gt;5,&lt;br>
1-&amp;gt;3-&amp;gt;4,&lt;br>
2-&amp;gt;6&lt;br>
]&lt;br>
merging them into one sorted list:&lt;br>
1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 22. Generate Parentheses</title><link>https://intervalrain.github.io/leetcode/22/</link><pubDate>Thu, 10 Nov 2022 23:44:24 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/22/</guid><description>&lt;p>&lt;strong>22. Generate Parentheses&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Backtracking&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given &lt;code>n&lt;/code> pairs of parentheses, write a function to &lt;em>generate all combinations of well-formed parentheses&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> n = 3&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> n = 1&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [&amp;quot;()&amp;quot;]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= n &amp;lt;= 8&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="二分析">二、分析&lt;/h3>
&lt;ul>
&lt;li>DFS 演算法是在遍歷「節點」，而回溯法是在遍歷「樹枝」。站在一個節點上，需思考三個問題：
&lt;ol>
&lt;li>路徑(PATH)：已做出的選擇。&lt;/li>
&lt;li>選項(OPTION)：當前可以做的選擇。&lt;/li>
&lt;li>終止條件(TERMINATE)：到達決策樹的底層，無法再做其它選擇。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>以下為回溯法的框架：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>PATH&lt;span style="color:#f92672">&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">backtrack&lt;/span>(PATH, OPTION) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TERMINATE) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.push_back(PATH);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (CHOICE : OPTION) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DO OPTION;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> backtrack(PATH, OPTION);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CANCEL OPTION;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>本題的終止條件是當 &lt;code>path&lt;/code> 的長度為 &lt;code>2n&lt;/code> 的時候。&lt;/li>
&lt;li>而選項是增加&lt;strong>左括號&lt;/strong> &lt;code>(&lt;/code> 與增加&lt;strong>右括號&lt;/strong> &lt;code>)&lt;/code>。&lt;/li>
&lt;li>加上兩個子節點的條件便完成，
&lt;ul>
&lt;li>左節點需滿足 &lt;code>left &amp;lt; n&lt;/code>。&lt;/li>
&lt;li>右節點需滿足 &lt;code>right &amp;lt; n &amp;amp;&amp;amp; right &amp;lt; left&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>DP 動態規劃則需觀察轉移方程式。
&lt;ul>
&lt;li>&lt;code>dp[0]&lt;/code> base case： ``&lt;/li>
&lt;li>&lt;code>dp[1]&lt;/code> 很容易得到：&lt;code>()&lt;/code>&lt;/li>
&lt;li>&lt;code>dp[2]&lt;/code> 也不難：&lt;code>()()&lt;/code>、&lt;code>(())&lt;/code>
接下來觀察 &lt;code>dp[3]&lt;/code>，可以分解為下面三個：
&lt;ol>
&lt;li>&lt;code>(&lt;/code> + dp[0] + &lt;code>)&lt;/code> + dp[2]：&lt;code>()()()&lt;/code>、&lt;code>()(())&lt;/code>&lt;/li>
&lt;li>&lt;code>(&lt;/code> + dp[1] + &lt;code>)&lt;/code> + dp[1]：&lt;code>(())()&lt;/code>&lt;/li>
&lt;li>&lt;code>(&lt;/code> + dp[2] + &lt;code>)&lt;/code> + dp[0]：&lt;code>(()())&lt;/code>、&lt;code>((()))&lt;/code>
換句話說，轉移方程式可以寫成：&lt;code>dp[i] = &amp;quot;(&amp;quot; + dp[j] + &amp;quot;)&amp;quot; + dp[i-j-1]&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="三解題">三、解題&lt;/h3>
&lt;h4 id="1-backtrack">1. Backtrack&lt;/h4>
&lt;ul>
&lt;li>Time complexity: \(O(2^{2n})\)，&lt;a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0">Wiki - Catalan number&lt;/a>&lt;/li>
&lt;li>Space complexity: \(O(n)\)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> generateParenthesis(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> backtrack(n, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, res, path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">backtrack&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n, &lt;span style="color:#66d9ef">int&lt;/span> left, &lt;span style="color:#66d9ef">int&lt;/span> right, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> res, string&lt;span style="color:#f92672">&amp;amp;&lt;/span> path) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// terminate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (path.length() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.push_back(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// select
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (left &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.push_back(&lt;span style="color:#e6db74">&amp;#39;(&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> backtrack(n, left&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, right, res, path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.pop_back();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> right &lt;span style="color:#f92672">&amp;lt;&lt;/span> left) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.push_back(&lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> backtrack(n, left, right&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, res, path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path.pop_back();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-dynamic-programming">2. Dynamic Programming&lt;/h4>
&lt;ul>
&lt;li>Time complexity: \(O(n^4)\)&lt;/li>
&lt;li>Space complexity: \(O(n)\)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> generateParenthesis(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> dp(n&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;&lt;/span>i;j&lt;span style="color:#f92672">++&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> dp[j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> dp[i&lt;span style="color:#f92672">-&lt;/span>j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;k&lt;span style="color:#f92672">&amp;lt;&lt;/span>left.size();k&lt;span style="color:#f92672">++&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> l&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;l&lt;span style="color:#f92672">&amp;lt;&lt;/span>right.size();l&lt;span style="color:#f92672">++&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp[i].push_back(&lt;span style="color:#e6db74">&amp;#34;(&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> left[k] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;)&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> right[l]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dp[n];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://intervalrain.github.io/leetcode">回目錄 Catalog&lt;/a>&lt;/p></description></item><item><title>[LeetCode] 21. Merge Two Sorted Lists</title><link>https://intervalrain.github.io/leetcode/21/</link><pubDate>Thu, 10 Nov 2022 20:25:07 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/21/</guid><description>&lt;p>&lt;strong>21. Merge Two Sorted Lists&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Linked List&lt;/code>、&lt;code>Recursion&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given the heads of two sorted linked lists &lt;code>list1&lt;/code> and &lt;code>list2&lt;/code>.&lt;/p>
&lt;p>Merge the two lists in a one &lt;strong>sorted&lt;/strong> list. The list should be made by splicing together the nodes of the first two lists.&lt;/p>
&lt;p>Return &lt;em>the head of the merged linked list&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> list1 = [1,2,4], list2 = [1,3,4]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [1,1,2,3,4,4]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1047. Remove All Adjacent Duplicates In String</title><link>https://intervalrain.github.io/leetcode/1047/</link><pubDate>Thu, 10 Nov 2022 20:01:29 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1047/</guid><description>&lt;p>&lt;strong>1047. Remove All Adjacent Duplicates In String&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Stack&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a string &lt;code>s&lt;/code> consisting of lowercase English letters. A &lt;strong>duplicate removal&lt;/strong> consists of choosing two &lt;strong>adjacent&lt;/strong> and &lt;strong>equal&lt;/strong> letters and removing them.&lt;/p>
&lt;p>We repeatly make &lt;strong>duplicate removals&lt;/strong> on &lt;code>s&lt;/code> until we no longer can.&lt;/p>
&lt;p>Return &lt;em>the final string after all such duplicate removals have been made&lt;/em>. It can be proven that the answer is &lt;strong>unique&lt;/strong>.&lt;/p></description></item><item><title>[LeetCode] 901. Online Stock Span</title><link>https://intervalrain.github.io/leetcode/901/</link><pubDate>Wed, 09 Nov 2022 23:35:42 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/901/</guid><description>&lt;p>&lt;strong>901. Online Stock Span&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Stack&lt;/code>、&lt;code>Design&lt;/code>、&lt;code>Monotonic Stack&lt;/code>、&lt;code>Data Stream&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Design an algorithm that collects daily price quotes for some stock and returns &lt;strong>the span&lt;/strong> of that stock&amp;rsquo;s price for the current day.&lt;/p>
&lt;p>The &lt;strong>span&lt;/strong> of the stock&amp;rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today&amp;rsquo;s price.&lt;/p></description></item><item><title>[LeetCode] 1544. Make The String Great</title><link>https://intervalrain.github.io/leetcode/1544/</link><pubDate>Tue, 08 Nov 2022 23:14:34 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1544/</guid><description>&lt;p>&lt;strong>1544. Make The String Great&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Stack&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a string &lt;code>s&lt;/code> of lower and upper case English letters.&lt;br>
A good string is a string which doesn&amp;rsquo;t have &lt;strong>two adjacent characters&lt;/strong> &lt;code>s[i]&lt;/code> and &lt;code>s[i + 1]&lt;/code> where:&lt;/p>
&lt;ul>
&lt;li>&lt;code>0 &amp;lt;= i &amp;lt;= s.length - 2&lt;/code>&lt;/li>
&lt;li>&lt;code>s[i]&lt;/code> is a lower-case letter and &lt;code>s[i + 1]&lt;/code> is the same letter but in upper-case or &lt;strong>vice-versa&lt;/strong>.&lt;br>
To make the string good, you can choose &lt;strong>two adjacent&lt;/strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.&lt;br>
Return the string after making it good. The answer is guaranteed to be unique under the given constraints.&lt;br>
&lt;strong>Notice&lt;/strong> that an empty string is also good.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2463. Minimum Total Distance Traveled</title><link>https://intervalrain.github.io/leetcode/2463/</link><pubDate>Tue, 08 Nov 2022 23:13:52 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2463/</guid><description>&lt;p>&lt;strong>2463. Minimum Total Distance Traveled&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 318}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>There are some robots and factories on the X-axis. You are given an integer array &lt;code>robot&lt;/code> where &lt;code>robot[i]&lt;/code> is the position of the &lt;code>ith&lt;/code> robot. You are also given a 2D integer array &lt;code>factory&lt;/code> where &lt;code>factory[j] = [positionj, limitj]&lt;/code> indicates that &lt;code>positionj&lt;/code> is the position of the &lt;code>jth&lt;/code> factory and that the &lt;code>jth&lt;/code> factory can repair at most &lt;code>limitj&lt;/code> robots.&lt;/p></description></item><item><title>[LeetCode] 2462. Total Cost to Hire K</title><link>https://intervalrain.github.io/leetcode/2462/</link><pubDate>Tue, 08 Nov 2022 00:53:08 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2462/</guid><description>&lt;p>&lt;strong>2462. Total Cost to Hire K&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Two Pointer&lt;/code>、&lt;code>Heap (Priority Queue)&lt;/code>、&lt;code>Simulation&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 318}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a &lt;strong>0-indexed&lt;/strong> integer array &lt;code>costs&lt;/code> where &lt;code>costs[i]&lt;/code> is the cost of hiring the &lt;code>ith&lt;/code> worker.
You are also given two integers &lt;code>k&lt;/code> and &lt;code>candidates&lt;/code>. We want to hire exactly &lt;code>k&lt;/code> workers according to the following rules:&lt;/p>
&lt;ul>
&lt;li>You will run &lt;code>k&lt;/code> sessions and hire exactly one worker in each session.&lt;/li>
&lt;li>In each hiring session, choose the worker with the lowest cost from either the first &lt;code>candidates&lt;/code> workers or the last &lt;code>candidates&lt;/code> workers. Break the tie by the smallest index.
&lt;ul>
&lt;li>For example, if &lt;code>costs = [3,2,7,7,1,2]&lt;/code> and &lt;code>candidates = 2&lt;/code>, then in the first hiring session, we will choose the &lt;code>4th&lt;/code> worker because they have the lowest cost &lt;code>[3,2,7,7,1,2]&lt;/code>.&lt;/li>
&lt;li>In the second hiring session, we will choose &lt;code>1st&lt;/code> worker because they have the same lowest cost as &lt;code>4th&lt;/code> worker but they have the smallest index &lt;code>[3,2,7,7,2]&lt;/code>. Please note that the indexing may be changed in the process.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.&lt;/li>
&lt;li>A worker can only be chosen once.
Return &lt;em>the total cost to hire exactly&lt;/em> &lt;code>k&lt;/code> &lt;em>workers&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2461. Maximum Sum of Distinct Subarrays With Length K</title><link>https://intervalrain.github.io/leetcode/2461/</link><pubDate>Tue, 08 Nov 2022 00:36:35 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2461/</guid><description>&lt;p>&lt;strong>2461. Maximum Sum of Distinct Subarrays With Length K&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Sliding Window&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 318}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an integer array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>. Find the maximum subarray sum of all the subarrays of &lt;code>nums&lt;/code> that meet the following conditions:&lt;/p>
&lt;ul>
&lt;li>The length of the subarray is &lt;code>k&lt;/code>, and&lt;/li>
&lt;li>All the elements of the subarray are &lt;strong>distinct&lt;/strong>.
Return &lt;em>the maximum subarray sum of all the subarrays that meet the conditions&lt;/em>. If no subarray meets the conditions, return &lt;code>0&lt;/code>.
&lt;em>A&lt;/em> &lt;em>&lt;strong>subarray&lt;/strong>&lt;/em> &lt;em>is a contiguous non-empty sequence of elements within an array.&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2460. Apply Operations to an Array</title><link>https://intervalrain.github.io/leetcode/2460/</link><pubDate>Tue, 08 Nov 2022 00:09:13 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2460/</guid><description>&lt;p>&lt;strong>2460. Apply Operations to an Array&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Simulation&lt;/code>&lt;/li>
&lt;li>\(\color{blue}\textsf{Weekly Contest 318}\)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a &lt;strong>0-indexed&lt;/strong> array &lt;code>nums&lt;/code> of size &lt;code>n&lt;/code> consisting of &lt;strong>non-negative&lt;/strong> integers.
You need to apply &lt;code>n - 1&lt;/code> operations to this array where, in the &lt;code>ith&lt;/code> operation (&lt;strong>0-indexed&lt;/strong>), you will apply the following on the &lt;code>ith&lt;/code> element of &lt;code>nums&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>If &lt;code>nums[i] == nums[i + 1]&lt;/code>, then multiply &lt;code>nums[i]&lt;/code> by &lt;code>2&lt;/code> and set &lt;code>nums[i + 1]&lt;/code> to &lt;code>0&lt;/code>. Otherwise, you skip this operation.
After performing &lt;strong>all&lt;/strong> the operations, &lt;strong>shift&lt;/strong> all the 0&amp;rsquo;s to the &lt;strong>end&lt;/strong> of the array.&lt;/li>
&lt;li>For example, the array &lt;code>[1,0,2,0,0,1]&lt;/code> after shifting all its 0&amp;rsquo;s to the end, is &lt;code>[1,2,1,0,0,0]&lt;/code>.
Return &lt;em>the resulting array&lt;/em>.&lt;/li>
&lt;li>&lt;strong>Note&lt;/strong> that the operations are applied &lt;strong>sequentially&lt;/strong>, not all at once.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1323. Maximum 69 Number</title><link>https://intervalrain.github.io/leetcode/1323/</link><pubDate>Mon, 07 Nov 2022 23:55:31 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1323/</guid><description>&lt;p>&lt;strong>1323. Maximum 69 Number&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Math&lt;/code>、&lt;code>Greedy&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given a positive integer &lt;code>num&lt;/code> consisting only of digits &lt;code>6&lt;/code> and &lt;code>9&lt;/code>.&lt;br>
Return &lt;em>the maximum number you can get by changing&lt;/em> &lt;em>&lt;strong>at most&lt;/strong>&lt;/em> &lt;em>one digit (&lt;code>6&lt;/code> becomes &lt;code>9&lt;/code>, and &lt;code>9&lt;/code> becomes &lt;code>6&lt;/code>).&lt;/em>&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> num = 9669&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 9969&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong>&lt;br>
Changing the first digit results in 6669.&lt;br>
Changing the second digit results in 9969.&lt;br>
Changing the third digit results in 9699.&lt;br>
Changing the fourth digit results in 9666.&lt;br>
The maximum number is 9969.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 79. Word Search</title><link>https://intervalrain.github.io/leetcode/79/</link><pubDate>Sat, 05 Nov 2022 21:12:17 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/79/</guid><description>&lt;p>&lt;strong>79. Word Search&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Backtracking&lt;/code>、&lt;code>Matrix&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an &lt;code>m x n&lt;/code> grid of characters &lt;code>board&lt;/code> and a string &lt;code>word&lt;/code>, return &lt;code>true&lt;/code> &lt;em>if&lt;/em> &lt;code>word&lt;/code> &lt;em>exists in the grid&lt;/em>.&lt;br>
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;ABCCED&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> true&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 212. Word Search II</title><link>https://intervalrain.github.io/leetcode/212/</link><pubDate>Sat, 05 Nov 2022 20:58:11 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/212/</guid><description>&lt;p>&lt;strong>212. Word Search II&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>String&lt;/code>、&lt;code>Backtracking&lt;/code>、&lt;code>Trie&lt;/code>、&lt;code>Matrix&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an &lt;code>m x n&lt;/code> &lt;code>board&lt;/code> of characters and a list of strings &lt;code>words&lt;/code>, return &lt;em>all words on the board&lt;/em>.&lt;br>
Each word must be constructed from letters of sequentially adjacent cells, where &lt;strong>adjacent cells&lt;/strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> board = [[&amp;ldquo;o&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;],[&amp;ldquo;e&amp;rdquo;,&amp;ldquo;t&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;e&amp;rdquo;],[&amp;ldquo;i&amp;rdquo;,&amp;ldquo;h&amp;rdquo;,&amp;ldquo;k&amp;rdquo;,&amp;ldquo;r&amp;rdquo;],[&amp;ldquo;i&amp;rdquo;,&amp;ldquo;f&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;v&amp;rdquo;]], words = [&amp;ldquo;oath&amp;rdquo;,&amp;ldquo;pea&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;rain&amp;rdquo;]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;oath&amp;rdquo;]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2131. Longest Palindrome by Concatenating Two Letter Words</title><link>https://intervalrain.github.io/leetcode/2131/</link><pubDate>Thu, 03 Nov 2022 23:10:10 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2131/</guid><description>&lt;p>&lt;strong>2131. Longest Palindrome by Concatenating Two Letter Words&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>String&lt;/code>、&lt;code>Greedy&lt;/code>、&lt;code>Counting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an array of strings &lt;code>words&lt;/code>. Each element of &lt;code>words&lt;/code> consists of &lt;strong>two&lt;/strong> lowercase English letters.&lt;br>
Create the &lt;strong>longest possible palindrome&lt;/strong> by selecting some elements from &lt;code>words&lt;/code> and concatenating them in &lt;strong>any order&lt;/strong>. Each element can be selected &lt;strong>at most once&lt;/strong>.&lt;br>
&lt;em>Return the&lt;/em> &lt;em>&lt;strong>length&lt;/strong>&lt;/em> &lt;em>of the longest palindrome that you can create&lt;/em>. If it is impossible to create any palindrome, return &lt;code>0&lt;/code>.&lt;/p></description></item><item><title>[LeetCode] 433. Minimum Genetic Mutation</title><link>https://intervalrain.github.io/leetcode/433/</link><pubDate>Wed, 02 Nov 2022 23:36:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/433/</guid><description>&lt;p>&lt;strong>433. Minimum Genetic Mutation&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Hash Table&lt;/code>、&lt;code>String&lt;/code>、&lt;code>Breadth-First Search&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>A gene string can be represented by an 8-character long string, with choices from &lt;code>A&lt;/code>, &lt;code>C&lt;/code>, &lt;code>G&lt;/code>, and &lt;code>T&lt;/code>.&lt;br>
Suppose we need to investigate a mutation from a gene string &lt;code>start&lt;/code> to a gene string &lt;code>end&lt;/code> where one mutation is defined as one single character changed in the gene string.&lt;/p>
&lt;ul>
&lt;li>For example, &lt;code>&amp;quot;AACCGGTT&amp;quot; --&amp;gt; &amp;quot;AACCGGTA&amp;quot;&lt;/code> is one mutation.&lt;br>
There is also a gene bank &lt;code>bank&lt;/code> that records all the valid gene mutations. A gene must be in &lt;code>bank&lt;/code> to make it a valid gene string.&lt;br>
Given the two gene strings &lt;code>start&lt;/code> and &lt;code>end&lt;/code> and the gene bank &lt;code>bank&lt;/code>, return the &lt;em>minimum number of mutations needed to mutate from&lt;/em> &lt;code>start&lt;/code> &lt;em>to&lt;/em> &lt;code>end&lt;/code>. If there is no such a mutation, return &lt;code>-1&lt;/code>.&lt;br>
Note that the starting point is assumed to be valid, so it might not be included in the bank.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 20. Valid Parentheses</title><link>https://intervalrain.github.io/leetcode/20/</link><pubDate>Tue, 01 Nov 2022 20:51:49 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/20/</guid><description>&lt;p>&lt;strong>20. Valid Parentheses&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Stack&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a string &lt;code>s&lt;/code> containing just the characters &lt;code>(&lt;/code>, &lt;code>)&lt;/code>, &lt;code>{&lt;/code>, &lt;code>}&lt;/code>, &lt;code>[&lt;/code> and &lt;code>]&lt;/code>, determine if the input string is valid.&lt;br>
An input string is valid if:&lt;/p>
&lt;ol>
&lt;li>Open brackets must be closed by the same type of brackets.&lt;/li>
&lt;li>Open brackets must be closed in the correct order.&lt;/li>
&lt;li>Every close bracket has a corresponding open bracket of the same type.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1706. Where Will the Ball Fall</title><link>https://intervalrain.github.io/leetcode/1706/</link><pubDate>Tue, 01 Nov 2022 19:02:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1706/</guid><description>&lt;p>&lt;strong>1706. Where Will the Ball Fall&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Depth-First Search&lt;/code>、&lt;code>Matrix&lt;/code>、&lt;code>Simulation&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You have a 2-D &lt;code>grid&lt;/code> of size &lt;code>m x n&lt;/code> representing a box, and you have &lt;code>n&lt;/code> balls. The box is open on the top and bottom sides.&lt;br>
Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.&lt;/p>
&lt;ul>
&lt;li>A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as &lt;code>1&lt;/code>.&lt;/li>
&lt;li>A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as &lt;code>-1&lt;/code>.&lt;br>
We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball get stuck if it hits a &amp;ldquo;V&amp;rdquo; shaped pattern between two boards or if a board redirects the ball into either wall of the box.&lt;br>
Return &lt;em>an array&lt;/em> &lt;code>answer&lt;/code> &lt;em>of size&lt;/em> &lt;code>n&lt;/code> &lt;em>where&lt;/em> &lt;code>answer[i]&lt;/code> &lt;em>is the column that the ball falls out of at the bottom after dropping the ball from the&lt;/em> &lt;code>ith&lt;/code> &lt;em>column at the top, or&lt;/em> &lt;code>-1&lt;/code> &lt;em>if the ball gets stuck in the box.&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="ball" loading="lazy" src="https://assets.leetcode.com/uploads/2019/09/26/ball.jpg">&lt;/p></description></item><item><title>[LeetCode] 1695. Maximum Erasure Value</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1695/</link><pubDate>Tue, 01 Nov 2022 19:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1695/</guid><description>&lt;ul>
&lt;li>套不定長的 Sliding Window pattern&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IWindow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span>() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>IWindow() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> IWindow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> _cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _cnt[num]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">-=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _cnt[num]&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> _cnt[num] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span>() &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> curr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>IWindow&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Solution()&lt;span style="color:#f92672">:&lt;/span> _w(make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span>()) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maximumUniqueSubarray&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> nums[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>check(num)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(nums[left&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>sum());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>不囉嗦版&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maximumUniqueSubarray(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> nums[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (map[num] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num2 &lt;span style="color:#f92672">=&lt;/span> nums[left&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map[num2]&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">-=&lt;/span> num2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map[num]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, curr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 904. Fruit Into Baskets</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/904/</link><pubDate>Tue, 01 Nov 2022 18:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/904/</guid><description>&lt;ul>
&lt;li>套不定長的 Sliding Window pattern&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IWindow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>IWindow() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> IWindow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> _types;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> _map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> _curr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Window(&lt;span style="color:#66d9ef">int&lt;/span> types)&lt;span style="color:#f92672">:&lt;/span> _types(types) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_map[num]&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _curr&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">--&lt;/span>_map[num] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _map.erase(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _curr&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>_map.count(num) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> _curr &lt;span style="color:#f92672">==&lt;/span> _types;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>IWindow&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Solution()&lt;span style="color:#f92672">:&lt;/span> _w(make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>)) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">totalFruit&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> fruits) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> fruits.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> fruits[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>check(num)) _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(fruits[left&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>不囉嗦版&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> totalFruit(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> fruits) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> fruits.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> fruits[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (curr &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>map.count(num)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num2 &lt;span style="color:#f92672">=&lt;/span> fruits[left&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">--&lt;/span>map[num2] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.erase(num2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map[num]&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 2730. Find the Longest Semi-Repetitive Substring</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2730/</link><pubDate>Tue, 01 Nov 2022 17:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2730/</guid><description>&lt;ul>
&lt;li>先將 s 轉成 prefix 再套不定長的 Sliding Window 套 pattern&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> longestSemiRepetitiveSubstring(string s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> trans &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#f92672">&amp;amp;&lt;/span>](string&lt;span style="color:#f92672">&amp;amp;&lt;/span> s) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res{&lt;span style="color:#ae81ff">0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.push_back(s[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> s[i] &lt;span style="color:#f92672">?&lt;/span> res.back() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> res.back());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> nums &lt;span style="color:#f92672">=&lt;/span> trans(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> nums[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (num &lt;span style="color:#f92672">-&lt;/span> nums[left] &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) left&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>不用先轉直接處理&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> longestSemiRepetitiveSubstring(string s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> check &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#f92672">&amp;amp;&lt;/span>](&lt;span style="color:#66d9ef">int&lt;/span> i) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> s[i] &lt;span style="color:#f92672">==&lt;/span> s[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (check(right&lt;span style="color:#f92672">++&lt;/span>)) curr&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (curr &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (check(&lt;span style="color:#f92672">++&lt;/span>left)) curr&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>左指針快進版&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> longestSemiRepetitiveSubstring(string s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> check &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#f92672">&amp;amp;&lt;/span>](&lt;span style="color:#66d9ef">int&lt;/span> i) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> s[i] &lt;span style="color:#f92672">==&lt;/span> s[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> last &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> check(right&lt;span style="color:#f92672">++&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (flag) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#f92672">=&lt;/span> last;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last &lt;span style="color:#f92672">=&lt;/span> right&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1208. Get Equal Substrings Within Budget</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1208/</link><pubDate>Tue, 01 Nov 2022 16:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1208/</guid><description>&lt;ul>
&lt;li>不定長的 Sliding Window 套 pattern&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IWindow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>() &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>IWindow() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> IWindow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> _maxCost;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> _curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Window(&lt;span style="color:#66d9ef">int&lt;/span> maxCost)&lt;span style="color:#f92672">:&lt;/span> _maxCost(maxCost) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _curr &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _curr &lt;span style="color:#f92672">-=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>() &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> _curr &lt;span style="color:#f92672">&amp;gt;&lt;/span> _maxCost;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>IWindow&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> equalSubstring(string s, string t, &lt;span style="color:#66d9ef">int&lt;/span> maxCost) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> nums &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#f92672">&amp;amp;&lt;/span>](&lt;span style="color:#66d9ef">int&lt;/span> i) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">abs&lt;/span>(s[i] &lt;span style="color:#f92672">-&lt;/span> t[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w &lt;span style="color:#f92672">=&lt;/span> make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span>(maxCost);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size(), left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(nums(right&lt;span style="color:#f92672">++&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>check()) _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(nums(left&lt;span style="color:#f92672">++&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right &lt;span style="color:#f92672">-&lt;/span> left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>簡易版&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> equalSubstring(string s, string t, &lt;span style="color:#66d9ef">int&lt;/span> maxCost) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size(), left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">+=&lt;/span> abs(s[right] &lt;span style="color:#f92672">-&lt;/span> t[right]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (curr &lt;span style="color:#f92672">&amp;gt;&lt;/span> maxCost) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">-=&lt;/span> abs(s[left] &lt;span style="color:#f92672">-&lt;/span> t[left]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right &lt;span style="color:#f92672">-&lt;/span> left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1493. Longest Subarray of 1's After Deleting One Element</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1493/</link><pubDate>Tue, 01 Nov 2022 15:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1493/</guid><description>&lt;ul>
&lt;li>不定長的 Sliding Window 套 pattern&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IWindow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>IWindow() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> IWindow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Window() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) cnt&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> num &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cnt &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>IWindow&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Solution()&lt;span style="color:#f92672">:&lt;/span> _w(make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span>()) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">longestSubarray&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size(), left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> nums[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>check(num)) _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(nums[left&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>但其實在 check &amp;amp; 移動左指標這一步可以做優化，左指標可以透過記錄一下一個合法的位置來快速移動。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> last &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> longestSubarray(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size(), left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> nums[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#f92672">=&lt;/span> last;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last &lt;span style="color:#f92672">=&lt;/span> right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 3. Longest Substring Without Repeating Characters</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/3/</link><pubDate>Tue, 01 Nov 2022 14:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/3/</guid><description>&lt;ul>
&lt;li>不定長的 Sliding Window 的 pattern 如下&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Window() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Bucket&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Window {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> _bucketSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> _valueDiff;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> num &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> (num &lt;span style="color:#f92672">-&lt;/span> _valueDiff) &lt;span style="color:#f92672">/&lt;/span> _bucketSize
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : num &lt;span style="color:#f92672">/&lt;/span> _bucketSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> _map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Bucket(&lt;span style="color:#66d9ef">int&lt;/span> valueDiff)&lt;span style="color:#f92672">:&lt;/span> _valueDiff(valueDiff), _bucketSize(valueDiff &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> index(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _map[idx] &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> index(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _map.erase(idx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> index(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> _map.count(idx) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (_map.count(idx&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> num &lt;span style="color:#f92672">-&lt;/span> _map[idx&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;lt;=&lt;/span> _valueDiff) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (_map.count(idx&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> _map[idx&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> num &lt;span style="color:#f92672">&amp;lt;=&lt;/span> _valueDiff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> containsNearbyAlmostDuplicate(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> indexDiff, &lt;span style="color:#66d9ef">int&lt;/span> valueDiff) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> indexDiff &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w &lt;span style="color:#f92672">=&lt;/span> make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Bucket&lt;span style="color:#f92672">&amp;gt;&lt;/span>(valueDiff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>find(nums[i])) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(nums[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(nums[i&lt;span style="color:#f92672">-&lt;/span>k]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>find(nums[i])) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(nums[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>沒有抽象化的 code&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> containsNearbyAlmostDuplicate(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idxin &lt;span style="color:#f92672">=&lt;/span> nums[i] &lt;span style="color:#f92672">/&lt;/span> (t&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums[i] &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) idxin&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idxout &lt;span style="color:#f92672">=&lt;/span> nums[i&lt;span style="color:#f92672">-&lt;/span>k] &lt;span style="color:#f92672">/&lt;/span> (t&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums[i&lt;span style="color:#f92672">-&lt;/span>k] &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) idxout&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.erase(idxout);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map.count(idxin) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (map.count(idxin&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> nums[i] &lt;span style="color:#f92672">-&lt;/span> map[idxin&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;lt;=&lt;/span> t) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (map.count(idxin&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> map[idxin&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> nums[i] &lt;span style="color:#f92672">&amp;lt;=&lt;/span> t)) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map[idxin] &lt;span style="color:#f92672">=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 3090. Maximum Length Substring With Two Occurrences</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/3090/</link><pubDate>Tue, 01 Nov 2022 14:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/3090/</guid><description>&lt;ul>
&lt;li>不定長的 Sliding Window 套 pattern&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IWindow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> c) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> c) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> c) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>IWindow() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> IWindow{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt[&lt;span style="color:#ae81ff">26&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Window() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(cnt, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(cnt));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> c) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt[c&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> c) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt[c&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>]&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> c) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> cnt[c&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>IWindow&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Solution()&lt;span style="color:#f92672">:&lt;/span> _w(make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span>()) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maximumLengthSubstring&lt;/span>(string s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size(), left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> s[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>check(c)) _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(s[left&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(c);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 不定長 Sliding Window Pattern</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/pattern_2/</link><pubDate>Tue, 01 Nov 2022 14:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/pattern_2/</guid><description>&lt;ul>
&lt;li>不定長度的 sliding window pattern&lt;/li>
&lt;li>步驟 &lt;br>
move sliding window&lt;br>
(1) 滑動左指標直到 window 有效
(2) 加入右指標
(3) 更新&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Window() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Solution()&lt;span style="color:#f92672">:&lt;/span> _w() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">solve&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w &lt;span style="color:#f92672">=&lt;/span> make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>WindowImpl&lt;span style="color:#f92672">&amp;gt;&lt;/span>(k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size(), left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> nums[right&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>check(num)) _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(nums[left&lt;span style="color:#f92672">++&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, right&lt;span style="color:#f92672">-&lt;/span>left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> len;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 220. Contains Duplicate III</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/220/</link><pubDate>Tue, 01 Nov 2022 13:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/220/</guid><description>&lt;ul>
&lt;li>這是一題是很有趣的一題，會用到 bucket sort 結合 sliding window，時間複雜度是 \(O(n)\)&lt;/li>
&lt;li>我把 sliding window 的部分拆分開來，讓邏輯更清楚。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Window() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Bucket&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Window {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> _bucketSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> _valueDiff;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">index&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> num &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> (num &lt;span style="color:#f92672">-&lt;/span> _valueDiff) &lt;span style="color:#f92672">/&lt;/span> _bucketSize
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : num &lt;span style="color:#f92672">/&lt;/span> _bucketSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> _map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Bucket(&lt;span style="color:#66d9ef">int&lt;/span> valueDiff)&lt;span style="color:#f92672">:&lt;/span> _valueDiff(valueDiff), _bucketSize(valueDiff &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> index(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _map[idx] &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> index(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _map.erase(idx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> index(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> _map.count(idx) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (_map.count(idx&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> num &lt;span style="color:#f92672">-&lt;/span> _map[idx&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;lt;=&lt;/span> _valueDiff) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (_map.count(idx&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> _map[idx&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> num &lt;span style="color:#f92672">&amp;lt;=&lt;/span> _valueDiff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> containsNearbyAlmostDuplicate(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> indexDiff, &lt;span style="color:#66d9ef">int&lt;/span> valueDiff) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> indexDiff &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w &lt;span style="color:#f92672">=&lt;/span> make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Bucket&lt;span style="color:#f92672">&amp;gt;&lt;/span>(valueDiff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>find(nums[i])) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(nums[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(nums[i&lt;span style="color:#f92672">-&lt;/span>k]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>find(nums[i])) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(nums[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>沒有抽象化的 code&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> containsNearbyAlmostDuplicate(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idxin &lt;span style="color:#f92672">=&lt;/span> nums[i] &lt;span style="color:#f92672">/&lt;/span> (t&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums[i] &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) idxin&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idxout &lt;span style="color:#f92672">=&lt;/span> nums[i&lt;span style="color:#f92672">-&lt;/span>k] &lt;span style="color:#f92672">/&lt;/span> (t&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums[i&lt;span style="color:#f92672">-&lt;/span>k] &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) idxout&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.erase(idxout);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map.count(idxin) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (map.count(idxin&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> nums[i] &lt;span style="color:#f92672">-&lt;/span> map[idxin&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;lt;=&lt;/span> t) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (map.count(idxin&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> map[idxin&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> nums[i] &lt;span style="color:#f92672">&amp;lt;=&lt;/span> t)) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map[idxin] &lt;span style="color:#f92672">=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1984. Minimum Difference Between Highest and Lowest of K Scores</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1984/</link><pubDate>Tue, 01 Nov 2022 12:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1984/</guid><description>&lt;ul>
&lt;li>這是一題簡單的定長度 sliding window。先排序再用滑動窗口求值。時間複雜度是 \(O(n\log(n))\)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> minimumDifference(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sort(nums.begin(), nums.end());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> INT_MAX;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.size() &lt;span style="color:#f92672">-&lt;/span> k &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> min(res, nums[i&lt;span style="color:#f92672">+&lt;/span>k&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> nums[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 2269. Find the K-Beauty of a Number</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2269/</link><pubDate>Tue, 01 Nov 2022 12:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2269/</guid><description>&lt;ul>
&lt;li>這是一題簡單的定長度 sliding window。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> divisorSubstrings(&lt;span style="color:#66d9ef">int&lt;/span> num, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string s &lt;span style="color:#f92672">=&lt;/span> to_string(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.size()&lt;span style="color:#f92672">-&lt;/span>k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> div &lt;span style="color:#f92672">=&lt;/span> stoi(s.substr(i, k));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (div &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> num &lt;span style="color:#f92672">%&lt;/span> div &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) res&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>用原本的 pattern 來做，但要注意 1e9 * 10 會爆掉，整數的範圍大概只有 2e9 (2147483647)。可改用先減再 shift 的方式處理。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> divisorSubstrings(&lt;span style="color:#66d9ef">int&lt;/span> num, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string s &lt;span style="color:#f92672">=&lt;/span> to_string(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> pk &lt;span style="color:#f92672">=&lt;/span> pow(&lt;span style="color:#ae81ff">10&lt;/span>, k&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> curr &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (s[i] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (curr &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> num &lt;span style="color:#f92672">%&lt;/span> curr &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) res&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (curr &lt;span style="color:#f92672">-&lt;/span> (s[i&lt;span style="color:#f92672">-&lt;/span>k] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> pk) &lt;span style="color:#f92672">+&lt;/span> (s[i] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (curr &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> num &lt;span style="color:#f92672">%&lt;/span> curr &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) res&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 766. Toeplitz Matrix</title><link>https://intervalrain.github.io/leetcode/766/</link><pubDate>Tue, 01 Nov 2022 00:40:55 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/766/</guid><description>&lt;p>&lt;strong>766. Toeplitz Matrix&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Matrix&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an &lt;code>m x n&lt;/code> &lt;code>matrix&lt;/code>, return &lt;em>&lt;code>true&lt;/code> if the matrix is Toeplitz. Otherwise, return &lt;code>false&lt;/code>&lt;/em>. A matrix is &lt;strong>Toeplitz&lt;/strong> if every diagonal from top-left to bottom-right has the same elements.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="ex1" loading="lazy" src="https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> true&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong>&lt;br>
In the above grid, the diagonals are:&lt;br>
&amp;ldquo;[9]&amp;rdquo;, &amp;ldquo;[5, 5]&amp;rdquo;, &amp;ldquo;[1, 1, 1]&amp;rdquo;, &amp;ldquo;[2, 2, 2]&amp;rdquo;, &amp;ldquo;[3, 3]&amp;rdquo;, &amp;ldquo;[4]&amp;rdquo;.&lt;br>
In each diagonal all elements are the same, so the answer is True.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>
&lt;img alt="ex2" loading="lazy" src="https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg">&lt;/p></description></item><item><title>[LeetCode] 1016. Binary String With Substrings Representing 1 To N</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1016/</link><pubDate>Mon, 31 Oct 2022 12:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1016/</guid><description>&lt;ul>
&lt;li>這一題是滿有趣的一題，我的靈感來自於 zkw 的線段樹(但沒有用到線段樹)。&lt;/li>
&lt;li>觀察 &lt;code>1 ~ n&lt;/code> 的樹，並將它排成 zkw 的線段樹，可以發現以下規則：
&lt;ul>
&lt;li>滿足樹的子葉，則必定可以滿足其父節點，例如：找到 &lt;code>&amp;quot;1010&amp;quot;&lt;/code>，則可以滿足 &lt;code>&amp;quot;101&amp;quot;&lt;/code>、&lt;code>&amp;quot;10&amp;quot;&lt;/code>、&lt;code>&amp;quot;1&amp;quot;&lt;/code>。&lt;/li>
&lt;li>所以可以得到一個數學結論是：我們只需要找到 &lt;code>n ~ n/2+1&lt;/code> 的數即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">1&lt;/span>] len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">10&lt;/span>] &lt;span style="color:#ae81ff">11&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">100&lt;/span> [&lt;span style="color:#ae81ff">101&lt;/span>] &lt;span style="color:#ae81ff">110&lt;/span> &lt;span style="color:#ae81ff">111&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1000&lt;/span> &lt;span style="color:#ae81ff">1001&lt;/span> [&lt;span style="color:#ae81ff">1010&lt;/span>] &lt;span style="color:#ae81ff">1011&lt;/span> &lt;span style="color:#ae81ff">1100&lt;/span> &lt;span style="color:#ae81ff">1101&lt;/span> &lt;span style="color:#ae81ff">1110&lt;/span> &lt;span style="color:#ae81ff">1111&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">8&lt;/span>) num mask
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">^&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>solution:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> queryString(string s, &lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1979&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> false; &lt;span style="color:#75715e">// 剪枝：當 n 太大時必為 false, 證明在下面
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span> &lt;span style="color:#f92672">-&lt;/span> __builtin_clz(n); &lt;span style="color:#75715e">// n 的位元長度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (s.size() &lt;span style="color:#f92672">&amp;lt;&lt;/span> len) &lt;span style="color:#66d9ef">return&lt;/span> false; &lt;span style="color:#75715e">// s 長度連 window 都不夠時 return false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> mask &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> len) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 遮罩 用來控制 window 長度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> unordered_set&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> seen; &lt;span style="color:#75715e">// 用來記錄數字是否出現過
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> valid &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// 總共需要收集到的數目
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// init
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> ((curr &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">|&lt;/span> (s[i] &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (curr &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> curr &lt;span style="color:#f92672">&amp;gt;&lt;/span> n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>) seen.insert(curr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (seen.size() &lt;span style="color:#f92672">==&lt;/span> valid) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// rolling
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> len; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> ((curr &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">|&lt;/span> (s[i] &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">&amp;amp;&lt;/span> mask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (curr &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> curr &lt;span style="color:#f92672">&amp;gt;&lt;/span> n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>) seen.insert(curr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (seen.size() &lt;span style="color:#f92672">==&lt;/span> valid) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>剪枝的證明：
我來說明 1979 這個臨界值的計算過程：&lt;/li>
&lt;/ul>
&lt;p>當字串長度 = 1000 時，我們需要找到滿足以下條件的最大 n：&lt;/p></description></item><item><title>[LeetCode] 19. Remove Nth Node From End of List</title><link>https://intervalrain.github.io/leetcode/19/</link><pubDate>Mon, 31 Oct 2022 00:05:10 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/19/</guid><description>&lt;p>&lt;strong>19. Remove Nth Node From End of List&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Linked List&lt;/code>、&lt;code>Two Pointers&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given the &lt;code>head&lt;/code> of a linked list, remove the &lt;code>nth&lt;/code> node from the end of the list and return its head.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="remove_ex1" loading="lazy" src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> head = [1,2,3,4,5], n = 2&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [1,2,3,5]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> head = [1], n = 1&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> []&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> head = [1,2], n = 1&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [1]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination</title><link>https://intervalrain.github.io/leetcode/1293/</link><pubDate>Sun, 30 Oct 2022 21:29:37 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1293/</guid><description>&lt;p>&lt;strong>1293. Shortest Path in a Grid with Obstacles Elimination&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Breadth-First Search&lt;/code>、&lt;code>Matrix&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an &lt;code>m x n&lt;/code> integer matrix &lt;code>grid&lt;/code> where each cell is either &lt;code>0&lt;/code> (empty) or &lt;code>1&lt;/code> (obstacles). You can move up, down, left, or right from and to an empty cell in &lt;strong>one step&lt;/strong>.&lt;br>
Return &lt;em>the minimum number of&lt;/em> &lt;em>&lt;strong>steps&lt;/strong>&lt;/em> &lt;em>to walk from the upper left corner&lt;/em> &lt;code>(0, 0)&lt;/code> &lt;em>to the lower right conrer&lt;/em> &lt;code>m-1, n-1&lt;/code> &lt;em>given that you can eliminate&lt;/em> &lt;em>&lt;strong>at most&lt;/strong>&lt;/em> &lt;code>k&lt;/code> &lt;em>obstacles&lt;/em>. If it is not possible to find such walk return &lt;code>-1&lt;/code>.&lt;/p></description></item><item><title>[LeetCode] 2953. Count Complete Substrings</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2953/</link><pubDate>Sun, 30 Oct 2022 12:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2953/</guid><description>&lt;ul>
&lt;li>難度分: 2449&lt;/li>
&lt;li>這題是一個定長的 sliding window，比較難想的是 window size 是 k * 1, k * 2, &amp;hellip; 到 k * 26，因為只有 26 個英文字母，所以最多只可能到 26 * k 的長度。&lt;/li>
&lt;li>額外需要檢查相鄰的字母是否距離 &amp;lt;= 2，我使用的方法是找到一個 &lt;code>j&lt;/code> 記錄最大的不符合的索引值，所以直要 window 不包含該 &lt;code>j&lt;/code>，window 內的所字元都會滿足。&lt;/li>
&lt;li>所以 pesudo code 會是
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">26&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// window size
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> windowSize &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">*&lt;/span> k;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// construct window
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> windowSize; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 處理 j
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 計算進入 window
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 確認初始的 window 是否滿足
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// rolling windo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> windowSize; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 處理 j
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 計算進入 window
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 計算離開 window
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 確認 window 是否滿足
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> countCompleteSubstrings(string s, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; idx &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">26&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> idx &lt;span style="color:#f92672">*&lt;/span> k &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; idx&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> idx &lt;span style="color:#f92672">*&lt;/span> k;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> cnt(&lt;span style="color:#ae81ff">26&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> valid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> abs(s[i] &lt;span style="color:#f92672">-&lt;/span> s[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">++&lt;/span>cnt[s[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> k) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> idx &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> len; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (abs(s[i] &lt;span style="color:#f92672">-&lt;/span> s[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">++&lt;/span>cnt[s[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> k) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt[s[i&lt;span style="color:#f92672">-&lt;/span>len]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>]&lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#f92672">==&lt;/span> k) valid&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> idx &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i&lt;span style="color:#f92672">-&lt;/span>len &lt;span style="color:#f92672">&amp;gt;=&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 2136. Earliest Possible Day of Full Bloom</title><link>https://intervalrain.github.io/leetcode/2136/</link><pubDate>Sun, 30 Oct 2022 00:25:25 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2136/</guid><description>&lt;p>&lt;strong>2136. Earliest Possible Day of Full Bloom&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Greedy&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You have &lt;code>n&lt;/code> flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed take time and so does the growth of a seed. You are given two &lt;strong>0-indexed&lt;/strong> integer arrays &lt;code>plantTime&lt;/code> and &lt;code>growTime&lt;/code>, of length &lt;code>n&lt;/code> each:&lt;/p>
&lt;ul>
&lt;li>&lt;code>plantTime[i]&lt;/code> is the number of &lt;strong>full days&lt;/strong> it takes you to &lt;strong>plant&lt;/strong> the &lt;code>ith&lt;/code> seed. Every day, you can work on planting exactly one seed. You &lt;strong>do not&lt;/strong> have to work on planting the same seed on consecutive days, but the planting of a seed is not complete &lt;strong>until&lt;/strong> you have worked &lt;code>plantTime[i]&lt;/code> days on planting it in total.&lt;/li>
&lt;li>&lt;code>growTime[i]&lt;/code> is the number of &lt;strong>full days&lt;/strong> it takes the &lt;code>ith&lt;/code> seed to grow after being completely planted. &lt;strong>After&lt;/strong> the last day of its growth, the flower &lt;strong>blooms&lt;/strong> and stays bloomed forever.
From the beginning of day &lt;code>0&lt;/code>, you can plant the seeds in &lt;strong>any&lt;/strong> order.&lt;br>
Return &lt;em>the&lt;/em> &lt;em>&lt;strong>earliest&lt;/strong>&lt;/em> &lt;em>possible day where&lt;/em> &lt;em>&lt;strong>all&lt;/strong>&lt;/em> &lt;em>seeds are blooming&lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="growplant1" loading="lazy" src="https://assets.leetcode.com/uploads/2021/12/21/1.png">&lt;/p></description></item><item><title>[LeetCode] 2156. Find Substring With Given Hash Value</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2156/</link><pubDate>Sat, 29 Oct 2022 12:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2156/</guid><description>&lt;ul>
&lt;li>
&lt;p>難度分: 2063&lt;/p>
&lt;/li>
&lt;li>
&lt;p>這題是 rolling hash，同樣樣到 sliding window 的概念，由左至右需要處理除法問題，會使問題的難度增加，所以這題逆其道而行，從右至左，那就可以把除法問題變成乘法問題了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在處理商數時，要小心處理負數，由於商數 d 必定介於 0~k之間，可以利用
$$
\boxed{\mod(\mod(a)-\mod(b)+k)}
$$&lt;/p>
&lt;ul>
&lt;li>證明：
$$
\boxed{
\begin{array}{ll}
0\le\mod(a)&amp;lt;k \\
0\le\mod(b)&amp;lt;k \\
-k&amp;lt;\mod(a)-\mod(b)&amp;lt;k &amp;amp; 在取 \mod 前先整理成正數\\
0&amp;lt;\mod(a)-\mod(b)+k&amp;lt; 2k \\
0&amp;lt;\mod(\mod(a)-\mod(b)+k) &amp;lt; k
\end{array}
}
$$&lt;/li>
&lt;/ul>
&lt;p>令 &lt;code>str = dcba&lt;/code>，&lt;code>k = 3&lt;/code>，已知 &lt;code>curr = mod(ap^2+bp+c, m)&lt;/code> 求 &lt;code>mod(bp^2+cp+d, m)&lt;/code>&lt;/p>
&lt;ul>
&lt;li>\(\mod(bp^2+cp+d)\)&lt;/li>
&lt;li>\(\quad = \mod((ap^2+bp+c)\times p +d-ax^3)\)&lt;/li>
&lt;li>\(\quad = \mod(\mod(ap^2+bp+c)\times p +d+m-\mod(ax^3))\)&lt;/li>
&lt;li>\(\quad = \mod(\text{curr}\times p +d+m-\mod(ax^3))\)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string subStrHash(string s, &lt;span style="color:#66d9ef">int&lt;/span> p, &lt;span style="color:#66d9ef">int&lt;/span> mod, &lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> val) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> pk &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> (curr &lt;span style="color:#f92672">*&lt;/span> p &lt;span style="color:#f92672">+&lt;/span> (s[n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pk &lt;span style="color:#f92672">=&lt;/span> (pk &lt;span style="color:#f92672">*&lt;/span> p) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">-&lt;/span>k;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> (curr &lt;span style="color:#f92672">*&lt;/span> p &lt;span style="color:#f92672">+&lt;/span> (s[n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> mod &lt;span style="color:#f92672">-&lt;/span> ((s[n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>k]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> pk) &lt;span style="color:#f92672">%&lt;/span> mod) &lt;span style="color:#f92672">%&lt;/span> mod;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (curr &lt;span style="color:#f92672">==&lt;/span> val) j &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> s.substr(j, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 18. 4Sum</title><link>https://intervalrain.github.io/leetcode/18/</link><pubDate>Fri, 28 Oct 2022 23:58:48 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/18/</guid><description>&lt;p>&lt;strong>18. 4Sum&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Two Pointer&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an array &lt;code>nums&lt;/code> of &lt;code>n&lt;/code> integers, return &lt;em>an array of all the&lt;/em> &lt;em>&lt;strong>unique&lt;/strong>&lt;/em> quadruplets &lt;code>[nums[a], nums[b], nums[c], nums[d]]&lt;/code> such that:&lt;/p>
&lt;ul>
&lt;li>&lt;code>0 &amp;lt;= a, b, c, d &amp;lt; n&lt;/code>&lt;/li>
&lt;li>&lt;code>a&lt;/code>, &lt;code>b&lt;/code>, &lt;code>c&lt;/code> and &lt;code>d&lt;/code> are &lt;strong>distinct&lt;/strong>.&lt;/li>
&lt;li>&lt;code>nums[a] + nums[b] + nums[c] + nums[d] == target&lt;/code>
You may return the answer in &lt;strong>any order&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [1,0,-1,0,-2,2], target = 0&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 17. Letter Combinations of a Phone Number</title><link>https://intervalrain.github.io/leetcode/17/</link><pubDate>Fri, 28 Oct 2022 22:59:22 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/17/</guid><description>&lt;p>&lt;strong>17. Letter Combinations of a Phone Number&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Hash Table&lt;/code>,&lt;code>String&lt;/code>,&lt;code>Backtracking&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a string containing digits from &lt;code>2-9&lt;/code> inclusive, return all possible letter combinations that the number could represent. Return the answer in &lt;strong>any order&lt;/strong>&lt;br>
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.&lt;br>
&lt;img alt="1200px-telephone-keypad2svg" loading="lazy" src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png">&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> digits = &amp;ldquo;23&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [&amp;ldquo;ad&amp;rdquo;,&amp;ldquo;ae&amp;rdquo;,&amp;ldquo;af&amp;rdquo;,&amp;ldquo;bd&amp;rdquo;,&amp;ldquo;be&amp;rdquo;,&amp;ldquo;bf&amp;rdquo;,&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;ce&amp;rdquo;,&amp;ldquo;cf&amp;rdquo;]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 16. 3Sum Closet</title><link>https://intervalrain.github.io/leetcode/16/</link><pubDate>Fri, 28 Oct 2022 21:51:20 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/16/</guid><description>&lt;p>&lt;strong>no. &lt;Title>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Two Pointers&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array &lt;code>nums&lt;/code> of length &lt;code>n&lt;/code> and an integer &lt;code>target&lt;/code>, find three integers in &lt;code>nums&lt;/code> such that the sum is closet to &lt;code>target&lt;/code>.&lt;br>
Return *the sum of the three integers`.&lt;br>
You may assume that each input would have exactly one solution.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [-1,2,1,-4], target = 1&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 2&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The sum that is closet to the target is 2. (-1 + 2 + 1 = 2).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 15. 3Sum</title><link>https://intervalrain.github.io/leetcode/15/</link><pubDate>Fri, 28 Oct 2022 13:30:19 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/15/</guid><description>&lt;p>&lt;strong>15. 3Sum&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Two Pointer&lt;/code>、&lt;code>Sorting&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array nums, return all the triplets &lt;code>[nums[i], nums[j], nums[k]]&lt;/code> such that &lt;code>i != j&lt;/code>, &lt;code>i != k&lt;/code>, &lt;code>j != k&lt;/code>, and &lt;code>nums[i] + nums[j] + nums[k] == 0&lt;/code>.&lt;br>
Notice that the solution set must not contain duplicate triplets.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [-1,0,1,2,-1,-4]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [[-1,-1,2],[-1,0,1]]&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong>&lt;br>
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.&lt;br>
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.&lt;br>
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.&lt;br>
The distinct triplets are [-1,0,1] and [-1,-1,2].&lt;br>
Notice that the order of the output and the order of the triplets does not matter.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 30. Substring with Concatenation of All Words</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/30/</link><pubDate>Fri, 28 Oct 2022 12:30:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/30/</guid><description>&lt;ul>
&lt;li>這一題與 567 類似，差別是將字元比較改成字串比較。&lt;/li>
&lt;li>注意因為字串比較不一定是從 0 開始，所以還要多一個 &lt;code>for start in range(0, wordLen)&lt;/code> 的迴圈來調整起始位置&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> findSubstring(string s, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> words) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> cnt1, cnt2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> word : words) cnt1[word]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> wordLen &lt;span style="color:#f92672">=&lt;/span> words[&lt;span style="color:#ae81ff">0&lt;/span>].size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> words.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (s.size() &lt;span style="color:#f92672">&amp;lt;&lt;/span> wordLen &lt;span style="color:#f92672">*&lt;/span> k) &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; start &lt;span style="color:#f92672">&amp;lt;&lt;/span> wordLen; start&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt2.clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> valid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> start; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k &lt;span style="color:#f92672">*&lt;/span> wordLen; i &lt;span style="color:#f92672">+=&lt;/span> wordLen) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string sin &lt;span style="color:#f92672">=&lt;/span> s.substr(i, wordLen);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt1.count(sin) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">++&lt;/span>cnt2[sin] &lt;span style="color:#f92672">==&lt;/span> cnt1[sin]) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> cnt1.size()) res.push_back(start);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> start &lt;span style="color:#f92672">+&lt;/span> k &lt;span style="color:#f92672">*&lt;/span> wordLen; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.size(); i &lt;span style="color:#f92672">+=&lt;/span> wordLen) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string sin &lt;span style="color:#f92672">=&lt;/span> s.substr(i, wordLen);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt1.count(sin) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">++&lt;/span>cnt2[sin] &lt;span style="color:#f92672">==&lt;/span> cnt1[sin]) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string sout &lt;span style="color:#f92672">=&lt;/span> s.substr(i&lt;span style="color:#f92672">-&lt;/span>k&lt;span style="color:#f92672">*&lt;/span>wordLen, wordLen);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt1.count(sout) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cnt2[sout]&lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#f92672">==&lt;/span> cnt1[sout]) valid&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> cnt1.size()) res.push_back(i&lt;span style="color:#f92672">-&lt;/span>(k&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">*&lt;/span>wordLen);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 438. Find All Anagrams in a String</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/438/</link><pubDate>Fri, 28 Oct 2022 12:20:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/438/</guid><description>&lt;ul>
&lt;li>這一題與 567 類似，是找 anagram 題題目，令 p 長度為 window size，即可解。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> findAnagrams(string s, string p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> p.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;&lt;/span> k) &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> cnt1, cnt2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> c : p) cnt1[c]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> valid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt1.count(s[i]) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">++&lt;/span>cnt2[s[i]] &lt;span style="color:#f92672">==&lt;/span> cnt1[s[i]]) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> cnt1.size()) res.push_back(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt1.count(s[i]) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">++&lt;/span>cnt2[s[i]] &lt;span style="color:#f92672">==&lt;/span> cnt1[s[i]]) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt1.count(s[i&lt;span style="color:#f92672">-&lt;/span>k]) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cnt2[s[i&lt;span style="color:#f92672">-&lt;/span>k]]&lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#f92672">==&lt;/span> cnt1[s[i&lt;span style="color:#f92672">-&lt;/span>k]]) valid&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> cnt1.size()) res.push_back(i&lt;span style="color:#f92672">-&lt;/span>k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 567. Permutation in String</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/567/</link><pubDate>Fri, 28 Oct 2022 12:10:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/567/</guid><description>&lt;ul>
&lt;li>這一題同樣是定長度的 sliding window，window size 為 s1.size()&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> checkInclusion(string s1, string s2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> map, map2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> s1.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s2.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (k &lt;span style="color:#f92672">&amp;gt;&lt;/span> n) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> valid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> c : s1) map[c]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>map.count(s2[i])) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">++&lt;/span>map2[s2[i]] &lt;span style="color:#f92672">==&lt;/span> map[s2[i]]) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> map.size()) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map.count(s2[i]) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">++&lt;/span>map2[s2[i]] &lt;span style="color:#f92672">==&lt;/span> map[s2[i]]) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map.count(s2[i&lt;span style="color:#f92672">-&lt;/span>k]) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> map2[s2[i&lt;span style="color:#f92672">-&lt;/span>k]]&lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#f92672">==&lt;/span> map[s2[i&lt;span style="color:#f92672">-&lt;/span>k]]) valid&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> map.size()) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1888. Minimum Number of Flips to Make the Binary String Alternating</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1888/</link><pubDate>Fri, 28 Oct 2022 12:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1888/</guid><description>&lt;ul>
&lt;li>難度分: 2006&lt;/li>
&lt;li>這一題如果沒有條件一，則很簡單，根據奇偶數索引位置，判斷是否要 flip 就可以了。
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">minFlips&lt;/span>(string s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ans1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, ans2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">++&lt;/span>ans1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">++&lt;/span>ans2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> min(ans1, ans2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>但這一題加上條件一，可以用很精巧的手法，把它轉成 sliding window 的問題，將字串重覆兩次，以原字串長度作為 window size，可解這題。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> minFlips(string s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s &lt;span style="color:#f92672">+=&lt;/span> s;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ans1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, ans2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">++&lt;/span>ans1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">++&lt;/span>ans2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> min(ans1, ans2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">++&lt;/span>ans1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">++&lt;/span>ans2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (((i &lt;span style="color:#f92672">-&lt;/span> k) &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i &lt;span style="color:#f92672">-&lt;/span> k] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> ((i &lt;span style="color:#f92672">-&lt;/span> k) &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i &lt;span style="color:#f92672">-&lt;/span> k] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">--&lt;/span>ans1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (((i &lt;span style="color:#f92672">-&lt;/span> k) &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i &lt;span style="color:#f92672">-&lt;/span> k] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> ((i &lt;span style="color:#f92672">-&lt;/span> k) &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> s[i &lt;span style="color:#f92672">-&lt;/span> k] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">--&lt;/span>ans2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans &lt;span style="color:#f92672">=&lt;/span> min({ans1, ans2, ans});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[Leetcode] 14. Longest Common Prefix</title><link>https://intervalrain.github.io/leetcode/14/</link><pubDate>Fri, 28 Oct 2022 00:00:08 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/14/</guid><description>&lt;p>&lt;strong>14. Longest Common Prefix&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Write a function to find the longest common prefix string amongst an array of strings.&lt;br>
If there is no common prefix, return an empty string &lt;code>&amp;quot;&amp;quot;&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> strs = [&amp;ldquo;flower&amp;rdquo;, &amp;ldquo;flow&amp;rdquo;, &amp;ldquo;flight&amp;rdquo;]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> &amp;ldquo;fl&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> strs = [&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;racecar&amp;rdquo;, &amp;ldquo;car&amp;rdquo;]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> &amp;quot;&amp;quot;&lt;/li>
&lt;li>&lt;strong>Explanation&lt;/strong>: There is no common prefix among the input strings.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= strs.length &amp;lt;= 200&lt;/code>&lt;/li>
&lt;li>&lt;code>0 &amp;lt;= strs[i].length &amp;lt;= 200&lt;/code>&lt;/li>
&lt;li>&lt;code>strs[i]&lt;/code> consists of only lowercase English letters.&lt;/li>
&lt;/ul>
&lt;h3 id="二分析">二、分析&lt;/h3>
&lt;ul>
&lt;li>簡單的字串比對問題。&lt;/li>
&lt;li>需熟悉 &lt;code>string&lt;/code> 的函數 &lt;code>substr()&lt;/code> 的使用方式，常用以下兩種
&lt;ul>
&lt;li>&lt;code>s.substr(int start, int len)&lt;/code>，從 &lt;code>start&lt;/code> 起取長度為 &lt;code>len&lt;/code> 的子字串。&lt;/li>
&lt;li>&lt;code>s.substr(int start)&lt;/code> 從 &lt;code>start&lt;/code> 起取到字串的結尾。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="三解題">三、解題&lt;/h3>
&lt;h4 id="1-string">1. String&lt;/h4>
&lt;ul>
&lt;li>Time complexity: \(O(m\times n)，\text{m }為\text{ strs }的長度，\text{n }為\text{ strs[i] }的長度\)，&lt;/li>
&lt;li>Space complexity: \(O(1)\)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>string &lt;span style="color:#a6e22e">longestCommonPrefix&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> strs) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string res &lt;span style="color:#f92672">=&lt;/span> strs[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> strs.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> min(strs[i].length(), res.length()); j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (strs[i][j] &lt;span style="color:#f92672">!=&lt;/span> res[j]) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> res.substr(&lt;span style="color:#ae81ff">0&lt;/span>, j);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://intervalrain.github.io/leetcode">回目錄 Catalog&lt;/a>&lt;/p></description></item><item><title>[Leetcode] 13. Roman to Integer</title><link>https://intervalrain.github.io/leetcode/13/</link><pubDate>Thu, 27 Oct 2022 21:58:08 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/13/</guid><description>&lt;p>&lt;strong>13. Roman to Integer&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Hash Table&lt;/code>、&lt;code>Math&lt;/code>、&lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Roman numerals are represented by seven different symbols: &lt;code>I&lt;/code>, &lt;code>V&lt;/code>, &lt;code>X&lt;/code>, &lt;code>L&lt;/code>, &lt;code>C&lt;/code>, &lt;code>D&lt;/code>, and &lt;code>M&lt;/code>.&lt;br>
\(\boxed{\begin{array}{ll}
\textbf{Symbol}&amp;amp;\textbf{Value}\\
\texttt{I}&amp;amp;1\\
\texttt{V}&amp;amp;5\\
\texttt{X}&amp;amp;10\\
\texttt{L}&amp;amp;50\\
\texttt{C}&amp;amp;100\\
\texttt{D}&amp;amp;500\\
\texttt{M}&amp;amp;1000\\
\end{array}}\)&lt;br>
For example, &lt;code>2&lt;/code> is written as &lt;code>II&lt;/code> in Roman numeral, just two one&amp;rsquo;s added together. &lt;code>12&lt;/code> is written as &lt;code>XII&lt;/code>, which is simply &lt;code>X + II&lt;/code>. The number &lt;code>27&lt;/code> is written as &lt;code>XXVII&lt;/code>, which is &lt;code>XX + V + II&lt;/code>.&lt;br>
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not &lt;code>IIII&lt;/code>. Instead the number four is written as &lt;code>IV&lt;/code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as &lt;code>IX&lt;/code>. There are six instances where subtraction is used:&lt;/p></description></item><item><title>[Leetcode] 835. Image Overlap</title><link>https://intervalrain.github.io/leetcode/835/</link><pubDate>Thu, 27 Oct 2022 17:35:25 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/835/</guid><description>&lt;p>&lt;strong>835. Image Overlap&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Matrix&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given two images, &lt;code>img1&lt;/code> and &lt;code>img2&lt;/code>, represented as binary, square matrices of size &lt;code>n x n&lt;/code>. A binary matrix has only &lt;code>0&lt;/code>s and &lt;code>1&lt;/code>s as values.&lt;br>
We &lt;strong>translate&lt;/strong> one image however we choose by sliding all the &lt;code>1&lt;/code> bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the &lt;strong>overlap&lt;/strong> by counting the number of positions that have a &lt;code>1&lt;/code> in &lt;strong>both&lt;/strong> images.
Note also that a translation does &lt;strong>not&lt;/strong> include any kind of rotation. Any &lt;code>1&lt;/code> bits that are translated outside of the matrix bordered are erased.&lt;br>
Return &lt;em>the largest possible overlap&lt;/em>.&lt;/p></description></item><item><title>[LeetCode] 2653. Sliding Subarray Beauty</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2653/</link><pubDate>Thu, 27 Oct 2022 12:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2653/</guid><description>&lt;ul>
&lt;li>難度分: 1786&lt;/li>
&lt;li>我覺得這一題稍有難度，主要在處理 &lt;code>findKth&lt;/code> 方法時，有一些技巧，如果單純用 vector 來記錄 window，會 LTE，因為 &lt;code>nums[i]&lt;/code> 的範圍滿小的(-50~50之間)，可以用 &lt;code>bucket sort&lt;/code>，如果數字再更大一點，可以使用 &lt;code>fenwick tree&lt;/code> 或是 &lt;code>segment tree&lt;/code> 範圍求和，使 &lt;code>update&lt;/code> 與 &lt;code>query&lt;/code> 的複雜度都是 \(\log(n)\)&lt;/li>
&lt;li>Bucket Sort&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">NumberTracker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> update(&lt;span style="color:#66d9ef">int&lt;/span> num, &lt;span style="color:#66d9ef">int&lt;/span> delta) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>NumberTracker() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BucketSort&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> NumberTracker {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> right_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BucketSort(&lt;span style="color:#66d9ef">int&lt;/span> left, &lt;span style="color:#66d9ef">int&lt;/span> right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_ &lt;span style="color:#f92672">=&lt;/span> left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right_ &lt;span style="color:#f92672">=&lt;/span> right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n_ &lt;span style="color:#f92672">=&lt;/span> right &lt;span style="color:#f92672">-&lt;/span> left &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt.assign(n_, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num, &lt;span style="color:#66d9ef">int&lt;/span> delta) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt[num &lt;span style="color:#f92672">-&lt;/span> left_] &lt;span style="color:#f92672">+=&lt;/span> delta;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> total &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n_; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total &lt;span style="color:#f92672">+=&lt;/span> cnt[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (total &lt;span style="color:#f92672">&amp;gt;=&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> left_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>NumberTracker&lt;span style="color:#f92672">&amp;gt;&lt;/span> tracker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Solution() &lt;span style="color:#f92672">:&lt;/span> tracker(make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>BucketSort&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">50&lt;/span>, &lt;span style="color:#ae81ff">50&lt;/span>)) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> getSubarrayBeauty(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>update(nums[i], &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>findKth(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.push_back(min(ans, &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>update(nums[i&lt;span style="color:#f92672">-&lt;/span>k], &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>update(nums[i], &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans &lt;span style="color:#f92672">=&lt;/span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>findKth(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.push_back(min(ans, &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Fenwick Tree&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FenwickTree&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> NumberTracker {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> right_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> bit;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">lowbit&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#f92672">-&lt;/span>a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> idx, &lt;span style="color:#66d9ef">int&lt;/span> diff) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> bit.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (idx &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bit[idx] &lt;span style="color:#f92672">+=&lt;/span> diff;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx &lt;span style="color:#f92672">+=&lt;/span> lowbit(idx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">query&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> idx) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (idx &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> bit[idx];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx &lt;span style="color:#f92672">-=&lt;/span> lowbit(idx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FenwickTree(&lt;span style="color:#66d9ef">int&lt;/span> left, &lt;span style="color:#66d9ef">int&lt;/span> right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_ &lt;span style="color:#f92672">=&lt;/span> left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right_ &lt;span style="color:#f92672">=&lt;/span> right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n_ &lt;span style="color:#f92672">=&lt;/span> right &lt;span style="color:#f92672">-&lt;/span> left &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bit.assign(n_ &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num, &lt;span style="color:#66d9ef">int&lt;/span> delta) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num &lt;span style="color:#f92672">-=&lt;/span> left_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add(num, delta);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> n_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (left &lt;span style="color:#f92672">&amp;lt;&lt;/span> right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> (left &lt;span style="color:#f92672">+&lt;/span> right) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (query(mid) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> k)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right &lt;span style="color:#f92672">=&lt;/span> mid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> min(&lt;span style="color:#ae81ff">0&lt;/span>, left &lt;span style="color:#f92672">+&lt;/span> left_);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Segment Tree (zkw tree)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">NumberTracker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> build(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> nums) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num, &lt;span style="color:#66d9ef">int&lt;/span> delta) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>NumberTracker() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SegmentTree&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> NumberTracker {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> tree_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> num_to_idx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> idx_to_num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">lowbit&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#f92672">-&lt;/span>a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SegmentTree() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">build&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> nums) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sort(nums.begin(), nums.end());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> nums[i] &lt;span style="color:#f92672">==&lt;/span> nums[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num_to_idx[nums[i]] &lt;span style="color:#f92672">=&lt;/span> j;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx_to_num[j&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (n_ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; n_ &lt;span style="color:#f92672">&amp;lt;&lt;/span> num_to_idx.size(); n_ &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m_ &lt;span style="color:#f92672">=&lt;/span> n_ &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree_.assign(m_, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num, &lt;span style="color:#66d9ef">int&lt;/span> delta) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> num_to_idx[num];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx &lt;span style="color:#f92672">+=&lt;/span> n_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (idx &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree_[idx] &lt;span style="color:#f92672">+=&lt;/span> delta;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findKth&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (idx &lt;span style="color:#f92672">&amp;lt;&lt;/span> n_) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tree_[idx] &lt;span style="color:#f92672">&amp;lt;&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">-=&lt;/span> tree_[idx];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> idx&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> idx_to_num[idx &lt;span style="color:#f92672">-&lt;/span> n_];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>NumberTracker&lt;span style="color:#f92672">&amp;gt;&lt;/span> tracker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Solution() &lt;span style="color:#f92672">:&lt;/span> tracker(make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>SegmentTree&lt;span style="color:#f92672">&amp;gt;&lt;/span>()) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> getSubarrayBeauty(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>build(nums);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>update(nums[i], &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>findKth(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.push_back(min(ans, &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>update(nums[i&lt;span style="color:#f92672">-&lt;/span>k], &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>update(nums[i], &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans &lt;span style="color:#f92672">=&lt;/span> tracker&lt;span style="color:#f92672">-&amp;gt;&lt;/span>findKth(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.push_back(min(ans, &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[Leetcode] 12. Integer to Roman</title><link>https://intervalrain.github.io/leetcode/12/</link><pubDate>Wed, 26 Oct 2022 20:36:08 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/12/</guid><description>&lt;p>&lt;strong>12. Integer to Roman&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Hash Table&lt;/code>、&lt;code>Math&lt;/code>、&lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Roman numerals are represented by seven different symbols: &lt;code>I&lt;/code>, &lt;code>V&lt;/code>, &lt;code>X&lt;/code>, &lt;code>L&lt;/code>, &lt;code>C&lt;/code>, &lt;code>D&lt;/code>, and &lt;code>M&lt;/code>.&lt;br>
\(\boxed{\begin{array}{ll}
\textbf{Symbol}&amp;amp;\textbf{Value}\\
\texttt{I}&amp;amp;1\\
\texttt{V}&amp;amp;5\\
\texttt{X}&amp;amp;10\\
\texttt{L}&amp;amp;50\\
\texttt{C}&amp;amp;100\\
\texttt{D}&amp;amp;500\\
\texttt{M}&amp;amp;1000\\
\end{array}}\)&lt;br>
For example, &lt;code>2&lt;/code> is written as &lt;code>II&lt;/code> in Roman numeral, just two one&amp;rsquo;s added together. &lt;code>12&lt;/code> is written as &lt;code>XII&lt;/code>, which is simply &lt;code>X + II&lt;/code>. The number &lt;code>27&lt;/code> is written as &lt;code>XXVII&lt;/code>, which is &lt;code>XX + V + II&lt;/code>.&lt;br>
Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not &lt;code>IIII&lt;/code>. Instead the number four is written as &lt;code>IV&lt;/code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as &lt;code>IX&lt;/code>. There are six instances where subtraction is used:&lt;/p></description></item><item><title>[Leetcode] 11. Container With Most Water</title><link>https://intervalrain.github.io/leetcode/11/</link><pubDate>Wed, 26 Oct 2022 19:36:06 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/11/</guid><description>&lt;p>&lt;strong>11. Container With Most Water&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Two Pointer&lt;/code>、&lt;code>Greedy&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given an integer array &lt;code>height&lt;/code> of length &lt;code>n&lt;/code>. There are &lt;code>n&lt;/code> vertical lines drawn such that the two endpoints of the &lt;code>ith&lt;/code> line are &lt;code>(i, 0)&lt;/code> and &lt;code>(i, height[i])&lt;/code>.&lt;br>
Find two lines that together with the x-axis form a container, such that the container contains the most water.&lt;br>
Return &lt;em>the maximum amount of water a container can store&lt;/em>.&lt;br>
&lt;strong>Notive&lt;/strong> that you may not slant the container.&lt;/p></description></item><item><title>[Leetcode] 10. Regular Expression Matching</title><link>https://intervalrain.github.io/leetcode/10/</link><pubDate>Wed, 26 Oct 2022 18:36:01 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/10/</guid><description>&lt;p>&lt;strong>10. Regular Expression Matching&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Dynamic Programming&lt;/code>、&lt;code>Recursion&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an input string &lt;code>s&lt;/code> and a pattern &lt;code>p&lt;/code>, implement regular expression matching with support for &lt;code>'.'&lt;/code> and &lt;code>'*'&lt;/code> where:&lt;/p>
&lt;ul>
&lt;li>&lt;code>'.'&lt;/code> Matches any single character.&lt;/li>
&lt;li>&lt;code>'*'&lt;/code> Matches zero or more of the preceding element.&lt;br>
The matching should cover the &lt;strong>entire&lt;/strong> input string (not partial).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;aa&amp;rdquo;, p = &amp;ldquo;a&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> false&lt;/li>
&lt;li>&lt;strong>Explanation&lt;/strong>: &amp;ldquo;a&amp;rdquo; does not match the entire string &amp;ldquo;aa&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2134. Minimum Swaps to Group All 1's Together II</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2134/</link><pubDate>Wed, 26 Oct 2022 12:00:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2134/</guid><description>&lt;ul>
&lt;li>難度分: 1748&lt;/li>
&lt;li>遇到 circular 的問題都可以換位思考，這題可以想成「min swaps to group all 1」或「min swaps to group all 0」&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> minSwaps(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> accumulate(nums.begin(), nums.end(), &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">min&lt;/span>(minSwapsHelper(nums, &lt;span style="color:#ae81ff">1&lt;/span>, k), minSwapsHelper(nums, &lt;span style="color:#ae81ff">0&lt;/span>, n&lt;span style="color:#f92672">-&lt;/span>k));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">minSwapsHelper&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> target, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums[i] &lt;span style="color:#f92672">==&lt;/span> target) curr&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> curr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums[i] &lt;span style="color:#f92672">==&lt;/span> target) curr&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums[i&lt;span style="color:#f92672">-&lt;/span>k] &lt;span style="color:#f92672">==&lt;/span> target) curr&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt &lt;span style="color:#f92672">=&lt;/span> max(cnt, curr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> k &lt;span style="color:#f92672">-&lt;/span> cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[Leetcode] 9. Palindrome Number</title><link>https://intervalrain.github.io/leetcode/9/</link><pubDate>Wed, 26 Oct 2022 10:20:08 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/9/</guid><description>&lt;p>&lt;strong>9. Palindrome Number&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Math&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer &lt;code>x&lt;/code>, return &lt;code>true&lt;/code> if &lt;code>x&lt;/code> is palindrome number.&lt;br>
An integer is a &lt;strong>palindrome&lt;/strong> when it reads the same backward as forward.&lt;/p>
&lt;ul>
&lt;li>For example, &lt;code>121&lt;/code> is a palindrome while &lt;code>123&lt;/code> is not.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> x = 121&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> true&lt;/li>
&lt;li>&lt;strong>Explanation&lt;/strong>: 121 reads as 121 from left to right and from right to left.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> x = -121&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> false&lt;/li>
&lt;li>&lt;strong>Explanation&lt;/strong>: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p></description></item><item><title>[Leetcode] 8. String to Integer (atoi)</title><link>https://intervalrain.github.io/leetcode/8/</link><pubDate>Wed, 26 Oct 2022 00:21:56 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/8/</guid><description>&lt;p>&lt;strong>8. String to Integer (atoi)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Implement the &lt;code>myAtoi(string s)&lt;/code> function, which converts a string to a 32-bit signed integer (similar to C/C++&amp;rsquo;s &lt;code>atoi&lt;/code> function).&lt;br>
The algorithm for &lt;code>myAtoi(string s)&lt;/code> is as follows:&lt;/p>
&lt;ol>
&lt;li>Read in and ignore any leading whitespace.&lt;/li>
&lt;li>Check if the next character (if not already at the end of the string) is &lt;code>'-'&lt;/code> or &lt;code>'+'&lt;/code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.&lt;/li>
&lt;li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.&lt;/li>
&lt;li>Convert these digits into an integer (i.e. &lt;code>&amp;quot;123&amp;quot; -&amp;gt; 123&lt;/code>, &lt;code>&amp;quot;0032&amp;quot; -&amp;gt; 32&lt;/code>). If no digits were read, then the integer is &lt;code>0&lt;/code>. Change the sign as necessary (from step 2).&lt;/li>
&lt;li>If the integer is out of the 32-bit signed integer range &lt;code>[-2^31, 2^31-1]&lt;/code>, then clamp the integer so that it remains in the range. Specifically, integers less than &lt;code>-2^31&lt;/code> should be clamped to &lt;code>-2^31&lt;/code>, and integer greater than &lt;code>2^31-1&lt;/code> should be clamped to &lt;code>2^31-1&lt;/code>.&lt;/li>
&lt;li>Return the integer as the final result.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Note:&lt;/strong>&lt;/p></description></item><item><title>[Leetcode] 7. Reverse Integer</title><link>https://intervalrain.github.io/leetcode/7/</link><pubDate>Tue, 25 Oct 2022 23:47:53 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/7/</guid><description>&lt;p>&lt;strong>7. Reverse Integer&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Math&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a signed 32-bit integer &lt;code>x&lt;/code>, return &lt;code>x&lt;/code> &lt;em>with its digits reversed&lt;/em>. If reversing &lt;code>x&lt;/code> causes the value to go outside the signed 32-bit integer range &lt;code>[-2^31, 2^31-1]&lt;/code>, then return &lt;code>0&lt;/code>.&lt;br>
&lt;strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> x = 123&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 321&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> x = -123&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> -321&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p></description></item><item><title>[Leetcode] 6. Zigzag Conversion</title><link>https://intervalrain.github.io/leetcode/6/</link><pubDate>Tue, 25 Oct 2022 21:40:24 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/6/</guid><description>&lt;p>&lt;strong>6. Zigzag Conversion&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>The string &lt;code>&amp;quot;PAYPALISHIRING&amp;quot;&lt;/code> is written in a zigzag pattern on a given number of rows like this: (you may want to dispaly this pattern in a fixed font for better legibility)&lt;br>
\(
\quad\texttt{P A H N}\\
\quad\texttt{APLSIIG}\\
\quad\texttt{Y I R}\\
\)&lt;br>
And then read line by line: &lt;code>&amp;quot;PAHNAPLSIIGYIR&amp;quot;&lt;/code>&lt;br>
Write the code that will take a string and make this conversion given a number of rows:
&lt;code>string convert(string s, int numRows&lt;/code>&lt;/p></description></item><item><title>[LeetCode] 5. Longest Palindromic Substring</title><link>https://intervalrain.github.io/leetcode/5/</link><pubDate>Tue, 25 Oct 2022 16:32:51 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/5/</guid><description>&lt;p>&lt;strong>5. Longest Substring Without Repeating Characters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>String&lt;/code>、&lt;code>Dynamic Programming&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a string &lt;code>s&lt;/code>, return &lt;em>the longest palindromic substring&lt;/em> in &lt;code>s&lt;/code>.&lt;br>
A string is called a palindrome string if the reverse of that string is the same of the original string.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;babad&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> &amp;ldquo;bab&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> &amp;ldquo;aba&amp;rdquo; is also a valid answer.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;cbbd&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> &amp;ldquo;bb&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code>&lt;/li>
&lt;li>&lt;code>s&lt;/code> consists of only digits and English letters.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="二分析">二、分析&lt;/h3>
&lt;ul>
&lt;li>注意 palindrome string 的特性：
&lt;ul>
&lt;li>當長度為 &lt;code>1&lt;/code> 時，必為 palindrome string&lt;/li>
&lt;li>當長度為 &lt;code>2&lt;/code> 時，兩個字元必須相同才為 palindrome string&lt;/li>
&lt;li>當長度 &lt;code>&amp;gt;2&lt;/code> 時，palindrome string 必須滿足
&lt;ol>
&lt;li>最左邊的字元等於最右邊的字元，即 &lt;code>s[left] == s[right]&lt;/code>&lt;/li>
&lt;li>除去最左邊的字元跟最右邊的字元，必須為 palindrome string，&lt;br>
即 &lt;code>s.substr(left+1, len-2)&lt;/code> 為 palindromic。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="三解題">三、解題&lt;/h3>
&lt;h4 id="1-dynamic-prograimming">1. Dynamic Prograimming&lt;/h4>
&lt;ul>
&lt;li>Time complexity: \(O(n^2)\)&lt;/li>
&lt;li>Space complexity: \(O(n^2)\)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>string &lt;span style="color:#a6e22e">longestPalindrome&lt;/span>(string s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.length();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> dp[n][n];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(dp, false, &lt;span style="color:#66d9ef">sizeof&lt;/span>(dp));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> j; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> j) { &lt;span style="color:#75715e">// 長度為 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dp[i][j] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (j &lt;span style="color:#f92672">-&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) { &lt;span style="color:#75715e">// 長度為 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dp[i][j] &lt;span style="color:#f92672">=&lt;/span> s[i] &lt;span style="color:#f92672">==&lt;/span> s[j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#75715e">// 長度 &amp;gt; 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dp[i][j] &lt;span style="color:#f92672">=&lt;/span> s[i] &lt;span style="color:#f92672">==&lt;/span> s[j] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> dp[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dp[i][j] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#f92672">-&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> len) { &lt;span style="color:#75715e">// 比較長度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> j &lt;span style="color:#f92672">-&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> s.substr(i, len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://intervalrain.github.io/leetcode">回目錄 Catalog&lt;/a>&lt;/p></description></item><item><title>[LeetCode] 4. Median of Two Sorted Arrays</title><link>https://intervalrain.github.io/leetcode/4/</link><pubDate>Tue, 25 Oct 2022 14:52:18 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/4/</guid><description>&lt;p>&lt;strong>4. Median of Two Sorted Arrays&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{red}\textsf{Hard}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Binary Search&lt;/code>、&lt;code>Divide and Conquer&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given two sorted arrays &lt;code>nums1&lt;/code> and &lt;code>nums2&lt;/code> of size &lt;code>m&lt;/code> and &lt;code>n&lt;/code> respectively, return &lt;strong>the median&lt;/strong> of the sorted arrays.&lt;br>
The overall run time complexity should be &lt;code>O(log (m+n))&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums1 = [1,3], nums2 = [2]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 2.00000&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> merged array = [1,2,3] and median is 2.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums1 = [1,2], nums2 = [3,4]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 2.50000&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 3. Longest Substring Without Repeating Characters</title><link>https://intervalrain.github.io/leetcode/3/</link><pubDate>Tue, 25 Oct 2022 14:20:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/3/</guid><description>&lt;p>&lt;strong>3. Longest Substring Without Repeating Characters&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Hash Table&lt;/code>、&lt;code>String&lt;/code>、&lt;code>Sliding Window&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given a string &lt;code>s&lt;/code>, find the length of the &lt;strong>longest substring&lt;/strong> without repeating characters.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;abcabcbb&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 3&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The answer is &amp;ldquo;abc&amp;rdquo;, with the length of 3.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;bbbbb&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 1&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> s = &amp;ldquo;pwwkew&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> 3&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> The answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3. Notice that the answer must be a substring, &amp;ldquo;pwke&amp;rdquo; is a subsequence and not a substring.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 2. Add Two Numbers</title><link>https://intervalrain.github.io/leetcode/2/</link><pubDate>Tue, 25 Oct 2022 13:38:00 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/2/</guid><description>&lt;p>&lt;strong>2. Add Two Numbers&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Linked List&lt;/code>、&lt;code>Math&lt;/code>、&lt;code>Recursion&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>You are given two &lt;strong>non-empty&lt;/strong> linked lists representing two non-negative integers. The digits are stored in &lt;strong>reverse order&lt;/strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&lt;br>
You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;br>
&lt;img alt="addtwonumber1" loading="lazy" src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> l1 = [2,4,3], l2 = [5,6,4]&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [7,0,8]&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> 342 + 465 = 807&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1297. Maximum Number of Occurrences of a Substring</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1297/</link><pubDate>Tue, 25 Oct 2022 12:43:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1297/</guid><description>&lt;ul>
&lt;li>難度分: 1748&lt;/li>
&lt;li>這題的 minSize 和 maxSize 在 26 以內，範圍不會太大，可以用定長度的 sliding window 硬解。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxFreq(string s, &lt;span style="color:#66d9ef">int&lt;/span> maxLetters, &lt;span style="color:#66d9ef">int&lt;/span> minSize, &lt;span style="color:#66d9ef">int&lt;/span> maxSize) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> minSize; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> maxSize; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, maxFreqWithWindowSize(s, maxLetters, i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maxFreqWithWindowSize&lt;/span>(string&lt;span style="color:#f92672">&amp;amp;&lt;/span> s, &lt;span style="color:#66d9ef">int&lt;/span> th, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> s.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt[&lt;span style="color:#ae81ff">26&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(cnt, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(cnt));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> uq &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt[s[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>]&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) uq&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uq &lt;span style="color:#f92672">&amp;lt;=&lt;/span> th) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map[s.substr(&lt;span style="color:#ae81ff">0&lt;/span>, k)]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt[s[i]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>]&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) uq&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">--&lt;/span>cnt[s[i&lt;span style="color:#f92672">-&lt;/span>k]&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) uq&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uq &lt;span style="color:#f92672">&amp;lt;=&lt;/span> th) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string t &lt;span style="color:#f92672">=&lt;/span> s.substr(i&lt;span style="color:#f92672">-&lt;/span>k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, &lt;span style="color:#f92672">++&lt;/span>map[t]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1652. Defuse the Bomb</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1652/</link><pubDate>Tue, 25 Oct 2022 12:42:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1652/</guid><description>&lt;ul>
&lt;li>這題要用 sliding window 解需要處理 circular iteration&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> decrypt(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> code, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> code.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res(n, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (k &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> abs(k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> k &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> n&lt;span style="color:#f92672">+&lt;/span>k;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> code[(start &lt;span style="color:#f92672">+&lt;/span> i) &lt;span style="color:#f92672">%&lt;/span> n];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> m, j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m &lt;span style="color:#f92672">+&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>, j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> in &lt;span style="color:#f92672">=&lt;/span> (start &lt;span style="color:#f92672">+&lt;/span> i) &lt;span style="color:#f92672">%&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> out &lt;span style="color:#f92672">=&lt;/span> (start &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> k) &lt;span style="color:#f92672">%&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> (code[(start &lt;span style="color:#f92672">+&lt;/span> i) &lt;span style="color:#f92672">%&lt;/span> n] &lt;span style="color:#f92672">-&lt;/span> code[(start &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> m) &lt;span style="color:#f92672">%&lt;/span> n]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res[j] &lt;span style="color:#f92672">=&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1. Two Sum</title><link>https://intervalrain.github.io/leetcode/1/</link><pubDate>Tue, 25 Oct 2022 12:41:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/1/</guid><description>&lt;p>&lt;strong>1. Two Sum&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{green}\textsf{Easy}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an array of integers &lt;code>nums&lt;/code> and an integer &lt;code>target&lt;/code>, return &lt;em>indices of the two numbers such that they add up to &lt;code>target&lt;/code>&lt;/em>.&lt;br>
You may assume that each input would have &lt;strong>exactly one solution&lt;/strong>, and you may not use the &lt;em>same&lt;/em> element twice.&lt;br>
You can return the answer in any order.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [2,7,11,15], taget = 9&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [0,1]&lt;/li>
&lt;li>&lt;strong>Explanation:&lt;/strong> Because nums[0] + nums[1] == 9, we return [0,1].&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description></item><item><title>[LeetCode] 1423. Maximum Points You Can Obtain from Cards</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1423/</link><pubDate>Tue, 25 Oct 2022 12:41:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1423/</guid><description>&lt;ul>
&lt;li>難度分: 1574&lt;/li>
&lt;li>這題同樣是定長度的 sliding window，但要透過一點轉換，變成求 &lt;code>window = n - k&lt;/code> 的最小和&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxScore(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> cardPoints, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> cardPoints.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">-&lt;/span>k;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> cardPoints[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> total &lt;span style="color:#f92672">=&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> min_window_sum &lt;span style="color:#f92672">=&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> m; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> (cardPoints[i] &lt;span style="color:#f92672">-&lt;/span> cardPoints[i&lt;span style="color:#f92672">-&lt;/span>m]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total &lt;span style="color:#f92672">+=&lt;/span> cardPoints[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min_window_sum &lt;span style="color:#f92672">=&lt;/span> min(min_window_sum, sum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> total &lt;span style="color:#f92672">-&lt;/span> min_window_sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 2461. Maximum Sum of Distinct Subarrays With Length K</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2461/</link><pubDate>Tue, 25 Oct 2022 12:40:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2461/</guid><description>&lt;ul>
&lt;li>難度分: 1553&lt;/li>
&lt;li>定長度的 sliding window，搭配對 window 檢查是否滿足條件&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> maximumSubarraySum(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> valid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt[nums[i]]&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> valid &lt;span style="color:#f92672">==&lt;/span> k &lt;span style="color:#f92672">?&lt;/span> sum : &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> (nums[i] &lt;span style="color:#f92672">-&lt;/span> nums[i&lt;span style="color:#f92672">-&lt;/span>k]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt[nums[i]]&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">--&lt;/span>cnt[nums[i&lt;span style="color:#f92672">-&lt;/span>k]] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) valid&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">==&lt;/span> k) res &lt;span style="color:#f92672">=&lt;/span> max(res, sum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 2841. Maximum Sum of Almost Unique Subarray</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2841/</link><pubDate>Tue, 25 Oct 2022 12:39:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2841/</guid><description>&lt;ul>
&lt;li>難度分: 1546&lt;/li>
&lt;li>定長度的 sliding window，搭配對 window 檢查是否滿足條件&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> maxSum(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> m, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> valid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt[nums[i]]&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">&amp;gt;=&lt;/span> m) res &lt;span style="color:#f92672">=&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> (nums[i] &lt;span style="color:#f92672">-&lt;/span> nums[i&lt;span style="color:#f92672">-&lt;/span>k]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt[nums[i]]&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) valid&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">--&lt;/span>cnt[nums[i&lt;span style="color:#f92672">-&lt;/span>k]] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) valid&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valid &lt;span style="color:#f92672">&amp;gt;=&lt;/span> m) res &lt;span style="color:#f92672">=&lt;/span> max(res, sum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1461. Check If a String Contains All Binary Codes of Size K</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1461/</link><pubDate>Tue, 25 Oct 2022 12:38:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1461/</guid><description>&lt;ul>
&lt;li>難度分: 1504&lt;/li>
&lt;li>比較簡單的解法，使用 unordered_set&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> hasAllCodes(string s, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_set&lt;span style="color:#f92672">&amp;lt;&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> set;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">+&lt;/span> k &lt;span style="color:#f92672">&amp;lt;=&lt;/span> s.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> set.insert(s.substr(i, k));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> set.size() &lt;span style="color:#f92672">==&lt;/span> pow(&lt;span style="color:#ae81ff">2&lt;/span>, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>使用 sliding window，並運用移位運算子&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> hasAllCodes(string s, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (s.size() &lt;span style="color:#f92672">&amp;lt;&lt;/span> k) &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> pow(&lt;span style="color:#ae81ff">2&lt;/span>, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> used(n, false);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">+=&lt;/span> (s[i] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> used[curr] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">+=&lt;/span> (s[i] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">%=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> used[curr] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">all_of&lt;/span>(used.begin(), used.end(), [](&lt;span style="color:#66d9ef">int&lt;/span> x) { &lt;span style="color:#66d9ef">return&lt;/span> x; });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1052. Grumpy Bookstore Owner</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1052/</link><pubDate>Tue, 25 Oct 2022 12:36:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1052/</guid><description>&lt;ul>
&lt;li>難度分: 1418&lt;/li>
&lt;li>定長度的 sliding window，秒殺&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxSatisfied(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> customers, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> grumpy, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> customers.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>grumpy[i]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> customers[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> customers[i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> customers[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> (customers[i] &lt;span style="color:#f92672">-&lt;/span> customers[i&lt;span style="color:#f92672">-&lt;/span>k]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, sum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 2379. Minimum Recolors to Get K Consecutive Black Blocks</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2379/</link><pubDate>Tue, 25 Oct 2022 12:35:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2379/</guid><description>&lt;ul>
&lt;li>難度分: 1360&lt;/li>
&lt;li>定長度的 sliding window，秒殺&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> minimumRecolors(string blocks, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (blocks[i] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;B&amp;#39;&lt;/span>) cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> k&lt;span style="color:#f92672">-&lt;/span>cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> blocks.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (blocks[i] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;B&amp;#39;&lt;/span>) cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (blocks[i&lt;span style="color:#f92672">-&lt;/span>k] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;B&amp;#39;&lt;/span>) cnt&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> min(res, k&lt;span style="color:#f92672">-&lt;/span>cnt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 2090. K Radius Subarray Averages</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2090/</link><pubDate>Tue, 25 Oct 2022 12:34:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2090/</guid><description>&lt;ul>
&lt;li>難度分: 1358
&lt;img alt="sample" loading="lazy" src="https://assets.leetcode.com/uploads/2021/11/07/eg1.png">&lt;/li>
&lt;li>這題一樣是定長度的 sliding window，但要做一下轉換，半徑為 &lt;code>k&lt;/code>，代表 window_size 為 &lt;code>2k+1&lt;/code>。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> getAverages(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res(n, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (m &lt;span style="color:#f92672">&amp;gt;&lt;/span> n) &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res[k] &lt;span style="color:#f92672">=&lt;/span> sum &lt;span style="color:#f92672">/&lt;/span> m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> m, j &lt;span style="color:#f92672">=&lt;/span> k&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>, j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> (nums[i] &lt;span style="color:#f92672">-&lt;/span> nums[i&lt;span style="color:#f92672">-&lt;/span>m]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res[j] &lt;span style="color:#f92672">=&lt;/span> sum &lt;span style="color:#f92672">/&lt;/span> m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1343/</link><pubDate>Tue, 25 Oct 2022 12:33:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1343/</guid><description>&lt;ul>
&lt;li>難度分: 1317&lt;/li>
&lt;li>定長度的 sliding window，秒殺&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> numOfSubarrays(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> arr, &lt;span style="color:#66d9ef">int&lt;/span> k, &lt;span style="color:#66d9ef">int&lt;/span> threshold) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threshold &lt;span style="color:#f92672">*=&lt;/span> k;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> arr[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (sum &lt;span style="color:#f92672">&amp;gt;=&lt;/span> threshold) res&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> arr.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> (arr[i] &lt;span style="color:#f92672">-&lt;/span> arr[i&lt;span style="color:#f92672">-&lt;/span>k]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (sum &lt;span style="color:#f92672">&amp;gt;=&lt;/span> threshold) res&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 643. Maximum Average Subarray I</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/643/</link><pubDate>Tue, 25 Oct 2022 12:32:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/643/</guid><description>&lt;ul>
&lt;li>定長度的 sliding window，秒殺&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> findMaxAverage(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">-=&lt;/span> nums[i&lt;span style="color:#f92672">-&lt;/span>k];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, sum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res&lt;span style="color:#f92672">/&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)k;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 1456. Maximum Number of Vowels in a Substring of Given Length</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1456/</link><pubDate>Tue, 25 Oct 2022 12:31:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1456/</guid><description>&lt;ul>
&lt;li>難度分: 1263&lt;/li>
&lt;li>定長度的 sliding window，秒殺&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxVowels(string s, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unordered_set&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> set &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;e&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;i&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;o&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;u&amp;#39;&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (set.count(s[i])) cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (set.count(s[i])) cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (set.count(s[i&lt;span style="color:#f92672">-&lt;/span>k])) cnt&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, cnt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] 定長 Sliding Window Pattern</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/pattern_1/</link><pubDate>Tue, 25 Oct 2022 12:31:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/pattern_1/</guid><description>&lt;ul>
&lt;li>定長度的 sliding window pattern&lt;/li>
&lt;li>步驟
&lt;ol>
&lt;li>construct sliding window + check condition&lt;/li>
&lt;li>move sliding window&lt;br>
(1) remove item&lt;br>
(2) check condition&lt;br>
(3) add item&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Window&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> add(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">erase&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Window() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Window&lt;span style="color:#f92672">&amp;gt;&lt;/span> _w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> solve(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w &lt;span style="color:#f92672">=&lt;/span> make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>WindowImpl&lt;span style="color:#f92672">&amp;gt;&lt;/span>(k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> k) _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>erase(nums[i&lt;span style="color:#f92672">-&lt;/span>k]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (_w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>check(nums[i])) &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _w&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add(nums[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>[LeetCode] Sliding Window and Double Pointer 科學刷題</title><link>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/</link><pubDate>Tue, 25 Oct 2022 12:30:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/</guid><description>&lt;h1 id="1-定長滑動窗口">1. 定長滑動窗口&lt;/h1>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/pattern_1">定長滑動窗口 pattern&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="11-基礎">1.1 基礎&lt;/h2>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1456">1456. Maximum Number of Vowels in a Substring of Given Length&lt;/a>(1263)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/643">643. Maximum Average Subarray I&lt;/a>&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1343">1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold&lt;/a>(1317)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2090">2090. K Radius Subarray Averages&lt;/a>(1358)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2379">2379. Minimum Recolors to Get K Consecutive Black Blocks&lt;/a>(1360)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1052">1052. Grumpy Bookstore Owner&lt;/a>(1418)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1461">1461. Check If a String Contains All Binary Codes of Size K&lt;/a>(1504)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2841">2841. Maximum Sum of Almost Unique Subarray&lt;/a>(1546)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2461">2461. Maximum Sum of Distinct Subarrays With Length K&lt;/a>(1553)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1423">1423. Maximum Points You Can Obtain from Cards&lt;/a>(1574)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1652">1652. Defuse the Bomb&lt;/a>&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1297">1297. Maximum Number of Occurrences of a Substring&lt;/a>(1748)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 1176. Diet Plan Performance(會員題)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 1100. Find K-Length Substrings With No Repeated Characters(會員題)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 1852. Distinct Numbers in Each Subarray(會員題)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 1151. Minimum Swaps to Group All 1&amp;rsquo;s Together(會員題)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 2107. Number of Unique Flavors After sharing K Candies(會員題)&lt;/li>
&lt;/ul>
&lt;h2 id="12-進階">1.2 進階&lt;/h2>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2134">2134. Minimum Swaps to Group All 1&amp;rsquo;s Together II&lt;/a>(1748)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2653">2653. Sliding Subarray Beauty&lt;/a>(1786)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1888">1888. Minimum Number of Flips to Make the Binary String Alternating&lt;/a>(2006)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/567">567. Permutation in String&lt;/a>&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/438">438. Find All Anagrams in a String&lt;/a>&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/30">30. Substring with Concatenation of All Words&lt;/a>&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2156">2156. Find Substring With Given Hash Value&lt;/a>(2063)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2953">2953. Count Complete Substrings&lt;/a>(2449)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1016">1016. Binary String With Substrings Representing 1 To N&lt;/a>&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 683. K Empty Slots(會員題)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 2067. Number of Equal Count Substrings(會員題)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 2524. Maximum Frequency Score of a substring(會員題)&lt;/li>
&lt;/ul>
&lt;h2 id="13-其它">1.3 其它&lt;/h2>
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2269">2269. Find the K-Beauty of a Number&lt;/a>(1280)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1984">1984. Minimum Difference Between Highest and Lowest of K Scores&lt;/a>(1306)&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> &lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/220">220. Contains Duplicate III&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="2-不定長滑動窗口">2. 不定長滑動窗口&lt;/h1>
&lt;blockquote>
&lt;p>不定長滑動窗口主要分為三類：求最長子數組、求最短子數組，以及求子數組個數。&lt;/p></description></item><item><title>[LeetCode] Catalog</title><link>https://intervalrain.github.io/leetcode/</link><pubDate>Tue, 25 Oct 2022 11:30:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/</guid><description>&lt;p>&lt;a href="https://intervalrain.github.io/leetcode_list">科學刷題&lt;/a>&lt;/p>
&lt;h2 id="catalog">&lt;strong>Catalog&lt;/strong>&lt;/h2>
&lt;h2 id="一依題號">一、依題號&lt;/h2>
&lt;h3 id="1-50045">1-500(45)&lt;/h3>
&lt;p>&lt;a href="https://intervalrain.github.io/leetcode/1">1. Two Sum&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/2">2. Add Two Numbers&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/3">3. Longest Substring Without Repeating Characters&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/4">4. Median of Two Sorted Array&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/5">5. Longest Palindromic Substring&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/6">6. Zigzag Conversion&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/7">7. Reverse Integer&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/8">8. String to Integer (atoi)&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/9">9. Palindrome Number&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/10">10. Regular Expression Matching&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/11">11. Container With Most Water&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/12">12. Integer to Roman&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/13">13. Roman to Integer&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/14">14. Longest Common Prefix&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/15">15. 3Sum&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/16">16. 3Sum Closet&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/17">17. Letter Combinations of a Phone Number&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/18">18. 4Sum&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/19">19. Remove Nth Node From End of List&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/20">20. Valid Parentheses&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/21">21. Merge Two Sorted Lists&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/22">22. Generate Parentheses&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/23">23. Merge k Sorted Lists&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/24">24. Swap Nodes in Pairs&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/25">25. Reverse Nodes in k-Group&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/53">53. Maximum Subarray&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/70">70. Climbing Stairs&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/79">79. Word Search&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/100">100. Same Tree&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/124">124. Binary Tree Maximum Path Sum&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/132">132. Palindrome Partitioning II&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/149">149. Max Points on a Line&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/151">151. Reverse Words in a String&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/198">198. House Robber&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/212">212. Word Search II&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/213">213. House Robber II&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/223">223. Rectangle Area&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/279">279. Perfect Squares&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/290">290. Word Pattern&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/300">300. Longest Increasing Subsequence&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/322">322. Coin Change&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/328">328. Odd Even Linked List&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/337">337. House Robber III&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/347">347. Top K Frequent Elements&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/374">374. Guess Number Higher or Lower II&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/433">433. Minimum Genetic Mutation&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/446">446. Arithmetic Slices II - Subsequence&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode/452">452. Minimum Number of Arrows to Burst Balloons&lt;/a>&lt;/p></description></item><item><title>[LeetCode] 分類清單</title><link>https://intervalrain.github.io/leetcode_list/</link><pubDate>Tue, 25 Oct 2022 11:30:32 +0800</pubDate><guid>https://intervalrain.github.io/leetcode_list/</guid><description>&lt;h2 id="分類清單">分類清單&lt;/h2>
&lt;p>&lt;a href="https://intervalrain.github.io/leetcode_list/sliding_window_dblptr">1. 滑動窗口與雙指針（定長／不定長／單序列／雙序列／三指針／分組循環）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/binary_search">2. 二分演算法（二分答案／最小化最大值／最大化最小值／Kth）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/monotonic_stack">3. 單調棧（基礎／矩形面積／貢獻法／最小字典序）&lt;/a>
&lt;a href="https://intervalrain.github.io/leetcode_list/grid">4. 網格圖（DFS／BFS／綜合應用）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/bit_manipulation">5. 位運算（基礎／性質／拆位／試填／恆等式／思維）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/graph">6. 圖論演算法（DFS／BFS／拓撲排序／最短路／最小生成樹／二分圖／基環樹／歐拉路徑）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/dynamic_programming">7. 動態規劃（入門／背包／狀態機／劃分／區間／狀壓／數位／數據結構優化／樹形／博弈／概率期望）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/common_data_structure">8. 常用數據結構（前綴和／差分／棧／佇列／堆／字典樹／並查集／樹狀樹組／線段樹）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/math">9. 數學演算法（數論／組合／概率期望／博弈／計算幾何／隨機算法）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/greedy">10. 貪心與思維（基本貪心策略／反悔／區間／字典序／數學／思維／腦筋急轉彎／構造）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/linked_list_binary_tree">11. 鏈表、二叉樹與回溯（前後指針／快慢指針／DFS／BFS／直徑／LCA／一般樹）&lt;/a>&lt;br>
&lt;a href="https://intervalrain.github.io/leetcode_list/string">12. 字串（KMP／Z函數／Manacher／字串Hash／AC自動機／後綴數組／子序列自動機）&lt;/a> 　&lt;/p></description></item><item><title>[Leetcode] 347. Top K Frequent Elements</title><link>https://intervalrain.github.io/leetcode/347/</link><pubDate>Sat, 23 Jul 2022 23:48:15 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/347/</guid><description>&lt;p>&lt;strong>347. Top K Frequent Elements&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Hardness: \(\color{orange}\textsf{Medium}\)&lt;/li>
&lt;li>Ralated Topics: &lt;code>Array&lt;/code>、&lt;code>Hash Table&lt;/code>、&lt;code>Divide and Conquer&lt;/code>、&lt;code>Sorting&lt;/code>、&lt;code>Heap (Priority Queue)&lt;/code>、&lt;code>Bucket Sort&lt;/code>、&lt;code>Counting&lt;/code>、&lt;code>Quickselect&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="一題目">一、題目&lt;/h3>
&lt;p>Given an integer array &lt;code>nums&lt;/code> and an integer &lt;code>k&lt;/code>, return the &lt;code>k&lt;/code> &lt;em>most frequent elements&lt;/em>. You may return the answer in &lt;strong>any order&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [1,1,1,2,2,3], k = 2&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [1,2]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Input:&lt;/strong> nums = [1], k = 1&lt;/li>
&lt;li>&lt;strong>Output:&lt;/strong> [1]&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code>&lt;/li>
&lt;li>&lt;code>-10^4 &amp;lt;= nums[i] &amp;lt;= 10^4&lt;/code>&lt;/li>
&lt;li>&lt;code>k&lt;/code> is in the range &lt;code>[1, the number of unique elements in the array]&lt;/code>.&lt;/li>
&lt;li>It is &lt;strong>guaranteed&lt;/strong> that the answer is &lt;strong>unique&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Follow up:&lt;/strong> Your algorithm&amp;rsquo;s time complexity must be better than &lt;code>O(n log n)&lt;/code>, where n is the array&amp;rsquo;s size.&lt;/p></description></item><item><title>[Leetcode] Maximum Frequency Stack 最大頻率堆疊</title><link>https://intervalrain.github.io/leetcode/freqstack/</link><pubDate>Sat, 19 Mar 2022 16:53:23 +0800</pubDate><guid>https://intervalrain.github.io/leetcode/freqstack/</guid><description>Maximum Frequency Stack algorithm</description></item></channel></rss>