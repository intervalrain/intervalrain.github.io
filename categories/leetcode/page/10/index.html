<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leetcode | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/categories/leetcode/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/categories/leetcode/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/categories/leetcode/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/categories/leetcode/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="Leetcode"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Leetcode"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/categories/>Categories</a></div><h1>Leetcode</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 433. Minimum Genetic Mutation</h2></header><div class=entry-content><p>433. Minimum Genetic Mutation
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、String、Breadth-First Search 一、題目 A gene string can be represented by an 8-character long string, with choices from A, C, G, and T.
Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.
For example, "AACCGGTT" --> "AACCGGTA" is one mutation.
There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.
Given the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.
Note that the starting point is assumed to be valid, so it might not be included in the bank. Example 1:
...</p></div><footer class=entry-footer><span title='2022-11-02 23:36:32 +0800 +0800'>November 2, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 433. Minimum Genetic Mutation" href=https://intervalrain.github.io/leetcode/433/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2106. Maximum Fruits Harvested After at Most K Steps</h2></header><div class=entry-content><p>這一題困難的部分在於計算 windows size 我的作法是根據 startPos + i 來計算左指針，左指針位置會在 startPos - max(k - 2*i, (k - i) / 2)，也就是算出左邊來回或是右邊來回兩種情況下， windowSize 最大的可能。 class Solution { public: int maxTotalFruits(vector&lt;vector&lt;int>>& fruits, int startPos, int k) { sort(fruits.begin(), fruits.end()); int curr = 0; int j = 0; while (j &lt; fruits.size() && fruits[j][0] &lt; startPos - k) j++; int u = j; for (int i = startPos - k; i &lt;= startPos && j &lt; fruits.size(); i++) { if (fruits[j][0] == i) curr += fruits[j++][1]; } if (j == fruits.size()) return curr; int res = curr; int left = startPos - k; for (int i = 1; i &lt;= k && j &lt; fruits.size(); i++) { int right = startPos + i; int pos = startPos - max(k - 2*i, (k - i)/2); if (fruits[j][0] == right) curr += fruits[j++][1]; while (left &lt; pos) { if (fruits[u][0] == left++) curr -= fruits[u++][1]; } res = max(res, curr); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-02 03:00:00 +0800 +0800'>November 2, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2106. Maximum Fruits Harvested After at Most K Steps" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2106/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2555. Maximize Win From Two Segments</h2></header><div class=entry-content><p>這一題困難的部分在於計算 windows size 我的作法是根據 startPos + i 來計算左指針，左指針位置會在 startPos - max(k - 2*i, (k - i) / 2)，也就是算出左邊來回或是右邊來回兩種情況下， windowSize 最大的可能。 class Solution { public: int maxTotalFruits(vector&lt;vector&lt;int>>& fruits, int startPos, int k) { sort(fruits.begin(), fruits.end()); int curr = 0; int j = 0; while (j &lt; fruits.size() && fruits[j][0] &lt; startPos - k) j++; int u = j; for (int i = startPos - k; i &lt;= startPos && j &lt; fruits.size(); i++) { if (fruits[j][0] == i) curr += fruits[j++][1]; } if (j == fruits.size()) return curr; int res = curr; int left = startPos - k; for (int i = 1; i &lt;= k && j &lt; fruits.size(); i++) { int right = startPos + i; int pos = startPos - max(k - 2*i, (k - i)/2); if (fruits[j][0] == right) curr += fruits[j++][1]; while (left &lt; pos) { if (fruits[u][0] == left++) curr -= fruits[u++][1]; } res = max(res, curr); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-02 03:00:00 +0800 +0800'>November 2, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2555. Maximize Win From Two Segments" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2555/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2271. Maximum White Tiles Covered by a Carpet</h2></header><div class=entry-content><p>這一題困難的部分在於計算 windows size 我的作法是根據 startPos + i 來計算左指針，左指針位置會在 startPos - max(k - 2*i, (k - i) / 2)，也就是算出左邊來回或是右邊來回兩種情況下， windowSize 最大的可能。 class Solution { public: int maxTotalFruits(vector&lt;vector&lt;int>>& fruits, int startPos, int k) { sort(fruits.begin(), fruits.end()); int curr = 0; int j = 0; while (j &lt; fruits.size() && fruits[j][0] &lt; startPos - k) j++; int u = j; for (int i = startPos - k; i &lt;= startPos && j &lt; fruits.size(); i++) { if (fruits[j][0] == i) curr += fruits[j++][1]; } if (j == fruits.size()) return curr; int res = curr; int left = startPos - k; for (int i = 1; i &lt;= k && j &lt; fruits.size(); i++) { int right = startPos + i; int pos = startPos - max(k - 2*i, (k - i)/2); if (fruits[j][0] == right) curr += fruits[j++][1]; while (left &lt; pos) { if (fruits[u][0] == left++) curr -= fruits[u++][1]; } res = max(res, curr); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-02 02:00:00 +0800 +0800'>November 2, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2271. Maximum White Tiles Covered by a Carpet" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2271/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2831. Find the Longest Equal Subarray</h2></header><div class=entry-content><p>這一題是求 maxcnt 而不是求 window size condition 是 window_size - maxcnt > k 接著套不定長 sliding window。 class Solution { public: int longestEqualSubarray(vector&lt;int>& nums, int k) { int res = 0, left = 0, right = 0, n = nums.size(); int maxcnt = 0; unordered_map&lt;int,int> cnt; while (right &lt; n) { int num = nums[right++]; maxcnt = max(maxcnt, ++cnt[num]); while (right-left-maxcnt > k) cnt[nums[left++]]--; res = max(res, maxcnt); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-02 01:00:00 +0800 +0800'>November 2, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2831. Find the Longest Equal Subarray" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2831/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2516. Take K of Each Character From Left and Right</h2></header><div class=entry-content><p>這題同樣是經典的 sliding window，可參考 1658，同樣是頭尾求最短轉換成求最長 window 的題型。 接著套不定長 sliding window。 class Solution { public: int takeCharacters(string s, int k) { // 先檢驗題目本身有沒有可能符合，因為 s 至少要 3 * k 才可能有解 int need = k * 3; int n = s.size(); if (n &lt; need) return -1; int cnt[3]; memset(cnt, 0, sizeof(cnt)); for (const auto& c : s) { cnt[c-'a']++; } // 檢查各字元是否至少有 k 個 for (int i = 0; i &lt; 3; i++) { if (cnt[i] &lt; k) return -1; cnt[i] -= k; } // 如果都符合，字串長度又剛好等於 need，那必定是整個 string 都需要 if (n == need) return n; // 剩下的就是經典的 sliding window，滑起來就是了 int left = 0, right = 0, res = 0; int curr[3]; memset(curr, 0, sizeof(curr)); while (right &lt; n) { char c = s[right++]; curr[c-'a']++; while (curr[c-'a'] > cnt[c-'a']) { curr[s[left++]-'a']--; } res = max(res, right-left); } // 注意要還原 return n - res; } };</p></div><footer class=entry-footer><span title='2022-11-02 00:00:00 +0800 +0800'>November 2, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2516. Take K of Each Character From Left and Right" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2516/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1658. Minimum Operations to Reduce X to Zero</h2></header><div class=entry-content><p>這一是經典的頭尾相連問題，可以透過透過以下手法換轉成簡單的 sliding window find head + tail = x let head + body + tail == total the problem becomes FIND body = total - x，問題從求最短頭+尾 變成 最長 window 套不定長 sliding window。 class Solution { public: int minOperations(vector&lt;int>& nums, int x) { int total = accumulate(nums.begin(), nums.end(), 0); int target = total - x; int left = 0, right = 0, res = -1, n = nums.size(); int curr = 0; if (target == 0) res = 0; // 注意要處理 boundary condition while (right &lt; n) { curr += nums[right++]; while (curr > target && left &lt; right) { curr -= nums[left++]; } if (curr == target) { res = max(res, right-left); } } return res == -1 ? -1 : n - res; // 最後要將長度轉回來 } };</p></div><footer class=entry-footer><span title='2022-11-01 23:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1658. Minimum Operations to Reduce X to Zero" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1658/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1838. Frequency of the Most Frequent Element</h2></header><div class=entry-content><p>這題同樣是經典的 sliding window，經排序過後，我們可以透過 len * max_element_in_window - accumulate_in_window 的方式來求 token need， 接著套不定長 sliding window。 class Solution { public: int maxFrequency(vector&lt;int>& nums, int k) { sort(nums.begin(), nums.end()); int left = 0, right = 0, res = 0, n = nums.size(); long long curr = 0; while (right &lt; n) { int num = nums[right++]; curr += num; while ((long long)(right-left) * num - curr > k) { curr -= nums[left++]; } res = max(res, right-left); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 23:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1838. Frequency of the Most Frequent Element" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1838/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 1004. Max Consecutive Ones III</h2></header><div class=entry-content><p>簡單的不定長 sliding window 問題。 class Solution { public: int longestOnes(vector&lt;int>& nums, int k) { int res = 0, left = 0, right = 0, n = nums.size(); int curr = 0; int cnt = 0; while (right &lt; n) { int num = nums[right++]; while (cnt == k && num == 0) { if (nums[left++] == 0) cnt--; } if (num == 0) cnt++; res = max(res, right-left); } return res; } };</p></div><footer class=entry-footer><span title='2022-11-01 22:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 1004. Max Consecutive Ones III" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/1004/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[LeetCode] 2024. Maximize the Confusion of an Exam</h2></header><div class=entry-content><p>簡單的不定長 sliding window 問題, 正反各做一遍即可。 class Solution { private: int maxConsecutiveAnswersWith(string keys, int k, char c) { int left = 0, right = 0, res = 0, n = keys.size(); int cnt = 0; while (right &lt; n) { char key = keys[right++]; while (key == c && cnt == k) { if (keys[left++] == c) { cnt--; } } if (key == c) cnt++; res = max(res, right-left); } return res; } public: int maxConsecutiveAnswers(string answerKey, int k) { return max(maxConsecutiveAnswersWith(answerKey, k, 'T'), maxConsecutiveAnswersWith(answerKey, k, 'F')); } };</p></div><footer class=entry-footer><span title='2022-11-01 21:00:00 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [LeetCode] 2024. Maximize the Confusion of an Exam" href=https://intervalrain.github.io/leetcode_list/sliding_window_dblptr/2024/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/categories/leetcode/page/9/>«&nbsp;上一頁&nbsp;
</a><a class=next href=https://intervalrain.github.io/categories/leetcode/page/11/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>