<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming | Rain Hu's Workspace</title><meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/categories/programming/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/categories/programming/index.xml><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/categories/programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/categories/programming/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="Programming"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Programming"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/categories/>Categories</a></div><h1>Programming</h1></header><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>EdgeSync ServiceFramework AspNetCore.Mvc</h2></header><div class=entry-content><p>EdgeSync ServiceFramework AspNetCore.Mvc 概覽 EdgeSync ServiceFramework AspNetCore.Mvc 提供了一個強大的框架，用於在 ASP.NET Core 應用程式中自動化 NATS 通訊模式的配置。框架支援兩種主要的通訊模式：Request/Response 和 Pub/Sub，並可搭配 NATS JetStream 或 Classic NATS 使用。
核心架構 1. 自動模式決策機制 框架使用 ConventionDecisionMaker 根據決策樹自動選擇最適合的通訊模式：
flowchart TD A["方法是否有返回值"] --> B["有"] A --> C["無"] B --> B1["檢查 JetStreamPullAttribute"] B1 --> B2["有 → 錯誤"] B1 --> B3["無 → Request/Response"] C --> E["參數是否為 Collection"] E --> F["是 → Pub/Sub Push"] E --> G["否"] G --> H["檢查 JetStreamPullAttribute"] H --> I["有 → Pub/Sub Pull"] H --> J["無 → Pub/Sub Push"] 2. 支援的通訊模式 模式 說明 使用場景 RequestResponse 請求-回應模式 API 呼叫、資料查詢 PubSubPushJetStream JetStream Push 模式 事件發布、廣播通知 PubSubPullJetStream JetStream Pull 模式 工作佇列、批次處理 PubSubPushClassic Classic NATS Push 輕量級事件通知 Request/Response 實作 基本概念 Request/Response 模式適用於需要同步回應的場景，如 API 呼叫、資料查詢等。
...</p></div><footer class=entry-footer><span title='2025-07-07 16:55:57 +0800 +0800'>July 7, 2025</span>&nbsp;·&nbsp;7 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to EdgeSync ServiceFramework AspNetCore.Mvc" href=https://intervalrain.github.io/nats/auto-convention/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Devcontainer</h2></header><div class=entry-content><p>安裝工具 sudo apt-get update && sudo apt-get install -y iputils-ping telnet</p></div><footer class=entry-footer><span title='2025-04-10 13:26:59 +0800 +0800'>April 10, 2025</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to Devcontainer" href=https://intervalrain.github.io/cs/devcontainer/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[C#] 打包 nuget</h2></header><div class=entry-content><p>NuGet 打包與引用指南 概述 本文檔詳細說明了如何創建 NuGet 包並將其添加到專案中的步驟流程。NuGet 是 .NET 生態系統中的包管理器，可以簡化函式庫的分發和引用過程。
打包 .NET 專案為 NuGet 包 生成 NuGet 包 (.nupkg) 要將您的 .NET 專案打包成 NuGet 包，請在專案根目錄中執行以下命令：
dotnet pack -c Release 這個命令會編譯專案並創建發佈配置的 NuGet 包。生成的 .nupkg 檔案通常位於 bin/Release 目錄中。
參數說明：
-c Release：以 Release 配置模式進行打包，這會優化程式碼並移除除錯資訊 查找生成的 NuGet 包 打包完成後，可以使用以下命令查找所有生成的 .nupkg 檔案：
ls **/*.nupkg 這個命令會遞迴地搜索當前目錄及其子目錄中的所有 .nupkg 檔案並列出它們。
使用本地 NuGet 包 複製 NuGet 包到本地倉庫 要將生成的 NuGet 包複製到本地 NuGet 倉庫中，可以使用以下命令：
cp **/*.nupkg /Users/rainhu/advantech/mynuget/ 這會將所有找到的 .nupkg 檔案複製到指定的本地目錄 /Users/rainhu/advantech/mynuget/。
配置本地 NuGet 來源 要使用本地 NuGet 包，您需要將本地目錄添加為 NuGet 來源。在您的專案中，可以通過以下方式配置：
...</p></div><footer class=entry-footer><span title='2025-04-08 16:17:30 +0800 +0800'>April 8, 2025</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C#] 打包 nuget" href=https://intervalrain.github.io/cs/nuget/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>基於 Ollama 和 LangChain 的 Naive RAG 實作(搭配 streamlit UI)</h2></header><div class=entry-content><p>在此為確保程式碼的可執行性，使用了免費的模型，若要求性能，可以使用替代方案。
完整程式碼
Basic Moves 1. 載入文件 loader = WebBaseLoader(urls_list) documents = loader.load() 使用 WebBaseLoader 從給定的 URL 列表中載入文件。在這裡可以根據需求替換其它 Loader。 PyPDFLoader 用於 PDF 文件。 TextLoader 用於純文本文件。 2. 分割文件 pythonCopytext_splitter = CharacterTextSplitter.from_tiktoken_encoder(chunk_size=7500, chunk_overlap=100) doc_splits = text_splitter.split_documents(documents) 文件分割是一個關鍵步驟。這裡使用 CharacterTextSplitter 並基於 tiktoken 編碼器進行分割。 參數說明: chunk_size: 定義每個 chunk 的最大 token 數。較大的 chunk 可能包含更多上下文，但可能降低檢索精度。 chunk_overlap: 定義相鄰塊之間的重疊 token 數。增加重疊可以幫助保持上下文連續性，但會增加記憶體需求。 替代方案: RecursiveCharacterTextSplitter: 可以更智能地處理文檔結構。 TokenTextSplitter: 直接基於標記進行分割，可能更準確但速度較慢。 3. 選擇 embedding 模型 pythonCopyembeddings = OllamaEmbeddings(model="mistral") 這裡使用 Ollama 的 Mistral 模型生成嵌入。 替代方案: OpenAI HuggingFace Gemini 4. 創建向量資料庫 pythonCopyvector_store = Chroma.from_documents( documents = doc_splits, embedding = embeddings, collection_name = "rag-chroma", ) 替代方案: FAISS (Meta 的) Milvus Pinecone 5. 建立 Retriever Interface retriever = vector_store.as_retriever() 可以通過設置參數 search_type 與 search_kwargs 來調整檢索行為。 6. 執行 RAG rag_chain = ( {"context": retriever, "question": RunnablePassthrough()} | prompt | llm | StrOutputParser() ) 定義 RAG 鏈。可以通過修改 prompt 或使用不同的 LLM 來優化性能。 7. 查詢 return rag_chain.invoke(question) 調用 RAG 鏈針對輸入的問題返回答案。 Advanced Moves 加入 metadata 並進行篩選: loader = WebBaseLoader(urls_list) loader.requests_kwargs = {'verify':False} docs = loader.load() docs = [Document(page_content=doc.page_content, metadata={"source": doc.metadata['source']}) for doc in docs] # 在檢索時使用 metadata 篩選 retriever = vector_store.as_retriever(search_kwargs={"filter": {"source": "特定URL"}}) 加入 pre/post retrieval 處理: from langchain.retrievers import ContextualCompressionRetriever from langchain.retrievers.document_compressors import LLMChainExtractor compressor = LLMChainExtractor.from_llm(llm) compression_retriever = ContextualCompressionRetriever( base_compressor=compressor, base_retriever=retriever ) 加入 rerank 提升回答的加權: from langchain.retrievers import EnsembleRetriever bm25_retriever = BM25Retriever.from_documents(documents) ensemble_retriever = EnsembleRetriever( retrievers=[retriever, bm25_retriever], weights=[0.5, 0.5] ) 改變 naive RAG 為 graph RAG: from langchain.graphs import NetworkxEntityGraph from langchain.indexes import GraphIndexCreator graph_creator = GraphIndexCreator( graph_type=NetworkxEntityGraph, include_embeddings=True ) graph = graph_creator.from_documents(documents) # 使用 graph RAG retrieved_nodes = graph.get_relevant_nodes(query)</p></div><footer class=entry-footer><span title='2024-07-30 23:55:29 +0800 +0800'>July 30, 2024</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to 基於 Ollama 和 LangChain 的 Naive RAG 實作(搭配 streamlit UI)" href=https://intervalrain.github.io/genai/naiverag/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Swift] UI Challenge</h2></header><div class=entry-content><p>Challenge 1: Card Style struct ContentView: View { var body: some View { ZStack { Color(.systemMint) .ignoresSafeArea() VStack(alignment: .leading, spacing: 20.0){ Image("eva") .resizable() .aspectRatio(contentMode: .fit) .cornerRadius(15) .padding(.all) HStack { Text("Eva Hsu") .font(.largeTitle) .fontWeight(.semibold) .foregroundColor(.black) .padding() Spacer() VStack { HStack { Image(systemName: "star.fill") Image(systemName: "star.fill") Image(systemName: "star.fill") Image(systemName: "star.fill") Image(systemName: "star.leadinghalf.fill") } .foregroundColor(.orange) .font(.caption) Text("(Reviews 240,152)") } .padding() } Text("The best girl in the world.") .foregroundColor(.primary) .padding(.horizontal) HStack { Spacer() Image(systemName: "binoculars.fill") Image(systemName: "fork.knife") } .foregroundColor(.gray) .font(.caption) .padding() } .background(Rectangle() .foregroundColor(.white) .cornerRadius(15) .shadow(radius: 15)) .padding() } } }m</p></div><footer class=entry-footer><span title='2024-06-21 01:19:02 +0800 +0800'>June 21, 2024</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Swift] UI Challenge" href=https://intervalrain.github.io/swift/ui_challenge/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[System Design] 系統設計概念與資源 System Design and Resources</h2></header><div class=entry-content><p>系統設計的核心概念 System Design Key Concepts 可擴展性(Scalability) 延遲與吞吐量(Latency vs Throughput) CAP 定理(CAP Theory) ACID 交易(ACID Transactions)</p></div><footer class=entry-footer><span title='2024-03-26 22:35:38 +0800 +0800'>March 26, 2024</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Ashish Pratap Singh, Rain Hu</footer><a class=entry-link aria-label="post link to [System Design] 系統設計概念與資源 System Design and Resources" href=https://intervalrain.github.io/systemdesign/system_design_menu/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[Hugo] 使用 Hugo-notice</h2></header><div class=entry-content><p>Shortcodes 介紹 Shortcodes 是內容檔案中的一個簡單片段，Hugo將使用預先定義的範本對其進行呈現。 除了更乾淨的 Markdown 外，Shortcodes 還可以隨時更新新的技術或標準。 Notice shortcodes 將以下程式碼加入到 Hugo 專案底下的 layouts/shortcodes/notice.html {{/* Available notice types: warning, info, note, tip */}} {{- $noticeType := .Get 0 | default "note" -}} {{/* Workaround markdownify inconsistency for single/multiple paragraphs */}} {{- $raw := (markdownify .Inner | chomp) -}} {{- $block := findRE "(?is)^&lt;(?:address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h(?:1|2|3|4|5|6)|header|hgroup|hr|li|main|nav|noscript|ol|output|p|pre|section|table|tfoot|ul|video)\\b" $raw 1 -}} {{/* Count how many times we've called this shortcode and load the css if it's the first time */}} {{- if not ($.Page.Scratch.Get "noticecount") -}} &lt;style type="text/css">.notice{--root-color:#444;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#c33;--warning-content:#fee;--info-title:#fb7;--info-content:#fec;--note-title:#6be;--note-content:#e7f2fa;--tip-title:#5a5;--tip-content:#efe}@media (prefers-color-scheme:dark){.notice{--root-color:#ddd;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#800;--warning-content:#400;--info-title:#a50;--info-content:#420;--note-title:#069;--note-content:#023;--tip-title:#363;--tip-content:#121}}body.dark .notice{--root-color:#ddd;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#800;--warning-content:#400;--info-title:#a50;--info-content:#420;--note-title:#069;--note-content:#023;--tip-title:#363;--tip-content:#121}.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:var(--root-color);background:var(--root-background)}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:var(--title-color);background:var(--title-background)}.notice.warning .notice-title{background:var(--warning-title)}.notice.warning{background:var(--warning-content)}.notice.info .notice-title{background:var(--info-title)}.notice.info{background:var(--info-content)}.notice.note .notice-title{background:var(--note-title)}.notice.note{background:var(--note-content)}.notice.tip .notice-title{background:var(--tip-title)}.notice.tip{background:var(--tip-content)}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:.125em;position:relative}&lt;/style> &lt;div>&lt;svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg">&lt;symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet">&lt;path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/>&lt;/symbol>&lt;symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet">&lt;path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/>&lt;/symbol>&lt;symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet">&lt;path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/>&lt;/symbol>&lt;symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet">&lt;path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/>&lt;/symbol>&lt;/svg>&lt;/div> {{- end -}} {{- $.Page.Scratch.Add "noticecount" 1 -}} &lt;div class="notice {{ $noticeType }}" {{ if len .Params | eq 2 }} id="{{ .Get 1 }}" {{ end }}> &lt;p class="first notice-title">&lt;span class="icon-notice baseline">&lt;svg>&lt;use href="#{{- $noticeType -}}-notice">&lt;/use>&lt;/svg>&lt;/span>{{- i18n $noticeType -}}&lt;/p> {{- if or $block (not $raw) }}{{ $raw }}{{ else }}&lt;p>{{ $raw }}&lt;/p>{{ end -}} &lt;/div> Classes 警告 {{&lt; notice warning >}} 這是警告(warning) {{&lt; /notice >}} ...</p></div><footer class=entry-footer><span title='2024-01-19 01:26:30 +0800 +0800'>January 19, 2024</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Hugo] 使用 Hugo-notice" href=https://intervalrain.github.io/hugo/notice/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[ML] 機器學習與統計學</h2></header><div class=entry-content><p>Introduction to ML 統計學與機器學習差在哪裡? 同: 將資料(data)轉為資訊(info)
異: 有無強烈的人為事先假設
統計學
統計學是在資料分析的基礎上，研究如何測定、收集、整理、歸納和分析反映資料，以便給出正確訊息的科學。 機器學習
機器學習演算法是一類從資料中自動分析獲得規律，並利用規律對未知資料進行預測的演算法。 \(\begin{array}{lll} \text{Item} & \text{Statistics} & \text{Machine Learning}\\\hline \text{特性} & \text{伴隨事前假設，依賴明確規則，以模型定義資料關聯性，重視模型解釋性} & \text{幾乎無視前假設，不依賴明確規則，相信經驗}\\ & \text{事前假設(人)}\rightarrow\text{模型估計(機器)} & \text{特徵萃取(機器)}\rightarrow\text{網路建構(機器)} \\\hline \text{優點} & \text{模型可解釋} & \text{不須事先假設或了解資料關聯性}\\ & \text{推論有強烈理論根據} & \text{可抓取資料的所有(幾乎)複雜特徵}\\ & \text{符合事前假設前提下，可做更多的推論}\\ & \text{符合事前假設前提下，不需大量資料} \\\hline \text{缺點} & \text{所有推論接基於事前假設，常難以驗證假設的正確性} & \text{模型難以解釋(黑盒子)}\\ & \text{難以抓取資料中過於複雜的特徵} & \text{推論無強烈理論根據} \\\hline \text{專家} & \text{統計背景} & \text{資訊背景及統計背景} \\\hline \end{array}\) 結論 統計模型的重點是有合理的事前假設 在有合理假設之情況下，統計模型能發揮效力(即使資料量少) 機器學習的重點是大量有代表性的資料 在有大量有效資料之情況下，機器學習能發揮效力(即使人類對資料間的關聯之了解並不多) 何時使用統計方法? 何時使用機器學習? 資料關聯性清楚，容易給予合適的模型假設時，建議使用統計模型 資料無明確規則(如影像及語音辨識)，且資料量夠多時，建議使用機器學習方法(可以佐以人為提示) 統計與機器學習類似的專有名詞 \(\begin{array}{ll} \text{Statistics} & \text{Machine Learning} \text{response, dependent variable} & \text{label} \\\hline \text{covariate, explanatory variable, independent variable} & \text{feature} \\\hline \text{model} & \text{network} \\\hline \text{parameter, coefficient} & \text{weight} \\\hline \text{fitting} & \text{learning} \\\hline \text{refression, classification} & \text{supervised learning} \\\hline \text{density estimation, cluster} & \text{unsupervised learning} \\\hline \end{array}\)
...</p></div><footer class=entry-footer><span title='2022-11-07 18:18:52 +0800 +0800'>November 7, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [ML] 機器學習與統計學" href=https://intervalrain.github.io/ml/lec1/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] Segment Tree</h2></header><div class=entry-content><p>線段樹 Segment Tree 簡介 線段樹是演算法中常用來維護區間訊息的資料結構。 空間複雜度為 \(O(n)\)，\(n\) 代表區間數。 查詢的時間複雜度為 \(O(\log n+k)\)，\(k\) 代表符合條件的區間數量。 線段樹將每個長度為為 1 的區間劃分為左右兩個區間遞迴求解，把整個線段劃分為一個樹型結構，通過合併左右兩個區間訊息來求得該區間的訊息。 在實現時，我們考慮遞迴建樹，設當前的根節點為 root，如果根節點管轄的區間長度已經是 1，則可以直接根據數組上相應位置的值初始化該節點。否則需將該區間從中點處分割為兩個子區間，分別進入左右子節點遞迴建樹，最後合併兩個子節點的訊息， 建樹 build void build(int s, int t, int p, const vector&lt;int>& arr){ if (s == t){ tree[p] = SegmentItem(arr[s], 1); return; } int m = s + ((t - s) >> 1); build(s, m, p*2, arr); build(m+1, t, p*2+1, arr); // push_up tree[p] = tree[p*2] + tree[(p*2)+1]; } 查詢 query SegmentItem find(int l, int r, int s, int t, int p){ if (l &lt;= s && t &lt;= r){ return tree[p]; } int m = s + ((t - s) >> 1); SegmentItem sum; if (r &lt;= m) return find(l, r, s, m, p*2); if (l > m) return find(l, r, m+1, t, p*2+1); return find(l, r, s, m, p*2) + find(l, r, m+1, t, p*2+1); } zkw 線段樹 來自清華大學張昆瑋(zkw)-《統計的力量》 以非遞迴的方式構建，效率更高，程式更短。 普通的線段樹是從上到下做處理，容易定位根節點，卻不容易定位子節點。 zkw 線段樹是當二叉樹是滿二叉樹時，因為子節點的編號具有以下規律： 葉子節點(left) 全部退化為線段 \([x,x]\) 。 \(n\) 個數據點則取大於等 \(n\)且為 \(2\) 的冪次的兩倍作為數組大小。 \((m=2^a\ge n)\) for (int m = 1; m &lt;= n; m >>= 1) 維護點為 \(n\) 個。索引為\([m,m+n)\)。 子葉數目為 \(m\) 個。索引為\([m,2m)\) 節點數為 \(2m-1\) 個。(數組大小需設 \(2m\) 因為 zkw tree是 1-index的) 樹高 \(H=\log_2(m)+1\) 層。 第 \(h\) 層有 \(2^{h-1}\) 個節點， 該層線段長度為 \(2^{H-h}\)。 若某節點為 \(p\)，父節點為 \(p/2\)，子節點為 \(2p\) 和 \(2p+1\) int parent = p >> 1; int left = p &lt;&lt; 1; int right = p &lt;&lt; 1 | 1; 若兩節點為 \(p\) 與 \(q\)，且兩節點互為兄弟節點，則 \(p\oplus q=1\) if (left ^ right) // left 與 right 為兄弟節點 else // left 與 right 不為兄弟節點 除根節點外，左節點皆為偶數，右節點皆為奇數 if (i == 1) // i 為根節點 else if (i & 1) // i 為奇數，為右節點 else if (!(i & 1)) // i 為偶數，為左節點 結構 線段樹索引堆疊： 轉成二進制： 規律： 一個節點的父節點是該數右移 1，低位捨棄。 一個節點的左子節點是該數左移 1，右子節點是該數左移 1 再加 1。 同一層的節點是依次遞增的，第 \(n\) 層有 \(2^{n-1}\)個節點 最後一層有多少個節點，值域就是多少。 建樹 build 取 m 值有許多版本，有些版本會直接取 \(m=2^{log_2(n+5)+1}\)以節省迭代計算 寫成 int n = 1 &lt;&lt; __lg(n+5)+1; 可以有開區間與閉區間兩種做法，差別在於從子葉節點的最左邊 \(m+i\) 開始，或是第二個子葉節點 \(m+1+i\) 開始。 由下而上更新時，開區間與閉區間的終止條件不同： 開區間的終止條件為兩子節點互為兄弟節點 while (i^j^1) // operation 閉區間的終止條件為右節點小於左節點 while (i &lt;= j) // operation class Tree { private: vector&lt;int> arr; int n, m; // n 為維護點數, m 為 zkw-tree 子葉節點數 public: Tree (vector&lt;int>& nums){ n = nums.size(); for (m = 1; m &lt;= n; m &lt;&lt;= 1); // 取大於等於 n 且為 2 的冪次的最小整數 arr.assign(2*m, 0); // 節點數設為 2m 個，其中 0 為空節點 } void build(vector&lt;int> nums){ for (int i = 0; i &lt; n; i++) { arr[i+m] = nums[i]; // 從子葉節點最左邊往右更新節點。 mx[i+m] = nums[i]; mn[i+m] = nums[i]; } for (int i = m-1; i; i--){ // 向上更新父節點。 arr[i] = in(x); } } }; 根據不同需求代換 \(\text{in(x)}\)：取和、最大值、最小平 // 取和 arr[i] = arr[i&lt;&lt;1] + arr[i&lt;&lt;1|1]; // 取最大值 arr[i] = max(arr[i&lt;&lt;1], arr[i&lt;&lt;1|1]); // 取最小值 arr[i] = min(arr[i&lt;&lt;1], arr[i&lt;&lt;1|1]); 更新 update 單點修改(以和為例) 更新時，以差分方式，將所有父節點加上更新點的差值。 void update(int i, int val){ int diff = val - arr[m+i] // 原值 arr[m+i] 與新值 val 的差 for (i += m; i; i >>= 1){ arr[i] += diff; } } 查詢 query 單點查詢(以和為例)：閉區間做法 判斷左邊界是否為右節點，若為右節點則加上後往右邊的父節點移動。 判斷右邊界是否為左節點，若為左節點則加上後往左邊的父節點移動。 int query(int left, int right){ int sum = 0; int i = left+m; // 左閉區間 int j = right+m; // 右閉區間 for (; i &lt;= j; i >>= 1, j >>= 1){ if (i & 1) sum += arr[i++]; if (!(j & 1)) sum += arr[j--]; } return sum; } 備註：開區間作法 (0-index 時會出現 -1 的情形，建議使用閉區間) int query(int left, int right){ int sum = 0; int i = left+m-1; int j = right+m+1; for(; i^j^1; i >>= 1, j >>= 1){ if (~i & 1) sum += arr[i^1]; if (j & 1) sum += arr[j^1]; } return sum; } 區間修改 在非遞迴的情況下，標記下傳是比較困難的，所以作法上改成將標記永久化。 具體而言，與查詢類似，當左端點是左子節點且右端點是右子節點時，我們對它的兄弟節點進行修改並標記，表示這顆子樹中的每個節點都要被修改。但單純這樣還不夠，因上述修改還會波及到這些節點的各級祖先，所以我們需要在途中根據實際修改的區間長度來更新各級祖先的值，這種操作需要一路上推到根節點。 (開區間作法) void update(int left, int right, int diff){ int len = 1, cntl = 0, cntr = 0; // cntl, cntr 是左右邊分別實際修改的區間長度 left += m-1; right += m+1; for (; left^right^1; left >> 1, right >> 1, len &lt;&lt; 1){ arr[left] += cntl * diff; arr[right] += cntr * diff; if (~left & 1) { arr[left^1] += diff * len; mark[left^1] += diff; cntl += len; } if (right & 1) { arr[right^1] += diff * len; mark[right^1] += diff; cntr += len; } } for (; left; left >>= 1, right >>= 1){ arr[left] += cntl * diff; arr[right] += cntr * diff; } } 在有區間修改存在時，區間查詢也需要考慮標記的影響。 所以除了加上端點的兄弟節點訊息，沿途中遇到的標記也對答案有貢獻，同樣需要上推到根節點。 int query(int left, int right){ int sum = 0, len = 1, cntl = 0, cntr = 0; left += m - 1; right += m + 1; for (; left^right^1; left >>= 1, right >>= 1, len &lt;&lt; 1){ sum += cntl * mark[left] + cntr * mark[right]; if (~left & 1) sum += arr[left^1], cntl += len; if (right & 1) sum += arr[right^1], cntr += len; } for (; left; left >> 1, right >> 1){ sum += cntl * mark[left] + cntr * mark[right]; } return sum; } 區間查詢最大值： void update(int l, int r, int d) { for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1) { if (l &lt; N) tree[l] = max(tree[l &lt;&lt; 1], tree[l &lt;&lt; 1 | 1]) + mark[l], tree[r] = max(tree[r &lt;&lt; 1], tree[r &lt;&lt; 1 | 1]) + mark[r]; if (~l & 1) tree[l ^ 1] += d, mark[l ^ 1] += d; if (r & 1) tree[r ^ 1] += d, mark[r ^ 1] += d; } for (; l; l >>= 1, r >>= 1) if (l &lt; N) tree[l] = max(tree[l &lt;&lt; 1], tree[l &lt;&lt; 1 | 1]) + mark[l], tree[r] = max(tree[r &lt;&lt; 1], tree[r &lt;&lt; 1 | 1]) + mark[r]; }; int query(int l, int r) { int maxl = -INF, maxr = -INF; for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1) { maxl += mark[l], maxr += mark[r]; if (~l & 1) cmax(maxl, tree[l ^ 1]); if (r & 1) cmax(maxr, tree[r ^ 1]); } for (; l; l >>= 1, r >>= 1) maxl += mark[l], maxr += mark[r]; return max(maxl, maxr); }; Leetcode. 307 範例 https://leetcode.com/problems/range-sum-query-mutable/ TreeNode 變形 class NumArray { class SegTree { public: int val; int begin, end; SegTree* left, *right; SegTree(int v):val(v) {} SegTree(int v, int b, int e):val(v), begin(b), end(e) {} SegTree(int v, int b, int e, SegTree* l, SegTree* r) :val(v), begin(b), end(e), left(l), right(r) {} }; SegTree* root; SegTree* build(vector&lt;int>& nums, int b, int e){ if (e &lt; b) return NULL; if (b == e) return new SegTree(nums[b], b, b); int mid = b + (e-b)/2; SegTree* left = build(nums, b, mid); SegTree* right = build(nums, mid+1, e); return new SegTree(left->val + right->val, b, e, left, right); } void update(SegTree* node, int index, int val){ if (node->begin == index && node->end == index){ node->val = val; } else { int mid = node->begin + (node->end - node->begin)/2; if (index &lt;= mid){ update(node->left, index, val); } else { update(node->right, index, val); } node->val = node->left->val + node->right->val; } } int query(SegTree* node, int left, int right){ if (node->begin == left && node->end == right){ return node->val; } int mid = node->begin + (node->end - node->begin)/2; if (right &lt;= mid){ return query(node->left, left, right); } else if (left > mid){ return query(node->right, left, right); } return query(node->left, left, mid) + query(node->right, mid+1, right); } public: NumArray(vector&lt;int>& nums) { root = build(nums, 0, nums.size()-1); } void update(int index, int val) { update(root, index, val); } int sumRange(int left, int right) { return query(root, left, right); } }; zkw 線段樹 class NumArray { class SegTree { vector&lt;int> arr; int m, n; public: SegTree(vector&lt;int>& nums) { n = nums.size(); for (m = 1; m &lt; n; m &lt;&lt;= 1); build(nums); } void build(vector&lt;int>& nums) { arr.assign(2*m, 0); for (int i = 0; i &lt; n; ++i) arr[m+i] = nums[i]; for (int i = m-1; i; --i) arr[i] = arr[i&lt;&lt;1] + arr[i&lt;&lt;1|1]; } void update(int index, int val) { int diff = val - arr[m+index]; for (index += m; index; index >>= 1) arr[index] += diff; } int query(int left, int right) { int sum = 0; for (int i = left+m, j = right+m; i &lt;= j; i >>= 1, j >>= 1){ if (i & 1) sum += arr[i++]; if (!(j & 1)) sum += arr[j--]; } return sum; } }; public: SegTree* root; NumArray(vector&lt;int>& nums) { root = new SegTree(nums); } void update(int index, int val) { root->update(index, val); } int sumRange(int left, int right) { return root->query(left, right); } }; BIT(binary indexed tree) class NumArray { public: class Bit { public: vector&lt;int> bit; int n; Bit(vector&lt;int>& nums) { n = nums.size(); bit.assign(n+1, 0); for (int i = 0; i &lt; n; i++){ build(i+1, nums[i]); } } void build(int index, int val) { while (index &lt;= n){ bit[index] += val; index = next(index); } } int next(int index) { return index + (index & -index); } int parent(int index) { return index - (index & -index); } int getSum(int index) { int sum = 0; while (index){ sum += bit[index]; index = parent(index); } return sum; } }; Bit* bit; NumArray(vector&lt;int>& nums) { bit = new Bit(nums); } void update(int index, int val) { int diff = val - sumRange(index, index); bit->build(index+1, diff); } int sumRange(int left, int right) { return bit->getSum(right+1) - bit->getSum(left); } };</p></div><footer class=entry-footer><span title='2022-10-18 23:14:38 +0800 +0800'>October 18, 2022</span>&nbsp;·&nbsp;8 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] Segment Tree" href=https://intervalrain.github.io/c++/segtree/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2 class=entry-hint-parent>[C++] stringstream 類範例 - split 與 concat</h2></header><div class=entry-content><p>stringstream 需引用 &lt;sstream> , &lt;iostream>, &lt;string>函式庫 配合 str() 將 stringstream 類轉換成 string 類別。 split() vector&lt;string> split(string& str, char del){ stringstream ss(str); string item; vector&lt;string> res; while (getline(ss, item, del)){ if (!item.empty()){ res.push_back(item); } } return res; } concat() string concat(vector&lt;string>& svec, char del){ stringstream ss; for (const auto& s : svec){ ss &lt;&lt; s &lt;&lt; del; } return ss.str(); } [leetcode 1859. Sorting the Sentence] class Solution { public: string sortSentence(string s) { vector&lt;string> tmp = split(s, ' '); int n = tmp.size(); vector&lt;string> svec(n); for (const string& s : tmp){ int pos = s.back() - '1'; svec[pos] = s.substr(0, s.length()-1); } return concat(svec, ' '); } string concat(vector&lt;string>& svec, char del){ string res; stringstream ss; for (const string& s : svec) ss &lt;&lt; del &lt;&lt; s; res = ss.str(); return res.substr(1); } vector&lt;string> split(string& str, char del){ vector&lt;string> res; stringstream ss(str); string item; while (getline(ss, item, del)){ if (!item.empty()){ res.push_back(item); } } return res; } };</p></div><footer class=entry-footer><span title='2022-10-14 00:21:23 +0800 +0800'>October 14, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] stringstream 類範例 - split 與 concat" href=https://intervalrain.github.io/c++/stringstream/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://intervalrain.github.io/categories/programming/page/2/>下一頁&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>