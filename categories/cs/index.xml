<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>CS on Rain Hu's Workspace</title><link>https://intervalrain.github.io/categories/cs/</link><description>Recent content in CS on Rain Hu's Workspace</description><generator>Hugo -- 0.151.0</generator><language>zh-tw</language><lastBuildDate>Sun, 07 May 2023 18:46:56 +0800</lastBuildDate><atom:link href="https://intervalrain.github.io/categories/cs/index.xml" rel="self" type="application/rss+xml"/><item><title>[Algo] 3-2. Binary Search</title><link>https://intervalrain.github.io/cs/algo/binary_search/</link><pubDate>Sun, 07 May 2023 18:46:56 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/binary_search/</guid><description>介紹二元搜索法，並介紹其適用情境</description></item><item><title>[Algo] 3-10. Binary Indexed Tree(Fenwick Tree, BIT)</title><link>https://intervalrain.github.io/cs/algo/bit/</link><pubDate>Sat, 08 Apr 2023 17:46:12 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/bit/</guid><description>利用 Binary Indexed Tree 做數組的動態更新與查詢，中譯為樹狀樹組</description></item><item><title>[Algo] 3-1. Two Pointer/Sliding Window</title><link>https://intervalrain.github.io/cs/algo/two_pointer/</link><pubDate>Sun, 19 Mar 2023 22:56:03 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/two_pointer/</guid><description>使用雙指標或是更進階的滑動窗口的技巧，對資料集合(可能是array，可能是list)做搜尋。</description></item><item><title>[Algo] 3-0. Sorting</title><link>https://intervalrain.github.io/cs/algo/sorting/</link><pubDate>Thu, 16 Mar 2023 19:50:21 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/sorting/</guid><description>從排序開始，練習將想法實踐，All start from sorting</description></item><item><title>[C#] C# 筆記</title><link>https://intervalrain.github.io/csharp/csharp/</link><pubDate>Tue, 28 Feb 2023 18:49:39 +0800</pubDate><guid>https://intervalrain.github.io/csharp/csharp/</guid><description>Notes for C#</description></item><item><title>[Algo] 2-4. 回溯法 Backtracking</title><link>https://intervalrain.github.io/cs/algo/backtracking/</link><pubDate>Fri, 27 Jan 2023 10:50:26 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/backtracking/</guid><description>演算法設計，介紹什麼是回溯法，並示範運用回溯法的思維解題</description></item><item><title>[Algo] 2-2. 貪心演算法 Greedy</title><link>https://intervalrain.github.io/cs/algo/greedy/</link><pubDate>Tue, 24 Jan 2023 18:31:15 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/greedy/</guid><description>演算法設計，介紹什麼是貪心法，貪心法的解題思維</description></item><item><title>[Algo] 2-1. 暴力演算法 Brute Force</title><link>https://intervalrain.github.io/cs/algo/brute_force/</link><pubDate>Tue, 24 Jan 2023 15:57:40 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/brute_force/</guid><description>演算法設計，介紹什麼是暴力演算法，並示範幾種資料結構的遍歷與枚舉</description></item><item><title>[Algo] 1-9. Algorithm</title><link>https://intervalrain.github.io/cs/algo/algorithm/</link><pubDate>Tue, 03 Jan 2023 21:49:42 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/algorithm/</guid><description>C++ 的內建演算法庫使用與範例</description></item><item><title>[Algo] 2-5. 動態規劃 Dynamic Programming</title><link>https://intervalrain.github.io/cs/algo/dp/</link><pubDate>Tue, 15 Nov 2022 16:10:53 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/dp/</guid><description>演算法設計，介紹什麼是動態規劃，並介紹幾種動態規劃常見的題型，與解題框架</description></item><item><title>[Algo] 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis</title><link>https://intervalrain.github.io/cs/algo/bigo/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/bigo/</guid><description>演算法的複雜度分析，與複雜度的表示法</description></item><item><title>[Algo] 0-4. 二叉樹(Binary Tree)</title><link>https://intervalrain.github.io/cs/algo/binary_tree/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/binary_tree/</guid><description>演算法思維，介紹二叉樹這種資料結構以及如何使用它與 Leetcode 相關範例介紹</description></item><item><title>[Algo] 0-3. 鏈表(Linked List)</title><link>https://intervalrain.github.io/cs/algo/linked_list/</link><pubDate>Thu, 06 Oct 2022 22:30:28 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/linked_list/</guid><description>演算法結構介紹，介紹鏈表的遍歷，與常見的經典考題與常用到的操作手法</description></item><item><title>[Algo] 0-2. 算法思維</title><link>https://intervalrain.github.io/cs/algo/concept/</link><pubDate>Thu, 06 Oct 2022 22:15:28 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/concept/</guid><description>演算法的思維，在深入 Leetcode 世界前的一些基礎引導</description></item><item><title>CS 學習筆記</title><link>https://intervalrain.github.io/csindex/</link><pubDate>Thu, 06 Oct 2022 22:01:48 +0800</pubDate><guid>https://intervalrain.github.io/csindex/</guid><description>rainhu的資工學習筆記</description></item><item><title>[DS] 演算法筆記</title><link>https://intervalrain.github.io/cs/algo/</link><pubDate>Thu, 06 Oct 2022 22:00:28 +0800</pubDate><guid>https://intervalrain.github.io/cs/algo/</guid><description>演算法筆記，提供各式各樣的程式設計演算法，並以 leetcode 題目或是實際案例出發，介紹並分析解法。</description></item><item><title>[作業系統] 計算機組織與結構</title><link>https://intervalrain.github.io/cs/ca/</link><pubDate>Sun, 03 Jul 2022 01:39:35 +0800</pubDate><guid>https://intervalrain.github.io/cs/ca/</guid><description>&lt;h1 id="計算機組織與結構"&gt;計算機組織與結構&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/ca/abstraction"&gt;計算機抽象化與科技&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/ca/isa"&gt;指令集架構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/ca/arithmetic"&gt;計算機算術&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/ca/processor"&gt;處理器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/ca/pipeline"&gt;Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/ca/memory"&gt;記憶體&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="參考資料"&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ocw.nthu.edu.tw/ocw/index.php?page=course&amp;amp;cid=76"&gt;黃婷婷 清大開放式課程 計算機結構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mropengate.blogspot.tw/"&gt;Mr. opengate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>[作業系統] 計算機作業系統</title><link>https://intervalrain.github.io/cs/os/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/cs/os/</guid><description>&lt;h1 id="計算機作業系統"&gt;計算機作業系統&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/os/intro"&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/os/processmanagement"&gt;進程管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/os/deadlock"&gt;死鎖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/os/memorymanagement"&gt;記憶體管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/os/equipmentmanagement"&gt;設備管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://intervalrain.github.io/cs/os/link"&gt;鏈接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="參考資料"&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/CyC2018/CS-Notes"&gt;cyc2018&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mropengate.blogspot.tw/"&gt;Mr. opengate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>[計算機作業系統] 死鎖</title><link>https://intervalrain.github.io/cs/os/deadlock/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/cs/os/deadlock/</guid><description>&lt;h1 id="準備中"&gt;準備中&lt;/h1&gt;</description></item><item><title>[計算機作業系統] 記憶體管理</title><link>https://intervalrain.github.io/cs/os/memorymanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/cs/os/memorymanagement/</guid><description>&lt;h1 id="準備中"&gt;準備中&lt;/h1&gt;</description></item><item><title>[計算機作業系統] 設備管理</title><link>https://intervalrain.github.io/cs/os/equipmentmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/cs/os/equipmentmanagement/</guid><description>&lt;h1 id="準備中"&gt;準備中&lt;/h1&gt;</description></item><item><title>[計算機作業系統] 進程管理</title><link>https://intervalrain.github.io/cs/os/processmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/cs/os/processmanagement/</guid><description>&lt;h1 id="進程管理"&gt;進程管理&lt;/h1&gt;
&lt;h2 id="進程與執行緒"&gt;進程與執行緒&lt;/h2&gt;
&lt;h3 id="1-進程process"&gt;1. 進程(process)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;進程是資源分配的基本單位。&lt;/li&gt;
&lt;li&gt;進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。
&lt;img alt="PCB" loading="lazy" src="https://www.usna.edu/Users/cs/bilzor/ic411/calendar.php?key=c8bc3778e1e290e4a99e60360fa8c03a340b21ad&amp;type=class&amp;event=6"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-執行緒thread"&gt;2. 執行緒(thread)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;執行緒又稱線程，是獨立調度的基本單位。&lt;/li&gt;
&lt;li&gt;一個進程可以有多個執行緒，它們共享進程資源。&lt;/li&gt;
&lt;li&gt;以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。
&lt;img alt="thread" loading="lazy" src="https://4.bp.blogspot.com/-QyEW1jszBJM/UnUsSC-mVOI/AAAAAAAAABY/Z94NgDcWTb4/s640/process-thread.png"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-區別"&gt;3. 區別&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;擁有資源
&lt;ul&gt;
&lt;li&gt;進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;調度
&lt;ul&gt;
&lt;li&gt;執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系統開銷
&lt;ul&gt;
&lt;li&gt;由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。&lt;/li&gt;
&lt;li&gt;同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通訊
&lt;ul&gt;
&lt;li&gt;執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="進程狀態的切換"&gt;進程狀態的切換&lt;/h2&gt;
&lt;p&gt;&lt;img alt="process state" loading="lazy" src="https://jingtao.fun/images/%E8%AF%BB%E4%B9%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20201102105129598.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就緒就態(ready)：等待被調度&lt;/li&gt;
&lt;li&gt;執行狀態(running)&lt;/li&gt;
&lt;li&gt;阻塞狀態(waiting)：等待資源
&lt;ul&gt;
&lt;li&gt;只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。&lt;/li&gt;
&lt;li&gt;阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="進程調度演算法"&gt;進程調度演算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="1-批次處理系統batch-system"&gt;1. 批次處理系統(batch system)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="11-先來先服務first-come-first-served-fcfs"&gt;1.1 先來先服務(first-come first-served, FCFS)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;非搶占式的調度，按照請求的順序進行調度。&lt;/li&gt;
&lt;li&gt;有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="12-短作業優先shortest-job-first-sjf"&gt;1.2 短作業優先(shortest job first, SJF)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;非搶占式的調度算法，按估計運行時間最短的順序進行調度。&lt;/li&gt;
&lt;li&gt;長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="13-最短剩餘時間優先shortest-remaining-time-next-srtn"&gt;1.3 最短剩餘時間優先(shortest remaining time next, SRTN)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-交互式系統time-sharing-system"&gt;2. 交互式系統(time-sharing system)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="21-時間片段輪轉robin-round-scheduling-rr"&gt;2.1 時間片段輪轉(robin round scheduling, RR)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。&lt;/li&gt;
&lt;li&gt;時間片段輪轉演算法的效率和時間片段的大小很有關係：
&lt;ul&gt;
&lt;li&gt;因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。&lt;/li&gt;
&lt;li&gt;而如果時間片段過長，那麼實時性就不能得到保証。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="22-優先級調度priority-scheduling"&gt;2.2 優先級調度(priority scheduling)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;為每個進程分配一個優先級，按優先級進行調度。&lt;/li&gt;
&lt;li&gt;為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="23-多級反饋佇列multilevel-feedback-queue-scheduling-mlfq"&gt;2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。&lt;/li&gt;
&lt;li&gt;多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,&amp;hellip;。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。&lt;/li&gt;
&lt;li&gt;每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。
&lt;img alt="MLFQ" loading="lazy" src="https://i.pinimg.com/736x/9e/56/96/9e5696a52f10453be9717470b28a44c7--round-robin-robins.jpg"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-實時系統real-time-system"&gt;3. 實時系統(real time system)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;實時系統要求一個請求在一個確定時間內得到響應。&lt;/li&gt;
&lt;li&gt;分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="進程同步"&gt;進程同步&lt;/h2&gt;
&lt;h3 id="1-臨界區"&gt;1. 臨界區&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;對臨界資源進行訪問的那段代碼稱為臨界區。&lt;/li&gt;
&lt;li&gt;為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// entry section
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// crtical section;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// exit section
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="2-同步與互斥synchronization-and-mutex"&gt;2. 同步與互斥(synchronization and mutex)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同步(synchronization)：多個進程因為合作產生的直接制約關係，使得進程有一定的先後執行關係。&lt;/li&gt;
&lt;li&gt;互斥(mutual exclusion, mutex)：多個進程在同一時刻只有一個進程能進入臨界區。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-號誌semaphore"&gt;3. 號誌(Semaphore)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;號誌，或稱信號量，是一個整數變數，可以對其執行 down 和 up 操作，也就是常見的 P 和 V 操作。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;down&lt;/strong&gt;：如果號誌量大於 0，執行 -1 操作；如果號誌等於 0，進程睡眠，等待號誌大於 0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;up&lt;/strong&gt;：對號誌執行 +1 操作，喚醒睡眠的進程讓其完成 down 操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;down 和 up 操作需要被設計成原語，不可分割，通常的做法是在執行這些操作的時候屏蔽中斷。&lt;br&gt;
如果號誌的取值只能為 0 或者 1，那麼就成為了互斥(mutex)，0 表示臨界區已經加鎖，1 表示臨界區解鎖。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;typedef&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; semaphore;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;semaphore mutex &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;P1&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; down(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;mutex);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// critical section
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; up(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;mutex);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;P2&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; down(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;mutex);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// critical section
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; up(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;mutex);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;使用號誌實現生產者-消費者問題&lt;/strong&gt;
&lt;img alt="producer-consumer-problem" loading="lazy" src="https://th.bing.com/th/id/R.dbbe36e7d63143d6defdab98ece8fff8?rik=J8NwPrcsGHP7jw&amp;pid=ImgRaw&amp;r=0"&gt;&lt;/p&gt;</description></item><item><title>[計算機作業系統] 概述</title><link>https://intervalrain.github.io/cs/os/intro/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/cs/os/intro/</guid><description>&lt;h1 id="作業系統"&gt;作業系統&lt;/h1&gt;
&lt;h2 id="簡介"&gt;簡介&lt;/h2&gt;
&lt;p&gt;&lt;img alt="computer os" loading="lazy" src="https://2.bp.blogspot.com/-gzomOqKpa74/VLPwd72Q8KI/AAAAAAAAk-E/mnLR8NAJfLY/s640/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2014-12-12%2B%E4%B8%8B%E5%8D%882.48.33-17.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;電腦系統主要可分成四個部分，或分成&lt;strong&gt;硬體(hardware)&lt;/strong&gt;、&lt;strong&gt;軟體(software)&lt;/strong&gt;、&lt;strong&gt;數據(data)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬體(hardware)：為系統提供基本的計算資源。
&lt;ol&gt;
&lt;li&gt;中央處理器(central processing unit, CPU)&lt;/li&gt;
&lt;li&gt;記憶體(memory)&lt;/li&gt;
&lt;li&gt;I/O 裝置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。&lt;/li&gt;
&lt;li&gt;使用者(users)&lt;/li&gt;
&lt;li&gt;作業系統(Operating system, OS)：&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS 最主要的兩個功能是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;資源分配：根據需求調配資源分配率(resource utilization)與效能(performance)&lt;/li&gt;
&lt;li&gt;監控使用者程式的執行，避免不正常的運作造成對系統的危害。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一個標準的 PC 作業系統應該提供以下的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行程管理(Processing management)&lt;/li&gt;
&lt;li&gt;記憶體管理(Memory management)&lt;/li&gt;
&lt;li&gt;檔案系統(File system)&lt;/li&gt;
&lt;li&gt;網路通訊(Networking)&lt;/li&gt;
&lt;li&gt;安全機制(Security)&lt;/li&gt;
&lt;li&gt;使用者介面(User interface)&lt;/li&gt;
&lt;li&gt;驅動程式(Device drivers)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="pc-基本特徵"&gt;PC 基本特徵&lt;/h2&gt;
&lt;h3 id="1-並行計算concurrent-computing"&gt;1. 並行計算(Concurrent computing)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而&lt;strong&gt;平行計算(parallel computing)&lt;/strong&gt; 則指同一個時間內能運行多個指令。&lt;/li&gt;
&lt;li&gt;平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。&lt;/li&gt;
&lt;li&gt;作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-分享sharing"&gt;2. 分享(Sharing)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;共享是指系統中的資源可以被多個並行進程共同使用。&lt;/li&gt;
&lt;li&gt;有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。&lt;/li&gt;
&lt;li&gt;互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-虛擬virtual"&gt;3. 虛擬(Virtual)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;虛擬技術把一個物理實體轉換為多個邏輯實體。&lt;/li&gt;
&lt;li&gt;主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。&lt;/li&gt;
&lt;li&gt;多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。&lt;/li&gt;
&lt;li&gt;虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="4-異步asynchronous"&gt;4. 異步(Asynchronous)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="基本功能"&gt;基本功能&lt;/h2&gt;
&lt;h3 id="1-進程管理process-management"&gt;1. 進程管理(Process management)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;進程管理、進程同步、進程通信、死鎖處理、處理調度等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-記憶體管理memory-management"&gt;2. 記憶體管理(Memory management)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-文件管理file-management"&gt;3. 文件管理(File management)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="4-設備管理equipment-management"&gt;4. 設備管理(Equipment management)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。&lt;/li&gt;
&lt;li&gt;主要包含緩衝管理、設備分配、設備處理、虛擬設備等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="系統調用"&gt;系統調用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。
&lt;img alt="interface" loading="lazy" src="https://camo.githubusercontent.com/e6e9338fcb2f8c849b5ed9798862d27937d80c94721948dd87c5dec1e739c2c6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f74475056302e706e67"&gt;&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Linux 的系統調用主要有以下這些：&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Commands&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;進程控制&lt;/td&gt;
&lt;td&gt;fork(); exit(); wait();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;進程通信&lt;/td&gt;
&lt;td&gt;pipe(); shmget(); mmap();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;文件操作&lt;/td&gt;
&lt;td&gt;open(); read(); write();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;設備操作&lt;/td&gt;
&lt;td&gt;ioctl(); read(); write();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;訊息維護&lt;/td&gt;
&lt;td&gt;getpid(); alarm(); sleep();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;chmod(); umask(); chown();&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="內核與微內核"&gt;內核與微內核&lt;/h2&gt;
&lt;p&gt;&lt;img alt="ring" loading="lazy" src="https://th.bing.com/th/id/R.859db91aeb8ec96109d43097bd911459?rik=lA7Jg6HrEIuyFA&amp;riu=http%3a%2f%2fresources.infosecinstitute.com%2fwp-content%2fuploads%2fKernelDebugging-03012013.jpg&amp;ehk=XDpXoi61cf6s%2fX4BOz3ghmFHsUIdfRiN8q%2f82rDn8%2fM%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0"&gt;&lt;/p&gt;</description></item><item><title>[計算機作業系統] 鏈接</title><link>https://intervalrain.github.io/cs/os/link/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/cs/os/link/</guid><description>&lt;h1 id="準備中"&gt;準備中&lt;/h1&gt;</description></item><item><title>[CS50] Lec 1 - C</title><link>https://intervalrain.github.io/cs50/lec1/</link><pubDate>Thu, 10 Mar 2022 02:39:12 +0800</pubDate><guid>https://intervalrain.github.io/cs50/lec1/</guid><description>Introduction to programming language C</description></item><item><title>[CS50] Lec 0 - Introduction to Computer Science</title><link>https://intervalrain.github.io/cs50/lec0/</link><pubDate>Wed, 23 Feb 2022 00:43:18 +0800</pubDate><guid>https://intervalrain.github.io/cs50/lec0/</guid><description>Intoduction to Computer Science</description></item></channel></rss>