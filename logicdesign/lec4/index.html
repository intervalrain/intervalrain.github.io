<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps | Rain Hu's Workspace</title><meta name=keywords content="Logic Design"><meta name=description content="Simplify Boolean function with K-map"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/logicdesign/lec4/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/logicdesign/lec4/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps"><meta property="og:description" content="Simplify Boolean function with K-map"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="logicdesign"><meta property="article:published_time" content="2021-09-18T03:11:35+08:00"><meta property="article:modified_time" content="2021-09-18T03:11:35+08:00"><meta property="article:tag" content="Logic Design"><meta property="og:image" content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps"><meta name=twitter:description content="Simplify Boolean function with K-map"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"LogicDesigns","item":"https://intervalrain.github.io/logicdesign/"},{"@type":"ListItem","position":2,"name":"[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps","item":"https://intervalrain.github.io/logicdesign/lec4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps","name":"[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps","description":"Simplify Boolean function with K-map","keywords":["Logic Design"],"articleBody":"布林邏輯式的簡化 卡諾圖(Karnaugh Maps, K-maps)是一種簡單、快速的簡化布林邏輯的方法。 SOP 將布林邏輯化簡成最簡SOP(Minimum Sum of products) \\(F=A’ B’ C’+A’ B’ C+A’ BC’+AB’ C+ABC’ +ABC\\) \\(F=A’ B’+B’ C+BC’+AB\\) \\(F=A’ B’+BC’+AC\\) POS 將布林邏輯化簡成最簡POS(Minimum Product of Sums) \\(F=(A+B’+C+D’)(A+B’+C’+D’)(A+B’+C’+D)(A’+B’+C’+D)(A+B+C’+D)(A’+B+C’+D)\\) \\(F=(A+B’+D’)(A+B’+C’)(B’+C’+D)(B+C’+D)\\) \\(F=(A+B’+D)(A+B’+C’)(C’+D)\\) \\(F=(A+B’+D’)(C’+D)\\) 2或3個變數的卡諾圖 簡化2個變數的布林邏輯式 \\(F=A’ B’+A’ B\\) 布林代數： \\(F=A’ B’+A’ B=A’(B’+B)=A’\\) 卡諾圖： \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow B\\rightarrow A\u00260\u00261\u0026\\\\\\hline 0\u0026\\text{A=0,B=0}\u0026\\text{A=1,B=0}\\\\\\hline 1\u0026\\text{A=0,B=1}\u0026\\text{A=1,B=1}\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026A’\u0026A\u0026\\\\\\hline B’\u00261\u00260\\\\\\hline B\u00261\u00260\\\\ \\end{array} } \\rightarrow A' \\) 簡化3個變數的布林邏輯式 \\(F=\\sum m(2,3,6)=A’ BC’+A’ BC+ABC’\\) 布林代數： \\(F=A’ BC’+A’ BC+ABC’=A’ B+BC’\\) 卡諾圖：*注意相鄰以grey code排列 \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow BC\\rightarrow A\u00260\u00261\u0026\\\\\\hline 00\u0026m_0(000)\u0026m_4(100)\\\\\\hline 01\u0026m_1(001)\u0026m_5(101)\\\\\\hline 11\u0026m_3(011)\u0026m_7(111)\\\\\\hline 10\u0026m_2(010)\u0026m_6(110)\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026A’\u0026A\u0026\\\\\\hline B’ C’\u00260\u00260\\\\\\hline B’ C \u00260\u00260\\\\\\hline B C \u00261\u00260\\\\\\hline B C’ \u00261\u00261\\\\ \\end{array} } \\rightarrow A’ B+BC' \\) 相鄰(Adjacency)的定義 最上面可以與最下面相接，視為相鄰 最左邊可以與最右邊相接，視為相鄰 \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026A’\u0026A\u0026\\\\\\hline B’ C’\u00260\u00260\\\\\\hline B’ C \u00260\u00260\\\\\\hline B C \u00261\u00261\\\\\\hline B C’ \u00260\u00260\\\\ \\end{array} } \\rightarrow BC \\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026A’\u0026A\u0026\\\\\\hline B’ C’\u00261\u00260\\\\\\hline B’ C \u00260\u00260\\\\\\hline B C \u00260\u00260\\\\\\hline B C’ \u00261\u00260\\\\ \\end{array} } \\rightarrow A’ C' \\) 組合的規則 以組合相鄰且以2為倍數為規則 組合的元素愈多愈好 可以重複選(cover) 等效最簡式 \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026A’\u0026A\u0026\\\\\\hline B’ C’\u00261\u00260\\\\\\hline B’ C \u00261\u00261\\\\\\hline B C \u00260\u00261\\\\\\hline B C’ \u00261\u00261\\\\ \\end{array}} \\rightarrow F=A’ B’+BC’+AC=A’ C’+B’C+AB \\) 4個變數的卡諾圖 \\(F=ACD+A’ B+D’\\) 以卡諾圖表示 \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026A’ B’\u0026A’ B\u0026AB\u0026AB’\\\\\\hline C’ D’\u00261\u00261\u00261\u00261\\\\\\hline C’ D \u0026 \u00261\u0026 \u0026 \\\\\\hline C D \u0026 \u00261\u00261\u00261\\\\\\hline C D’ \u00261\u00261\u00261\u00261\\\\ \\end{array}} \\quad \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u002600\u002601\u002611\u002610\\\\\\hline 00\u0026m_0\u0026m_4\u0026m_{12}\u0026m_8\\\\\\hline 01\u0026m_1\u0026m_5\u0026m_{13}\u0026m_9\\\\\\hline 11\u0026m_3\u0026m_7\u0026m_{15}\u0026m_{11}\\\\\\hline 10\u0026m_2\u0026m_6\u0026m_{14}\u0026m_{10}\\\\ \\end{array}} \\) 以 min-term expression 方式解題 解 \\(F(a,b,c,d)=\\sum m(1,3,4,5,10,12,13)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u002600\u002601\u002611\u002610\\\\\\hline 00\u0026 \u00261\u00261\u0026 \\\\\\hline 01\u00261\u00261\u00261\u0026 \\\\\\hline 11\u00261\u0026 \u0026 \u0026 \\\\\\hline 10\u0026 \u0026 \u0026 \u00261\\\\ \\end{array}} \\rightarrow F=bc’+a’ b’ d+ab’ c’d \\) 考慮 Don’t care 的情況 解 \\(F(a,b,c,d)=\\sum m(1,3,5,7,9)+\\sum d(6,12,13)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u002600\u002601\u002611\u002610\\\\\\hline 00\u0026 \u0026 \u0026X\u0026 \\\\\\hline 01\u00261\u00261\u0026X\u00261\\\\\\hline 11\u00261\u00261\u0026 \u0026 \\\\\\hline 10\u0026 \u0026X\u0026 \u0026 \\\\ \\end{array}} \\rightarrow F=a’d+c’d \\) 以 max-term expression 方式解題 解 \\(F(a,b,c,d)=\\sum m(0,2,3,4,8,10,11,15)=\\prod M(1,5,6,7,9,12,13,14)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u002600\u002601\u002611\u002610\\\\\\hline 00\u0026 \u0026 \u00260\u0026 \\\\\\hline 01\u00260\u00260\u00260\u00260\\\\\\hline 11\u0026 \u00260\u0026 \u0026 \\\\\\hline 10\u0026 \u00260\u00260\u0026 \\\\ \\end{array}} \\)\n\\(\\rightarrow F’=c’ d+a’ bc+abd’\\)\n\\(\\rightarrow F=(c+d)(a+b’+c’)(a’+b’+d)\\) 基本質函項(essential prime implicants) 名詞定義 蘊函項(Implicant) 任何可以被組合的單一或群元素(意指為 \\(F\\)的子集。) 質函項(Prime Implicant) 已不能再被組合更多的函項。(意指最大的、框選最多的子集) 基本質函項(Essential Prime Implicant) 一個帶有只能被單一質函項框選到的元素的質函項 \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u002600\u002601\u002611\u002610\\\\\\hline 00\u0026 \u0026 \u00261\u0026 \\\\\\hline 01\u00261\u00261\u00261\u0026 \\\\\\hline 11\u0026 \u00261\u00261\u00261\\\\\\hline 10\u0026 \u00261\u0026 \u0026 \\\\ \\end{array}} \\) 蘊函項：\\(A’ C’ D, ABC’, ACD, A’ BC, BD, m_1, m_5, m_6, m_7…. \\) 質函項：\\(A’ C’ D, ABC’, ACD, A’ BC, BD \\) 基本質函項：\\(A’ C’ D,ABC’,A’ BC, ACD\\) 簡化原則 因為有可能存在多個等效的最簡式，所以： 盡可能將式子展開成質函項(Prime implicants)。 用盡可能最少的質函項來表式布林函式。 例題 \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u002600\u002601\u002611\u002610\\\\\\hline 00\u0026 \u00261\u00261\u0026 \\\\\\hline 01\u00261\u00261\u00261\u0026 \\\\\\hline 11\u00261\u0026 \u00261\u00261\\\\\\hline 10\u0026 \u0026 \u00261\u00261\\\\ \\end{array}} \\rightarrow F=A’ B’ D+BC’+AC \\) 5個變數的卡諾圖 表示法1 表示法2 ","wordCount":"382","inLanguage":"zh-tw","image":"https://intervalrain.github.io/images/cover.jpg","datePublished":"2021-09-18T03:11:35+08:00","dateModified":"2021-09-18T03:11:35+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/logicdesign/lec4/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/logicdesign/>LogicDesigns</a></div><h1 class="post-title entry-hint-parent">[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps</h1><div class=post-description>Simplify Boolean function with K-map</div><div class=post-meta><span title='2021-09-18 03:11:35 +0800 +0800'>September 18, 2021</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//LogicDesign/Lec4.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e5%b8%83%e6%9e%97%e9%82%8f%e8%bc%af%e5%bc%8f%e7%9a%84%e7%b0%a1%e5%8c%96 aria-label=布林邏輯式的簡化>布林邏輯式的簡化</a><ul><li><a href=#sop aria-label=SOP>SOP</a></li><li><a href=#pos aria-label=POS>POS</a></li></ul></li><li><a href=#2%e6%88%963%e5%80%8b%e8%ae%8a%e6%95%b8%e7%9a%84%e5%8d%a1%e8%ab%be%e5%9c%96 aria-label=2或3個變數的卡諾圖>2或3個變數的卡諾圖</a><ul><li><a href=#%e7%b0%a1%e5%8c%962%e5%80%8b%e8%ae%8a%e6%95%b8%e7%9a%84%e5%b8%83%e6%9e%97%e9%82%8f%e8%bc%af%e5%bc%8f aria-label=簡化2個變數的布林邏輯式>簡化2個變數的布林邏輯式</a></li><li><a href=#%e7%b0%a1%e5%8c%963%e5%80%8b%e8%ae%8a%e6%95%b8%e7%9a%84%e5%b8%83%e6%9e%97%e9%82%8f%e8%bc%af%e5%bc%8f aria-label=簡化3個變數的布林邏輯式>簡化3個變數的布林邏輯式</a></li><li><a href=#%e7%9b%b8%e9%84%b0adjacency%e7%9a%84%e5%ae%9a%e7%be%a9 aria-label=相鄰(Adjacency)的定義>相鄰(Adjacency)的定義</a></li><li><a href=#%e7%b5%84%e5%90%88%e7%9a%84%e8%a6%8f%e5%89%87 aria-label=組合的規則>組合的規則</a></li><li><a href=#%e7%ad%89%e6%95%88%e6%9c%80%e7%b0%a1%e5%bc%8f aria-label=等效最簡式>等效最簡式</a></li></ul></li><li><a href=#4%e5%80%8b%e8%ae%8a%e6%95%b8%e7%9a%84%e5%8d%a1%e8%ab%be%e5%9c%96 aria-label=4個變數的卡諾圖>4個變數的卡諾圖</a><ul><li><a href=#%e4%bb%a5-min-term-expression-%e6%96%b9%e5%bc%8f%e8%a7%a3%e9%a1%8c aria-label="以 min-term expression 方式解題">以 min-term expression 方式解題</a></li><li><a href=#%e8%80%83%e6%85%ae-dont-care-%e7%9a%84%e6%83%85%e6%b3%81 aria-label="考慮 Don&rsquo;t care 的情況">考慮 Don&rsquo;t care 的情況</a></li><li><a href=#%e4%bb%a5-max-term-expression-%e6%96%b9%e5%bc%8f%e8%a7%a3%e9%a1%8c aria-label="以 max-term expression 方式解題">以 max-term expression 方式解題</a></li></ul></li><li><a href=#%e5%9f%ba%e6%9c%ac%e8%b3%aa%e5%87%bd%e9%a0%85essential-prime-implicants aria-label="基本質函項(essential prime implicants)">基本質函項(essential prime implicants)</a><ul><li><a href=#%e5%90%8d%e8%a9%9e%e5%ae%9a%e7%be%a9 aria-label=名詞定義>名詞定義</a></li><li><a href=#%e7%b0%a1%e5%8c%96%e5%8e%9f%e5%89%87 aria-label=簡化原則>簡化原則</a></li></ul></li><li><a href=#5%e5%80%8b%e8%ae%8a%e6%95%b8%e7%9a%84%e5%8d%a1%e8%ab%be%e5%9c%96 aria-label=5個變數的卡諾圖>5個變數的卡諾圖</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=布林邏輯式的簡化>布林邏輯式的簡化<a hidden class=anchor aria-hidden=true href=#布林邏輯式的簡化>#</a></h1><ul><li>卡諾圖(Karnaugh Maps, K-maps)是一種簡單、快速的簡化布林邏輯的方法。</li></ul><h2 id=sop>SOP<a hidden class=anchor aria-hidden=true href=#sop>#</a></h2><ul><li>將布林邏輯化簡成最簡SOP(Minimum Sum of products)<ul><li>\(F=A&rsquo; B&rsquo; C&rsquo;+A&rsquo; B&rsquo; C+A&rsquo; BC&rsquo;+AB&rsquo; C+ABC&rsquo; +ABC\)</li><li>\(F=A&rsquo; B&rsquo;+B&rsquo; C+BC&rsquo;+AB\)</li><li>\(F=A&rsquo; B&rsquo;+BC&rsquo;+AC\)</li></ul></li></ul><h2 id=pos>POS<a hidden class=anchor aria-hidden=true href=#pos>#</a></h2><ul><li>將布林邏輯化簡成最簡POS(Minimum Product of Sums)<ul><li>\(F=(A+B&rsquo;+C+D&rsquo;)(A+B&rsquo;+C&rsquo;+D&rsquo;)(A+B&rsquo;+C&rsquo;+D)(A&rsquo;+B&rsquo;+C&rsquo;+D)(A+B+C&rsquo;+D)(A&rsquo;+B+C&rsquo;+D)\)</li><li>\(F=(A+B&rsquo;+D&rsquo;)(A+B&rsquo;+C&rsquo;)(B&rsquo;+C&rsquo;+D)(B+C&rsquo;+D)\)</li><li>\(F=(A+B&rsquo;+D)(A+B&rsquo;+C&rsquo;)(C&rsquo;+D)\)</li><li>\(F=(A+B&rsquo;+D&rsquo;)(C&rsquo;+D)\)</li></ul></li></ul><h1 id=2或3個變數的卡諾圖>2或3個變數的卡諾圖<a hidden class=anchor aria-hidden=true href=#2或3個變數的卡諾圖>#</a></h1><h2 id=簡化2個變數的布林邏輯式>簡化2個變數的布林邏輯式<a hidden class=anchor aria-hidden=true href=#簡化2個變數的布林邏輯式>#</a></h2><ul><li>\(F=A&rsquo; B&rsquo;+A&rsquo; B\)<ul><li>布林代數：<ul><li>\(F=A&rsquo; B&rsquo;+A&rsquo; B=A&rsquo;(B&rsquo;+B)=A&rsquo;\)</li></ul></li><li>卡諾圖：<ul><li>\(
\boxed{
\def\arraystretch{1.4}\begin{array}{c|c|c}
\downarrow B\rightarrow A&amp;0&amp;1&\\\hline
0&\text{A=0,B=0}&\text{A=1,B=0}\\\hline
1&\text{A=0,B=1}&\text{A=1,B=1}\\
\end{array}
}
\rightarrow
\boxed{
\def\arraystretch{1.4}\begin{array}{c|c|c}
&amp;A&rsquo;&amp;A&\\\hline
B&rsquo;&amp;1&amp;0\\\hline
B&amp;1&amp;0\\
\end{array}
}
\rightarrow
A'
\)</li></ul></li></ul></li></ul><hr><h2 id=簡化3個變數的布林邏輯式>簡化3個變數的布林邏輯式<a hidden class=anchor aria-hidden=true href=#簡化3個變數的布林邏輯式>#</a></h2><ul><li>\(F=\sum m(2,3,6)=A&rsquo; BC&rsquo;+A&rsquo; BC+ABC&rsquo;\)<ul><li>布林代數：<ul><li>\(F=A&rsquo; BC&rsquo;+A&rsquo; BC+ABC&rsquo;=A&rsquo; B+BC&rsquo;\)</li></ul></li><li>卡諾圖：*<strong>注意相鄰以grey code排列</strong><ul><li>\(
\boxed{
\def\arraystretch{1.4}\begin{array}{c|c|c}
\downarrow BC\rightarrow A&amp;0&amp;1&\\\hline
00&amp;m_0(000)&amp;m_4(100)\\\hline
01&amp;m_1(001)&amp;m_5(101)\\\hline
11&amp;m_3(011)&amp;m_7(111)\\\hline
10&amp;m_2(010)&amp;m_6(110)\\
\end{array}
}
\rightarrow
\boxed{
\def\arraystretch{1.4}\begin{array}{c|c|c}
&amp;A&rsquo;&amp;A&\\\hline
B&rsquo; C&rsquo;&amp;0&amp;0\\\hline
B&rsquo; C &amp;0&amp;0\\\hline
B C &amp;1&amp;0\\\hline
B C&rsquo; &amp;1&amp;1\\
\end{array}
}
\rightarrow
A&rsquo; B+BC'
\)</li></ul></li></ul></li></ul><hr><h2 id=相鄰adjacency的定義>相鄰(Adjacency)的定義<a hidden class=anchor aria-hidden=true href=#相鄰adjacency的定義>#</a></h2><ul><li>最上面可以與最下面相接，視為相鄰</li><li>最左邊可以與最右邊相接，視為相鄰<ul><li>\(
\boxed{
\def\arraystretch{1.4}\begin{array}{c|c|c}
&amp;A&rsquo;&amp;A&\\\hline
B&rsquo; C&rsquo;&amp;0&amp;0\\\hline
B&rsquo; C &amp;0&amp;0\\\hline
B C &amp;1&amp;1\\\hline
B C&rsquo; &amp;0&amp;0\\
\end{array}
}
\rightarrow BC
\)</li><li>\(
\boxed{
\def\arraystretch{1.4}\begin{array}{c|c|c}
&amp;A&rsquo;&amp;A&\\\hline
B&rsquo; C&rsquo;&amp;1&amp;0\\\hline
B&rsquo; C &amp;0&amp;0\\\hline
B C &amp;0&amp;0\\\hline
B C&rsquo; &amp;1&amp;0\\
\end{array}
}
\rightarrow A&rsquo; C'
\)</li></ul></li></ul><h2 id=組合的規則>組合的規則<a hidden class=anchor aria-hidden=true href=#組合的規則>#</a></h2><ul><li>以組合<strong>相鄰</strong>且<strong>以2為倍數</strong>為規則</li><li>組合的元素愈多愈好</li><li>可以重複選(cover)</li></ul><h2 id=等效最簡式>等效最簡式<a hidden class=anchor aria-hidden=true href=#等效最簡式>#</a></h2><ul><li>\(\boxed{\def\arraystretch{1.4}\begin{array}{c|c|c}
&amp;A&rsquo;&amp;A&\\\hline
B&rsquo; C&rsquo;&amp;1&amp;0\\\hline
B&rsquo; C &amp;1&amp;1\\\hline
B C &amp;0&amp;1\\\hline
B C&rsquo; &amp;1&amp;1\\
\end{array}}
\rightarrow
F=A&rsquo; B&rsquo;+BC&rsquo;+AC=A&rsquo; C&rsquo;+B&rsquo;C+AB
\)</li></ul><h1 id=4個變數的卡諾圖>4個變數的卡諾圖<a hidden class=anchor aria-hidden=true href=#4個變數的卡諾圖>#</a></h1><ul><li>\(F=ACD+A&rsquo; B+D&rsquo;\)</li><li>以卡諾圖表示<ul><li>\(\boxed{\def\arraystretch{1.4}\begin{array}{c|c|c|c|c}
&amp;A&rsquo; B&rsquo;&amp;A&rsquo; B&amp;AB&amp;AB&rsquo;\\\hline
C&rsquo; D&rsquo;&amp;1&amp;1&amp;1&amp;1\\\hline
C&rsquo; D & &amp;1& & \\\hline
C D & &amp;1&amp;1&amp;1\\\hline
C D&rsquo; &amp;1&amp;1&amp;1&amp;1\\
\end{array}}
\quad
\boxed{\def\arraystretch{1.4}\begin{array}{c|c|c|c|c}
&amp;00&amp;01&amp;11&amp;10\\\hline
00&amp;m_0&amp;m_4&amp;m_{12}&amp;m_8\\\hline
01&amp;m_1&amp;m_5&amp;m_{13}&amp;m_9\\\hline
11&amp;m_3&amp;m_7&amp;m_{15}&amp;m_{11}\\\hline
10&amp;m_2&amp;m_6&amp;m_{14}&amp;m_{10}\\
\end{array}}
\)</li></ul></li></ul><hr><h2 id=以-min-term-expression-方式解題>以 min-term expression 方式解題<a hidden class=anchor aria-hidden=true href=#以-min-term-expression-方式解題>#</a></h2><ul><li>解 \(F(a,b,c,d)=\sum m(1,3,4,5,10,12,13)\)<ul><li>\(
\boxed{\def\arraystretch{1.4}\begin{array}{c|c|c|c|c}
&amp;00&amp;01&amp;11&amp;10\\\hline
00& &amp;1&amp;1& \\\hline
01&amp;1&amp;1&amp;1& \\\hline
11&amp;1& & & \\\hline
10& & & &amp;1\\
\end{array}}
\rightarrow
F=bc&rsquo;+a&rsquo; b&rsquo; d+ab&rsquo; c&rsquo;d
\)</li></ul></li></ul><hr><h2 id=考慮-dont-care-的情況>考慮 Don&rsquo;t care 的情況<a hidden class=anchor aria-hidden=true href=#考慮-dont-care-的情況>#</a></h2><ul><li>解 \(F(a,b,c,d)=\sum m(1,3,5,7,9)+\sum d(6,12,13)\)<ul><li>\(
\boxed{\def\arraystretch{1.4}\begin{array}{c|c|c|c|c}
&amp;00&amp;01&amp;11&amp;10\\\hline
00& & &amp;X& \\\hline
01&amp;1&amp;1&amp;X&amp;1\\\hline
11&amp;1&amp;1& & \\\hline
10& &amp;X& & \\
\end{array}}
\rightarrow
F=a&rsquo;d+c&rsquo;d
\)</li></ul></li></ul><hr><h2 id=以-max-term-expression-方式解題>以 max-term expression 方式解題<a hidden class=anchor aria-hidden=true href=#以-max-term-expression-方式解題>#</a></h2><ul><li>解 \(F(a,b,c,d)=\sum m(0,2,3,4,8,10,11,15)=\prod M(1,5,6,7,9,12,13,14)\)<ul><li>\(
\boxed{\def\arraystretch{1.4}\begin{array}{c|c|c|c|c}
&amp;00&amp;01&amp;11&amp;10\\\hline
00& & &amp;0& \\\hline
01&amp;0&amp;0&amp;0&amp;0\\\hline
11& &amp;0& & \\\hline
10& &amp;0&amp;0& \\
\end{array}}
\)<br>\(\rightarrow F&rsquo;=c&rsquo; d+a&rsquo; bc+abd&rsquo;\)<br>\(\rightarrow F=(c+d)(a+b&rsquo;+c&rsquo;)(a&rsquo;+b&rsquo;+d)\)</li></ul></li></ul><h1 id=基本質函項essential-prime-implicants>基本質函項(essential prime implicants)<a hidden class=anchor aria-hidden=true href=#基本質函項essential-prime-implicants>#</a></h1><h2 id=名詞定義>名詞定義<a hidden class=anchor aria-hidden=true href=#名詞定義>#</a></h2><ul><li>蘊函項(Implicant)<ul><li>任何可以被組合的單一或群元素(意指為 \(F\)的子集。)</li></ul></li><li>質函項(Prime Implicant)<ul><li>已不能再被組合更多的函項。(意指最大的、框選最多的子集)</li></ul></li><li>基本質函項(Essential Prime Implicant)<ul><li>一個帶有只能被單一質函項框選到的元素的質函項</li></ul></li><li>\(
\boxed{\def\arraystretch{1.4}\begin{array}{c|c|c|c|c}
&amp;00&amp;01&amp;11&amp;10\\\hline
00& & &amp;1& \\\hline
01&amp;1&amp;1&amp;1& \\\hline
11& &amp;1&amp;1&amp;1\\\hline
10& &amp;1& & \\
\end{array}}
\)<ul><li>蘊函項：\(A&rsquo; C&rsquo; D, ABC&rsquo;, ACD, A&rsquo; BC, BD, m_1, m_5, m_6, m_7&mldr;. \)</li><li>質函項：\(A&rsquo; C&rsquo; D, ABC&rsquo;, ACD, A&rsquo; BC, BD \)</li><li>基本質函項：\(A&rsquo; C&rsquo; D,ABC&rsquo;,A&rsquo; BC, ACD\)</li></ul></li></ul><h2 id=簡化原則>簡化原則<a hidden class=anchor aria-hidden=true href=#簡化原則>#</a></h2><ul><li>因為有可能存在多個等效的最簡式，所以：</li></ul><ol><li>盡可能將式子展開成質函項(Prime implicants)。</li><li>用盡可能最少的質函項來表式布林函式。</li></ol><hr><ul><li>例題</li><li>\(
\boxed{\def\arraystretch{1.4}\begin{array}{c|c|c|c|c}
&amp;00&amp;01&amp;11&amp;10\\\hline
00& &amp;1&amp;1& \\\hline
01&amp;1&amp;1&amp;1& \\\hline
11&amp;1& &amp;1&amp;1\\\hline
10& & &amp;1&amp;1\\
\end{array}}
\rightarrow
F=A&rsquo; B&rsquo; D+BC&rsquo;+AC
\)</li></ul><h1 id=5個變數的卡諾圖>5個變數的卡諾圖<a hidden class=anchor aria-hidden=true href=#5個變數的卡諾圖>#</a></h1><ul><li>表示法1
<img alt=Kmap1 loading=lazy src=/images/LD/Kmap1.png></li><li>表示法2
<img alt=Kmap2 loading=lazy src=/images/LD/Kmap2.png></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/logic-design/>Logic Design</a></li></ul></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>