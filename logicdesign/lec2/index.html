<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Logic Design] Lec 02 - 布林代數 | Rain Hu's Workspace</title><meta name=keywords content="Logic Design"><meta name=description content="Boolean Algebra operation and theory"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4c6c0beaf1dfe52cd0f712a5896ac127e66fd064cfc598e04750f496d470699e.css integrity="sha256-TGwL6vHf5SzQ9xKliWrBJ+Zv0GTPxZjgR1D0ltRwaZ4=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/logicdesign/lec2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/logicdesign/lec2/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[Logic Design] Lec 02 - 布林代數"><meta property="og:description" content="Boolean Algebra operation and theory"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="logicdesign"><meta property="article:published_time" content="2021-09-18T03:11:35+08:00"><meta property="article:modified_time" content="2021-09-18T03:11:35+08:00"><meta property="article:tag" content="Logic Design"><meta property="og:image" content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[Logic Design] Lec 02 - 布林代數"><meta name=twitter:description content="Boolean Algebra operation and theory"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"LogicDesigns","item":"https://intervalrain.github.io/logicdesign/"},{"@type":"ListItem","position":2,"name":"[Logic Design] Lec 02 - 布林代數","item":"https://intervalrain.github.io/logicdesign/lec2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Logic Design] Lec 02 - 布林代數","name":"[Logic Design] Lec 02 - 布林代數","description":"Boolean Algebra operation and theory","keywords":["Logic Design"],"articleBody":"基本邏輯運算 Logic Gates Not Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026\\overline{\\text{X}}\\text{or}\\text{X’}\\\\\\hline 0\u00261\\\\\\hline 1\u00260\\\\\\hline \\end{array} \\) And Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026\\text{Y}\u0026\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u00260\u00260\\\\\\hline 0\u00261\u00260\\\\\\hline 1\u00260\u00260\\\\\\hline 1\u00261\u00261\\\\\\hline \\end{array} \\) Or Gates Symbol Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026\\text{Y}\u0026\\text{Z=X+Y}\\\\\\hline 0\u00260\u00260\\\\\\hline 0\u00261\u00261\\\\\\hline 1\u00260\u00261\\\\\\hline 1\u00261\u00261\\\\\\hline \\end{array} \\) 布林表達式與真值表(Boolean Expression and Truth Table) Boolean expression 用 ' 代表 NOT 用 + 代表 OR 用 . 代表 AND 將輸入用上面的運算子表示成算式，如：\\((A+C)(B’+C)\\) Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{ccc|cccccc} A\u0026B\u0026C\u0026B’\u0026AB’\u0026AB’+C\u0026A+C\u0026B’+C\u0026(A+C)(B’+C)\\\\\\hline 0\u00260\u00260\u00261\u00260\u00260\u00260\u00261\u00260\\\\ 0\u00260\u00261\u00261\u00260\u00261\u00261\u00261\u00261\\\\ 0\u00261\u00260\u00260\u00260\u00260\u00260\u00260\u00260\\\\ 0\u00261\u00261\u00260\u00260\u00261\u00261\u00261\u00261\\\\ 1\u00260\u00260\u00261\u00261\u00261\u00261\u00261\u00261\\\\ 1\u00260\u00261\u00261\u00261\u00261\u00261\u00261\u00261\\\\ 1\u00261\u00260\u00260\u00260\u00260\u00261\u00260\u00260\\\\ 1\u00261\u00261\u00260\u00260\u00261\u00261\u00261\u00261\\\\ \\end{array} \\) 基本運算定理 NOT gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x’)’\u0026=\u0026x \\end{array} } \\)\nAND gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x+0\u0026=\u0026x\\\\ x+1\u0026=\u00261\\\\ x+x\u0026=\u0026x\\\\ x+x’\u0026=\u00261 \\end{array} } \\)\nOR gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\cdot 0\u0026=\u00260\\\\ x\\cdot 1\u0026=\u0026x\\\\ x\\cdot x\u0026=\u0026x\\\\ x\\cdot x’\u0026=\u00260 \\end{array} } \\)\n進階運算定理 交換律 Commutative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} xy\u0026=\u0026yx\\\\ x+y\u0026=\u0026y+x \\end{array} } \\)\n結合律 Associative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (xy)z\u0026=\u0026x(yz)\\\\ (x+y)+z\u0026=\u0026x+(y+z) \\end{array} } \\)\n分配律 Distributive Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026=\u0026xy+xz\\\\ x+yz\u0026=\u0026(x+y)(x+z) \\end{array} } \\)\nMultiplying out and factoring Sum of Product(SOP) form 將算式化整成各個輸入端先 AND 後再 OR 例： \\(ABC+AB’C+AB’C’\\) Product of Sum(POS) form 將算式化整成各個輸入端先 OR 後再 AND 例： \\((A+B+C)(A+B’+C)(A+B’+C’)\\) Multiplying out： 將算式化簡成 SOP form 善用\\(\\boxed{(A+B)(A+C)=A+BC}\\) 範例：\n\\((A+BC)(A+D+E)\\)\n\\(=(A+x)(A+y)\\)\n\\(=A+xy\\)\n\\(=A+BC(D+E)\\)\n\\(=A+BCD+BCE\\) Factoring： 將算式化簡成 POS form 善用\\(\\boxed{A+BC=(A+B)(A+C)}\\) 範例：\n\\(AB’+C’D\\)\n\\(=(AB’+C’)(AB’+D)\\)\n\\(=(A+C’)(B’+C’)(A+D)(B’+D))\\) 2-level realization 利用 Multiplying out 與 Factoring 可以將電路簡化成 2-level circuit 因為減少了 Delay propagation 可以減少 Total Time Delay DeMorgan’s Laws and Duality DeMorgan’s Laws 方法： \\(AND\\leftrightarrow OR\\) \\(A\\leftrightarrow A’\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x+y+z+…)’\u0026=\u0026x’ y’ z’…\\\\ (xyz…)’\u0026=\u0026x’+y’+z’… \\end{array} } \\) Truth Table 證明\n\\( \\def\\arraystretch{1.5}\\begin{array}{ccc|ccc|c|c|c} x\u0026y\u0026z\u0026x’\u0026y’\u0026z’\u0026x+y+z\u0026(x+y+z)’\u0026x’ y’ z’\\\\\\hline 0\u00260\u00260\u00261\u00261\u00261\u00260\u00261\u00261\\\\ 0\u00260\u00261\u00261\u00261\u00260\u00261\u00260\u00260\\\\ 0\u00261\u00260\u00261\u00260\u00261\u00261\u00260\u00260\\\\ 0\u00261\u00261\u00261\u00260\u00260\u00261\u00260\u00260\\\\ 1\u00260\u00260\u00260\u00261\u00261\u00261\u00260\u00260\\\\ 1\u00260\u00261\u00260\u00261\u00260\u00261\u00260\u00260\\\\ 1\u00261\u00260\u00260\u00260\u00261\u00261\u00260\u00260\\\\ 1\u00261\u00261\u00260\u00260\u00260\u00261\u00260\u00260\\\\ \\end{array} \\) 範例\n\\([(A’ B+C’)(D’+EF’)+GH+W]’\\)\n\\(=[(A+B’)C+D(E’+F)] (G’+H’)W’\\) Duality 方法\n\\(AND\\leftrightarrow OR\\) \\(0\\leftrightarrow 1\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{cccccccccc} [f(\u0026x_1,\u0026x_2,\u0026…,\u0026x_n,\u00260,\u00261,\u0026+,\u0026\\cdot\u0026)]^D\\\\ =f(\u0026x_1,\u0026x_2,\u0026…,\u0026x_n,\u00261,\u00260,\u0026\\cdot,\u0026+\u0026) \\end{array} } \\) 性質\n\\(\\boxed{F=G\\rightarrow F^D=G^D}\\) 範例\n\\((x+y’)y=xy\\rightarrow x\\cdot y’+y=x+y\\)\n回顧分配律 Distributive Law，即為 Duality 的表現。\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026=\u0026xy+xz\\\\ x+yz\u0026=\u0026(x+y)(x+z) \\end{array} } \\)\nExclusive-OR and equivalence operations Exlusive-OR(XOR,\\(\\oplus\\)) Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026\\text{Y}\u0026\\text{Z=X}\\oplus\\text{Y}\\\\\\hline 0\u00260\u00260\\\\\\hline 0\u00261\u00261\\\\\\hline 1\u00260\u00261\\\\\\hline 1\u00261\u00260\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\oplus 0\u0026=\u0026x\\\\ x\\oplus 1\u0026=\u0026x’\\\\ x\\oplus x\u0026=\u00260\\\\ x\\oplus x’\u0026=\u00261\\\\ x\\oplus y\u0026=\u0026y\\oplus x\\\\ (x\\oplus y)\\oplus z\u0026=\u0026x\\oplus (y\\oplus z)\\\\ x(y\\oplus z)\u0026=\u0026xy\\oplus xz\\\\ x\\oplus y\u0026=\u0026xy+x’ y' \\end{array} } \\) Equivalence(\\(\\equiv\\)) Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026\\text{Y}\u0026\\text{Z=X}\\equiv{Y}\\\\\\hline 0\u00260\u00261\\\\\\hline 0\u00261\u00260\\\\\\hline 1\u00260\u00260\\\\\\hline 1\u00261\u00261\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\equiv 0\u0026=\u0026x’\\\\ x\\equiv 1\u0026=\u0026x\\\\ x\\equiv x\u0026=\u00261\\\\ x\\equiv x’\u0026=\u00260\\\\ x\\equiv y\u0026=\u0026y\\equiv x\\\\ (x\\equiv y)\\equiv z\u0026=\u0026x\\equiv (y\\equiv z)\\\\ x(y\\equiv z)\u0026=\u0026xy\\equiv xz\\\\ x\\equiv y\u0026=\u0026xy’+x’ y \\end{array} } \\) 連鎖律 The consensus thorem 公式： \\(\\boxed{xy+x’ z+yz=xy+x’ z}\\) \\(\\boxed{(x+y)(x’+z)(y+z)=(x+y)(x’+z)}\\) 證明：\n\\(xy+x’ z+yz\\)\n\\(=xy+x’ z + (x+x’)yz\\)\n\\(=xy+xyz+x’ z+x’ yz\\)\n\\(=xy(1+z)+x’ z(1+y)\\)\n\\(=xy+x’ z\\) 簡化布林表達式的流程 利用 \\(\\boxed{xy+xy’=x(y+y’)=x}\\)(AND性質) 利用 \\(\\boxed{x+xy+…=x(1+y+…)=x}\\)(OR性質) 利用 \\(\\boxed{xy+x’ z+yz=xy+x’z }\\)(連鎖律) 利用 \\(\\boxed{x+x’y=x(y+y’)+x’y=xy+xy’+x’ y=x+y}\\) 必要時加入 redundant terms Lec3會使用圖表法，較不容易出錯。 如何證明布林表達式的正確性? 建構 Truth Table 簡化 LHS 和 RHS ","wordCount":"428","inLanguage":"zh-tw","image":"https://intervalrain.github.io/images/cover.jpg","datePublished":"2021-09-18T03:11:35+08:00","dateModified":"2021-09-18T03:11:35+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/logicdesign/lec2/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/logicdesign/>LogicDesigns</a></div><h1 class="post-title entry-hint-parent">[Logic Design] Lec 02 - 布林代數</h1><div class=post-description>Boolean Algebra operation and theory</div><div class=post-meta><span title='2021-09-18 03:11:35 +0800 +0800'>September 18, 2021</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//LogicDesign/Lec2.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e9%82%8f%e8%bc%af%e9%81%8b%e7%ae%97 aria-label=基本邏輯運算>基本邏輯運算</a><ul><li><a href=#logic-gates aria-label="Logic Gates">Logic Gates</a><ul><li><a href=#not-gates aria-label="Not Gates">Not Gates</a></li><li><a href=#and-gates aria-label="And Gates">And Gates</a></li><li><a href=#or-gates aria-label="Or Gates">Or Gates</a></li></ul></li></ul></li><li><a href=#%e5%b8%83%e6%9e%97%e8%a1%a8%e9%81%94%e5%bc%8f%e8%88%87%e7%9c%9f%e5%80%bc%e8%a1%a8boolean-expression-and-truth-table aria-label="布林表達式與真值表(Boolean Expression and Truth Table)">布林表達式與真值表(Boolean Expression and Truth Table)</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e9%81%8b%e7%ae%97%e5%ae%9a%e7%90%86 aria-label=基本運算定理>基本運算定理</a><ul><li><a href=#not-gate-%e7%9a%84%e5%9f%ba%e6%9c%ac%e9%81%8b%e7%ae%97%e5%ae%9a%e7%90%86 aria-label="NOT gate 的基本運算定理">NOT gate 的基本運算定理</a></li><li><a href=#and-gate-%e7%9a%84%e5%9f%ba%e6%9c%ac%e9%81%8b%e7%ae%97%e5%ae%9a%e7%90%86 aria-label="AND gate 的基本運算定理">AND gate 的基本運算定理</a></li><li><a href=#or-gate-%e7%9a%84%e5%9f%ba%e6%9c%ac%e9%81%8b%e7%ae%97%e5%ae%9a%e7%90%86 aria-label="OR gate 的基本運算定理">OR gate 的基本運算定理</a></li></ul></li><li><a href=#%e9%80%b2%e9%9a%8e%e9%81%8b%e7%ae%97%e5%ae%9a%e7%90%86 aria-label=進階運算定理>進階運算定理</a><ul><li><a href=#%e4%ba%a4%e6%8f%9b%e5%be%8b-commutative-law aria-label="交換律 Commutative Law">交換律 Commutative Law</a></li><li><a href=#%e7%b5%90%e5%90%88%e5%be%8b-associative-law aria-label="結合律 Associative Law">結合律 Associative Law</a></li><li><a href=#%e5%88%86%e9%85%8d%e5%be%8b-distributive-law aria-label="分配律 Distributive Law">分配律 Distributive Law</a></li></ul></li><li><a href=#multiplying-out-and-factoring aria-label="Multiplying out and factoring">Multiplying out and factoring</a><ul><li><a href=#sum-of-productsop-form aria-label="Sum of Product(SOP) form">Sum of Product(SOP) form</a></li><li><a href=#product-of-sumpos-form aria-label="Product of Sum(POS) form">Product of Sum(POS) form</a></li><li><a href=#multiplying-out aria-label="Multiplying out：">Multiplying out：</a></li><li><a href=#factoring aria-label=Factoring：>Factoring：</a></li><li><a href=#2-level-realization aria-label="2-level realization">2-level realization</a></li></ul></li><li><a href=#demorgans-laws-and-duality aria-label="DeMorgan&rsquo;s Laws and Duality">DeMorgan&rsquo;s Laws and Duality</a><ul><li><a href=#demorgans-laws aria-label="DeMorgan&rsquo;s Laws">DeMorgan&rsquo;s Laws</a></li><li><a href=#duality aria-label=Duality>Duality</a></li></ul></li><li><a href=#exclusive-or-and-equivalence-operations aria-label="Exclusive-OR and equivalence operations">Exclusive-OR and equivalence operations</a><ul><li><a href=#exlusive-orxoroplus aria-label=Exlusive-OR(XOR,\(\oplus\))>Exlusive-OR(XOR,\(\oplus\))</a></li><li><a href=#equivalenceequiv aria-label=Equivalence(\(\equiv\))>Equivalence(\(\equiv\))</a></li></ul></li><li><a href=#%e9%80%a3%e9%8e%96%e5%be%8b-the-consensus-thorem aria-label="連鎖律 The consensus thorem">連鎖律 The consensus thorem</a></li><li><a href=#%e7%b0%a1%e5%8c%96%e5%b8%83%e6%9e%97%e8%a1%a8%e9%81%94%e5%bc%8f%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=簡化布林表達式的流程>簡化布林表達式的流程</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%ad%89%e6%98%8e%e5%b8%83%e6%9e%97%e8%a1%a8%e9%81%94%e5%bc%8f%e7%9a%84%e6%ad%a3%e7%a2%ba%e6%80%a7 aria-label=如何證明布林表達式的正確性?>如何證明布林表達式的正確性?</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=基本邏輯運算>基本邏輯運算<a hidden class=anchor aria-hidden=true href=#基本邏輯運算>#</a></h1><h2 id=logic-gates>Logic Gates<a hidden class=anchor aria-hidden=true href=#logic-gates>#</a></h2><h3 id=not-gates>Not Gates<a hidden class=anchor aria-hidden=true href=#not-gates>#</a></h3><ul><li>Symbol
<img alt=notgate loading=lazy src=/images/notgate.png></li><li>Truth Table<br>\(
\def\arraystrecth{1.5}\begin{array}{|c|c|}\hline
\text{X}&\overline{\text{X}}\text{or}\text{X&rsquo;}\\\hline
0&amp;1\\\hline
1&amp;0\\\hline
\end{array}
\)</li></ul><h3 id=and-gates>And Gates<a hidden class=anchor aria-hidden=true href=#and-gates>#</a></h3><ul><li>Symbol
<img alt=notgate loading=lazy src=/images/andgate.png></li><li>Truth Table<br>\(
\def\arraystrecth{1.5}\begin{array}{|c|c|c|}\hline
\text{X}&\text{Y}&\text{Z=X}\cdot\text{Y}\\\hline
0&amp;0&amp;0\\\hline
0&amp;1&amp;0\\\hline
1&amp;0&amp;0\\\hline
1&amp;1&amp;1\\\hline
\end{array}
\)</li></ul><h3 id=or-gates>Or Gates<a hidden class=anchor aria-hidden=true href=#or-gates>#</a></h3><ul><li>Symbol
<img alt=notgate loading=lazy src=/images/orgate.png></li><li>Truth Table
\(
\def\arraystrecth{1.5}\begin{array}{|c|c|c|}\hline
\text{X}&\text{Y}&\text{Z=X+Y}\\\hline
0&amp;0&amp;0\\\hline
0&amp;1&amp;1\\\hline
1&amp;0&amp;1\\\hline
1&amp;1&amp;1\\\hline
\end{array}
\)</li></ul><h1 id=布林表達式與真值表boolean-expression-and-truth-table>布林表達式與真值表(Boolean Expression and Truth Table)<a hidden class=anchor aria-hidden=true href=#布林表達式與真值表boolean-expression-and-truth-table>#</a></h1><ul><li>Boolean expression<ul><li>用 <code>'</code> 代表 NOT</li><li>用 <code>+</code> 代表 OR</li><li>用 <code>.</code> 代表 AND</li><li>將輸入用上面的運算子表示成算式，如：\((A+C)(B&rsquo;+C)\)</li></ul></li><li>Truth Table
\(
\def\arraystrecth{1.5}\begin{array}{ccc|cccccc}
A&amp;B&amp;C&amp;B&rsquo;&amp;AB&rsquo;&amp;AB&rsquo;+C&amp;A+C&amp;B&rsquo;+C&(A+C)(B&rsquo;+C)\\\hline
0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;1&amp;0\\
0&amp;0&amp;1&amp;1&amp;0&amp;1&amp;1&amp;1&amp;1\\
0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\
0&amp;1&amp;1&amp;0&amp;0&amp;1&amp;1&amp;1&amp;1\\
1&amp;0&amp;0&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\\
1&amp;0&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\\
1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0\\
1&amp;1&amp;1&amp;0&amp;0&amp;1&amp;1&amp;1&amp;1\\
\end{array}
\)</li></ul><h1 id=基本運算定理>基本運算定理<a hidden class=anchor aria-hidden=true href=#基本運算定理>#</a></h1><h2 id=not-gate-的基本運算定理>NOT gate 的基本運算定理<a hidden class=anchor aria-hidden=true href=#not-gate-的基本運算定理>#</a></h2><p>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
(x&rsquo;)&rsquo;&=&amp;x
\end{array}
}
\)</p><h2 id=and-gate-的基本運算定理>AND gate 的基本運算定理<a hidden class=anchor aria-hidden=true href=#and-gate-的基本運算定理>#</a></h2><p>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
x+0&=&amp;x\\
x+1&=&amp;1\\
x+x&=&amp;x\\
x+x&rsquo;&=&amp;1
\end{array}
}
\)</p><h2 id=or-gate-的基本運算定理>OR gate 的基本運算定理<a hidden class=anchor aria-hidden=true href=#or-gate-的基本運算定理>#</a></h2><p>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
x\cdot 0&=&amp;0\\
x\cdot 1&=&amp;x\\
x\cdot x&=&amp;x\\
x\cdot x&rsquo;&=&amp;0
\end{array}
}
\)</p><h1 id=進階運算定理>進階運算定理<a hidden class=anchor aria-hidden=true href=#進階運算定理>#</a></h1><h2 id=交換律-commutative-law>交換律 Commutative Law<a hidden class=anchor aria-hidden=true href=#交換律-commutative-law>#</a></h2><p>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
xy&=&amp;yx\\
x+y&=&amp;y+x
\end{array}
}
\)</p><h2 id=結合律-associative-law>結合律 Associative Law<a hidden class=anchor aria-hidden=true href=#結合律-associative-law>#</a></h2><p>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
(xy)z&=&amp;x(yz)\\
(x+y)+z&=&amp;x+(y+z)
\end{array}
}
\)</p><h2 id=分配律-distributive-law>分配律 Distributive Law<a hidden class=anchor aria-hidden=true href=#分配律-distributive-law>#</a></h2><p>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
x(y+z)&=&amp;xy+xz\\
x+yz&=&(x+y)(x+z)
\end{array}
}
\)</p><h1 id=multiplying-out-and-factoring>Multiplying out and factoring<a hidden class=anchor aria-hidden=true href=#multiplying-out-and-factoring>#</a></h1><h2 id=sum-of-productsop-form>Sum of Product(SOP) form<a hidden class=anchor aria-hidden=true href=#sum-of-productsop-form>#</a></h2><ul><li>將算式化整成各個輸入端先 <strong>AND</strong> 後再 <strong>OR</strong></li><li>例： \(ABC+AB&rsquo;C+AB&rsquo;C&rsquo;\)</li></ul><h2 id=product-of-sumpos-form>Product of Sum(POS) form<a hidden class=anchor aria-hidden=true href=#product-of-sumpos-form>#</a></h2><ul><li>將算式化整成各個輸入端先 <strong>OR</strong> 後再 <strong>AND</strong></li><li>例： \((A+B+C)(A+B&rsquo;+C)(A+B&rsquo;+C&rsquo;)\)</li></ul><h2 id=multiplying-out>Multiplying out：<a hidden class=anchor aria-hidden=true href=#multiplying-out>#</a></h2><ul><li>將算式化簡成 SOP form</li><li>善用\(\boxed{(A+B)(A+C)=A+BC}\)</li><li>範例：<br>\((A+BC)(A+D+E)\)<br>\(=(A+x)(A+y)\)<br>\(=A+xy\)<br>\(=A+BC(D+E)\)<br>\(=A+BCD+BCE\)</li></ul><h2 id=factoring>Factoring：<a hidden class=anchor aria-hidden=true href=#factoring>#</a></h2><ul><li>將算式化簡成 POS form</li><li>善用\(\boxed{A+BC=(A+B)(A+C)}\)</li><li>範例：<br>\(AB&rsquo;+C&rsquo;D\)<br>\(=(AB&rsquo;+C&rsquo;)(AB&rsquo;+D)\)<br>\(=(A+C&rsquo;)(B&rsquo;+C&rsquo;)(A+D)(B&rsquo;+D))\)</li></ul><h2 id=2-level-realization>2-level realization<a hidden class=anchor aria-hidden=true href=#2-level-realization>#</a></h2><ul><li>利用 Multiplying out 與 Factoring 可以將電路簡化成 2-level circuit</li><li>因為減少了 Delay propagation 可以減少 Total Time Delay</li></ul><h1 id=demorgans-laws-and-duality>DeMorgan&rsquo;s Laws and Duality<a hidden class=anchor aria-hidden=true href=#demorgans-laws-and-duality>#</a></h1><h2 id=demorgans-laws>DeMorgan&rsquo;s Laws<a hidden class=anchor aria-hidden=true href=#demorgans-laws>#</a></h2><ul><li>方法：<ul><li>\(AND\leftrightarrow OR\)</li><li>\(A\leftrightarrow A&rsquo;\)<br>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
(x+y+z+&mldr;)&rsquo;&=&amp;x&rsquo; y&rsquo; z&rsquo;&mldr;\\
(xyz&mldr;)&rsquo;&=&amp;x&rsquo;+y&rsquo;+z&rsquo;&mldr;
\end{array}
}
\)</li></ul></li><li>Truth Table 證明<br>\(
\def\arraystretch{1.5}\begin{array}{ccc|ccc|c|c|c}
x&amp;y&amp;z&amp;x&rsquo;&amp;y&rsquo;&amp;z&rsquo;&amp;x+y+z&(x+y+z)&rsquo;&amp;x&rsquo; y&rsquo; z&rsquo;\\\hline
0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;1&amp;1\\
0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;1&amp;0&amp;0\\
0&amp;1&amp;0&amp;1&amp;0&amp;1&amp;1&amp;0&amp;0\\
0&amp;1&amp;1&amp;1&amp;0&amp;0&amp;1&amp;0&amp;0\\
1&amp;0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;0\\
1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0&amp;0\\
1&amp;1&amp;0&amp;0&amp;0&amp;1&amp;1&amp;0&amp;0\\
1&amp;1&amp;1&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0\\
\end{array}
\)</li><li>範例<br>\([(A&rsquo; B+C&rsquo;)(D&rsquo;+EF&rsquo;)+GH+W]&rsquo;\)<br>\(=[(A+B&rsquo;)C+D(E&rsquo;+F)] (G&rsquo;+H&rsquo;)W&rsquo;\)</li></ul><h2 id=duality>Duality<a hidden class=anchor aria-hidden=true href=#duality>#</a></h2><ul><li><p>方法</p><ul><li>\(AND\leftrightarrow OR\)</li><li>\(0\leftrightarrow 1\)<br>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{cccccccccc}
[f(&amp;x_1,&amp;x_2,&&mldr;,&amp;x_n,&amp;0,&amp;1,&+,&\cdot&)]^D\\
=f(&amp;x_1,&amp;x_2,&&mldr;,&amp;x_n,&amp;1,&amp;0,&\cdot,&+&)
\end{array}
}
\)</li></ul></li><li><p>性質</p><ul><li>\(\boxed{F=G\rightarrow F^D=G^D}\)</li></ul></li><li><p>範例<br>\((x+y&rsquo;)y=xy\rightarrow x\cdot y&rsquo;+y=x+y\)</p></li><li><p>回顧分配律 Distributive Law，即為 Duality 的表現。<br>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
x(y+z)&=&amp;xy+xz\\
x+yz&=&(x+y)(x+z)
\end{array}
}
\)</p></li></ul><h1 id=exclusive-or-and-equivalence-operations>Exclusive-OR and equivalence operations<a hidden class=anchor aria-hidden=true href=#exclusive-or-and-equivalence-operations>#</a></h1><h2 id=exlusive-orxoroplus>Exlusive-OR(XOR,\(\oplus\))<a hidden class=anchor aria-hidden=true href=#exlusive-orxoroplus>#</a></h2><ul><li>Symbol
<img alt=xorgate loading=lazy src=/images/xorgate.png></li><li>Truth Table<br>\(
\def\arraystrecth{1.5}\begin{array}{|c|c|c|}\hline
\text{X}&\text{Y}&\text{Z=X}\oplus\text{Y}\\\hline
0&amp;0&amp;0\\\hline
0&amp;1&amp;1\\\hline
1&amp;0&amp;1\\\hline
1&amp;1&amp;0\\\hline
\end{array}
\)</li><li>性質：<br>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
x\oplus 0&=&amp;x\\
x\oplus 1&=&amp;x&rsquo;\\
x\oplus x&=&amp;0\\
x\oplus x&rsquo;&=&amp;1\\
x\oplus y&=&amp;y\oplus x\\
(x\oplus y)\oplus z&=&amp;x\oplus (y\oplus z)\\
x(y\oplus z)&=&amp;xy\oplus xz\\
x\oplus y&=&amp;xy+x&rsquo; y'
\end{array}
}
\)</li></ul><h2 id=equivalenceequiv>Equivalence(\(\equiv\))<a hidden class=anchor aria-hidden=true href=#equivalenceequiv>#</a></h2><ul><li>Symbol
<img alt=equivgate loading=lazy src=/images/equivgate.png></li><li>Truth Table<br>\(
\def\arraystrecth{1.5}\begin{array}{|c|c|c|}\hline
\text{X}&\text{Y}&\text{Z=X}\equiv{Y}\\\hline
0&amp;0&amp;1\\\hline
0&amp;1&amp;0\\\hline
1&amp;0&amp;0\\\hline
1&amp;1&amp;1\\\hline
\end{array}
\)</li><li>性質：<br>\(
\boxed{
\def\arraystretch{1.5}\begin{array}{ccc}
x\equiv 0&=&amp;x&rsquo;\\
x\equiv 1&=&amp;x\\
x\equiv x&=&amp;1\\
x\equiv x&rsquo;&=&amp;0\\
x\equiv y&=&amp;y\equiv x\\
(x\equiv y)\equiv z&=&amp;x\equiv (y\equiv z)\\
x(y\equiv z)&=&amp;xy\equiv xz\\
x\equiv y&=&amp;xy&rsquo;+x&rsquo; y
\end{array}
}
\)</li></ul><h1 id=連鎖律-the-consensus-thorem>連鎖律 The consensus thorem<a hidden class=anchor aria-hidden=true href=#連鎖律-the-consensus-thorem>#</a></h1><ul><li>公式：<ul><li>\(\boxed{xy+x&rsquo; z+yz=xy+x&rsquo; z}\)</li><li>\(\boxed{(x+y)(x&rsquo;+z)(y+z)=(x+y)(x&rsquo;+z)}\)</li></ul></li><li>證明：<br>\(xy+x&rsquo; z+yz\)<br>\(=xy+x&rsquo; z + (x+x&rsquo;)yz\)<br>\(=xy+xyz+x&rsquo; z+x&rsquo; yz\)<br>\(=xy(1+z)+x&rsquo; z(1+y)\)<br>\(=xy+x&rsquo; z\)</li></ul><h1 id=簡化布林表達式的流程>簡化布林表達式的流程<a hidden class=anchor aria-hidden=true href=#簡化布林表達式的流程>#</a></h1><ol><li>利用 \(\boxed{xy+xy&rsquo;=x(y+y&rsquo;)=x}\)(AND性質)</li><li>利用 \(\boxed{x+xy+&mldr;=x(1+y+&mldr;)=x}\)(OR性質)</li><li>利用 \(\boxed{xy+x&rsquo; z+yz=xy+x&rsquo;z }\)(連鎖律)</li><li>利用 \(\boxed{x+x&rsquo;y=x(y+y&rsquo;)+x&rsquo;y=xy+xy&rsquo;+x&rsquo; y=x+y}\)</li><li>必要時加入 redundant terms</li></ol><ul><li><a href=https://intervalrain.github.io/logicdesign/lec3/>Lec3</a>會使用圖表法，較不容易出錯。</li></ul><h1 id=如何證明布林表達式的正確性>如何證明布林表達式的正確性?<a hidden class=anchor aria-hidden=true href=#如何證明布林表達式的正確性>#</a></h1><ol><li>建構 Truth Table</li><li>簡化 LHS 和 RHS</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/logic-design/>Logic Design</a></li></ul></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>