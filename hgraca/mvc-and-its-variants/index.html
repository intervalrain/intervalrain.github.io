<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[IT] MVC 及其變形 | Rain Hu's Workspace</title><meta name=keywords content="Software Architecture"><meta name=description content="創立一個可維護的應用程式一直是程式設計的一項長期挑戰。
不久前，我在一家公司工作，其核心業務應用是一個 SaaS 平台，被幾千個客戶公司使用，這項應用程式已經運營了三年，其中的程式碼混雜了 HTML, CSS, 業務邏輯及 SQL，當然，在應用程式推出後的兩年，公司決定開始重構。儘管我們知道這樣的做法是不好的，且我們也知道如何避免，但是這樣的情況還是時常發生。
然後，回溯到 1970 年代，混合職責是很常見的做法，且人們仍在努力尋找如何改進。隨著應用程式的複雜性提升，對 UI 的更動必然會導致業務邏輯的更改，從而增加了修改的複雜度、執行的時間與 bug 出現的可能性。(因為會有更多的程式碼被更改)。
1979 - Model-View-Controller

為了解決上述問題，Trygve Reenskaug 於 1979 年提出了 MVC 架構，以此來將關注點分離，將 UI 與業務邏輯分離。該模式被應用於 1973年出現的桌面 GUI。
MVC 架構將程式分為三個部分：

Model: 模型，代表了商業邏輯。
View: 視圖，代表了 UI 中的組件，如 button, text box 等。
Controller: 控制器，負責協調視圖和模型之間的配合，這意味著它：

決定要顯示哪些視圖，以及使用什麼數據。
將使用者行為轉化為業務邏輯。




A model could be a single object (rather uninteresting), or it could be some structure of objects. - Trygve Reenskaug 1979, MVC
一個模型可以是單一物件(相對無趣)，或可以是一些物件的結構。 - 特里格維‧倫斯考 1979, MVC"><meta name=author content="hgraca"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/hgraca/mvc-and-its-variants/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/hgraca/mvc-and-its-variants/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[IT] MVC 及其變形"><meta property="og:description" content="創立一個可維護的應用程式一直是程式設計的一項長期挑戰。
不久前，我在一家公司工作，其核心業務應用是一個 SaaS 平台，被幾千個客戶公司使用，這項應用程式已經運營了三年，其中的程式碼混雜了 HTML, CSS, 業務邏輯及 SQL，當然，在應用程式推出後的兩年，公司決定開始重構。儘管我們知道這樣的做法是不好的，且我們也知道如何避免，但是這樣的情況還是時常發生。
然後，回溯到 1970 年代，混合職責是很常見的做法，且人們仍在努力尋找如何改進。隨著應用程式的複雜性提升，對 UI 的更動必然會導致業務邏輯的更改，從而增加了修改的複雜度、執行的時間與 bug 出現的可能性。(因為會有更多的程式碼被更改)。
1979 - Model-View-Controller 為了解決上述問題，Trygve Reenskaug 於 1979 年提出了 MVC 架構，以此來將關注點分離，將 UI 與業務邏輯分離。該模式被應用於 1973年出現的桌面 GUI。
MVC 架構將程式分為三個部分：
Model: 模型，代表了商業邏輯。 View: 視圖，代表了 UI 中的組件，如 button, text box 等。 Controller: 控制器，負責協調視圖和模型之間的配合，這意味著它： 決定要顯示哪些視圖，以及使用什麼數據。 將使用者行為轉化為業務邏輯。 A model could be a single object (rather uninteresting), or it could be some structure of objects. - Trygve Reenskaug 1979, MVC
一個模型可以是單一物件(相對無趣)，或可以是一些物件的結構。 - 特里格維‧倫斯考 1979, MVC"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="hgraca"><meta property="article:published_time" content="2023-10-19T10:54:19+08:00"><meta property="article:modified_time" content="2023-10-19T10:54:19+08:00"><meta property="article:tag" content="Software Architectrue"><meta name=twitter:card content="summary"><meta name=twitter:title content="[IT] MVC 及其變形"><meta name=twitter:description content="創立一個可維護的應用程式一直是程式設計的一項長期挑戰。
不久前，我在一家公司工作，其核心業務應用是一個 SaaS 平台，被幾千個客戶公司使用，這項應用程式已經運營了三年，其中的程式碼混雜了 HTML, CSS, 業務邏輯及 SQL，當然，在應用程式推出後的兩年，公司決定開始重構。儘管我們知道這樣的做法是不好的，且我們也知道如何避免，但是這樣的情況還是時常發生。
然後，回溯到 1970 年代，混合職責是很常見的做法，且人們仍在努力尋找如何改進。隨著應用程式的複雜性提升，對 UI 的更動必然會導致業務邏輯的更改，從而增加了修改的複雜度、執行的時間與 bug 出現的可能性。(因為會有更多的程式碼被更改)。
1979 - Model-View-Controller

為了解決上述問題，Trygve Reenskaug 於 1979 年提出了 MVC 架構，以此來將關注點分離，將 UI 與業務邏輯分離。該模式被應用於 1973年出現的桌面 GUI。
MVC 架構將程式分為三個部分：

Model: 模型，代表了商業邏輯。
View: 視圖，代表了 UI 中的組件，如 button, text box 等。
Controller: 控制器，負責協調視圖和模型之間的配合，這意味著它：

決定要顯示哪些視圖，以及使用什麼數據。
將使用者行為轉化為業務邏輯。




A model could be a single object (rather uninteresting), or it could be some structure of objects. - Trygve Reenskaug 1979, MVC
一個模型可以是單一物件(相對無趣)，或可以是一些物件的結構。 - 特里格維‧倫斯考 1979, MVC"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Hgracas","item":"https://intervalrain.github.io/hgraca/"},{"@type":"ListItem","position":2,"name":"[IT] MVC 及其變形","item":"https://intervalrain.github.io/hgraca/mvc-and-its-variants/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[IT] MVC 及其變形","name":"[IT] MVC 及其變形","description":"創立一個可維護的應用程式一直是程式設計的一項長期挑戰。\n不久前，我在一家公司工作，其核心業務應用是一個 SaaS 平台，被幾千個客戶公司使用，這項應用程式已經運營了三年，其中的程式碼混雜了 HTML, CSS, 業務邏輯及 SQL，當然，在應用程式推出後的兩年，公司決定開始重構。儘管我們知道這樣的做法是不好的，且我們也知道如何避免，但是這樣的情況還是時常發生。\n然後，回溯到 1970 年代，混合職責是很常見的做法，且人們仍在努力尋找如何改進。隨著應用程式的複雜性提升，對 UI 的更動必然會導致業務邏輯的更改，從而增加了修改的複雜度、執行的時間與 bug 出現的可能性。(因為會有更多的程式碼被更改)。\n1979 - Model-View-Controller 為了解決上述問題，Trygve Reenskaug 於 1979 年提出了 MVC 架構，以此來將關注點分離，將 UI 與業務邏輯分離。該模式被應用於 1973年出現的桌面 GUI。\nMVC 架構將程式分為三個部分：\nModel: 模型，代表了商業邏輯。 View: 視圖，代表了 UI 中的組件，如 button, text box 等。 Controller: 控制器，負責協調視圖和模型之間的配合，這意味著它： 決定要顯示哪些視圖，以及使用什麼數據。 將使用者行為轉化為業務邏輯。 A model could be a single object (rather uninteresting), or it could be some structure of objects. - Trygve Reenskaug 1979, MVC\n一個模型可以是單一物件(相對無趣)，或可以是一些物件的結構。 - 特里格維‧倫斯考 1979, MVC\n","keywords":["Software Architecture"],"articleBody":"創立一個可維護的應用程式一直是程式設計的一項長期挑戰。\n不久前，我在一家公司工作，其核心業務應用是一個 SaaS 平台，被幾千個客戶公司使用，這項應用程式已經運營了三年，其中的程式碼混雜了 HTML, CSS, 業務邏輯及 SQL，當然，在應用程式推出後的兩年，公司決定開始重構。儘管我們知道這樣的做法是不好的，且我們也知道如何避免，但是這樣的情況還是時常發生。\n然後，回溯到 1970 年代，混合職責是很常見的做法，且人們仍在努力尋找如何改進。隨著應用程式的複雜性提升，對 UI 的更動必然會導致業務邏輯的更改，從而增加了修改的複雜度、執行的時間與 bug 出現的可能性。(因為會有更多的程式碼被更改)。\n1979 - Model-View-Controller 為了解決上述問題，Trygve Reenskaug 於 1979 年提出了 MVC 架構，以此來將關注點分離，將 UI 與業務邏輯分離。該模式被應用於 1973年出現的桌面 GUI。\nMVC 架構將程式分為三個部分：\nModel: 模型，代表了商業邏輯。 View: 視圖，代表了 UI 中的組件，如 button, text box 等。 Controller: 控制器，負責協調視圖和模型之間的配合，這意味著它： 決定要顯示哪些視圖，以及使用什麼數據。 將使用者行為轉化為業務邏輯。 A model could be a single object (rather uninteresting), or it could be some structure of objects. - Trygve Reenskaug 1979, MVC\n一個模型可以是單一物件(相對無趣)，或可以是一些物件的結構。 - 特里格維‧倫斯考 1979, MVC\n其他重要且經典的 MVC 概念有：\n視圖直接使用模型數據物件(model data objects)，以顯示其數據。 當模型數據發生變化時，它會觸發一個事件，立即更新視圖(1997年，還沒有HTTP)。 通常，每個視圖都會關聯到一個控制器。 每個螢幕可以包含數對的視圖與控制器。 每個控制器可能有多個視圖。 今日我們熟悉的 HTTP Request \u0026 Response 模式，並未使用這樣的 MVC 風格。因為在這種情境下，流程是從視圖到控制器的，如同我們熟悉的，但在另一個方向上，它直接從模型流向視圖，而不經過控制器。\n此外，在現在的 Request \u0026 Response 模式中，當數據發生變化時，並不會觸發在瀏覽器中的視圖進行更新(儘管這可以透過使用 web sockets 來實現)。要查看更新的數據，用戶需要發出新的 request，接著數據才能透過控制器返回。\n1987/2000 - PAC/Hierarchical Model-View-Controller PAC，也被稱為 HMVC，為了提高模組化，將 UI 部分做 widgetization。\n例如，當我們有一個視圖，其中的一個部分在其他多個視圖中或甚至在同一個視圖中以完全相同的格視重複使用。一個實際的例子是網頁中的 RSS，它在多個頁面中重複被使用。\n使用 HMVC，處理主要 request 將會將次要的 request 轉發給其它控制器，以獲得 widget 的渲染，然後將其融入主視圖的渲染中。\n就我個人而言，我在 HTTP Request \u0026 Response 模式中遇過幾次這種案例，但我發現讓 UI 透過 AJAX 呼叫控制器來渲染 widget 是更簡單的方法，因為它保留了模組化的好處，且不會因嵌套呼叫控制器而增加複雜性，這樣的次要請求可以在像 Varnish 這樣的東西中被緩存，這是一個加分的部分。\n1996 - Model-View-Presenter MVC 架構為當時的程式設計提供了重大的改進，然而，隨著應用程式複雜性的增加，對進一步解耦的需求也隨之增加。\n在 1996 年，IBM 子公司 Taligent 公開了他們基於 MVC 架構開發的 MVP 架構，想法是進一步將模型與 UI 進行關注點分離：\n視圖是被動的，且對模型一無所知。 專注於控制器(presenter)，它們不包含任何業務遲輯，只是在模型中調用命令、查詢，將原始數據傳遞給視圖。 數據的變化並不會直接觸發視圖的更新：它會透過 presenter 進行，然後 presenter 再更新視圖。這樣可以讓 presenter 在執行視圖更新前執行額外跟呈現相關的邏輯。例如，更新與數據庫中發生變化的數據相關的數據。 每個視圖都有一個單獨的 presenter。 這已經更接近我們在今日 Request \u0026 Response 模式中看到的：流程總是通過 Controller/Presenter。然而，presenter 仍然不會主動更新視圖，它總是需要執行新的 request 才能使變更可見。\n在 MVP 中，presenter 又被稱為監督控制器(supervisor controller)。\n2005 - Model-View-ViewModel 再次，源於應用程式的複雜性增加，2005年，微軟的 WPF 和 Silverlight 的架構師 John Gossman 宣布了 MVVM 架構，其目標是進一步將 UI 設計與程式碼分離，並提供從視圖到數據模型的數據綁定。\n[MVVM] is a variation [of MVC] that is tailored for modern UI development platforms where the View is the responsibility of a designer rather than a classic developer. […] the UI part of the application is being developed using different tools, languages and by a different person than is the business logic or data backend. - John Gossman 2005, Introduction to Model/View/ViewModel pattern [MVVM]是[ MVC]的一種變體，專為現代UI開發平台量身定制，其中視圖是由設計師而非傳統開發人員負責。[…] 應用程序的UI部分是使用不同的工具、語言以及由與業務邏輯或數據後端不同的人來開發的。 - 約翰‧高斯曼 2005，模型/視圖/視圖模型模式介紹\n其中，Controller 被 ViewModel 所取代。\n[The View] encodes the keyboard shortcuts and the controls themselves manage the interaction with the input devices that is the responsibility of Controller in MVC (what exactly happened to Controller in modern GUI development is a long digression…I tend to think it just faded into the background. It is still there, but we don’t have to think about it as much as we did in 1979). - John Gossman 2005, Introduction to Model/View/ViewModel pattern [視圖]編碼鍵盤快捷鍵，而控制項本身則管理與輸入設備的互動，這是MVC中控制器的責任（現代GUI開發中控制器究竟發生了什麼，是一個長篇的離題…我傾向於認為它只是淡出了背景。它仍然存在，但我們不必像1979年那樣多考慮它）。 - 約翰‧高斯曼 2005，模型/視圖/視圖模型模式介紹\nMVVM 的概念是：\n一個 ViewModel 只對應一個 View，反之亦然。 將視圖邏輯移至 ViewModel 以簡化視圖。 視圖中使用的數據與 ViewModel 中的數據之間的一對一映射。 將 ViewModel 中的數據與 View 中的數據綁定，以便當 ViewModel 中的數據發生變化時，它會立即在 View 中反映出來。 就像在原始的 MVC 模式中一樣，這種方法在傳統的 request \u0026 response 模式中是不可能的，因為 ViewModel 無法主動更新視圖（除非使用web socket），而 MVVM 需要它。此外，ViewModel 具有與視圖中使用的數據匹配的屬性，並非控制器的常見做法。\nModel-View-Presenter-ViewModel 在為雲端建立複雜的企業應用程式時，我傾向於將應用程式的使用者介面結構理性化為 M-V-P-VM，其中的 ViewModel 就是 Martin Fowler 在 2004 年所稱的 Presentation Model。\nModel 模型 一組包含所有業務邏輯和使用案例的類別。\nView 視圖 一個模板，用於使用模板引擎生成 HTML。\nViewModel 視圖模型(aka Presentation Model) 從查詢（或從中提取原始數據的模型實體）接收原始數據，並保留該數據以在模板中使用。它還封裝了複雜的呈現邏輯，以簡化模板。我發現使用 ViewModel 尤其重要，因為我們將不會被誘惑在模板中使用實體，這使我們能夠完全隔離視圖和模型：\n模型中的變化（即實體結構的變化）可能會影響到 ViewModel，但不會影響模板； 複雜的呈現邏輯不會滲透到領域中（即，在業務實體中創建與呈現邏輯專屬相關的方法），因為我們可以將其封裝在 ViewModel 中。 模板的依賴性因必須在 ViewModel 中設定而變得明確。使這些依賴性可見可以幫助我們，例如，決定應該從數據庫中急切加載什麼以防止 N+1 問題。 Presenter\n接收一個 HTTP 請求，觸發一個命令或查詢，使用查詢返回的數據，一個 ViewModel，一個模板和一個模板引擎來生成HTML並將其發送回客戶端。所有視圖交互都通過一個 presenter 進行。\n\u003c?php // src/UI/Admin/Some/Controller/Namespace/Detail/SomeEntityDetailController.php namespace UI\\Admin\\Some\\Controller\\Namespace\\Detail; // use ... final class SomeEntityDetailController { /** * @var SomeRepositoryInterface */ private $someRepository; /** * @var RelatedRepositoryInterface */ private $relatedRepository; /** * @var TemplateEngineInterface */ private $templateEngine; public function __construct( SomeRepositoryInterface $someRepository, RelatedRepositoryInterface $relatedRepository, TemplateEngineInterface $templateEngine ) { $this-\u003esomeRepository = $someRepository; $this-\u003erelatedRepository = $relatedRepository; $this-\u003etemplateEngine = $templateEngine; } /** * @return mixed */ public function get(int $someEntityId) { $mainEntity = $this-\u003esomeRepository-\u003egetById($someEntityId); $relatedEntityList = $this-\u003erelatedRepository-\u003egetByParentId($someEntityId); return $this-\u003etemplateEngine-\u003erender( '@Some/Controller/Namespace/Detail/details.html.twig', new DetailsViewModel($mainEntity, $relatedEntityList) ); } } \u003c?php // src/UI/Admin/Some/Controller/Namespace/Detail/DetailsViewModel.php namespace UI\\Admin\\Some\\Controller\\Namespace\\Detail; // use ... final class DetailsViewModel implements TemplateViewModelInterface { /** * @var array */ private $mainEntity = []; /** * @var array */ private $relatedEntityList = []; /** * @var bool */ private $shouldDisplayFancyDialog = false; /** * @var bool */ private $canEditData = false; /** * @param SomeEntity $mainEntity * @param RelatedEntity[] $relatedEntityList */ public function __construct(SomeEntity $mainEntity, array $relatedEntityList) { $this-\u003emainEntity = [ 'name' =\u003e $mainEntity-\u003egetName(), 'description' =\u003e $mainEntity-\u003egetResume(), ]; foreach ($relatedEntityList as $relatedEntity) { $this-\u003erelatedEntityList[] = [ 'title' =\u003e $relatedEntity-\u003egetTitle(), 'subtitle' =\u003e $relatedEntity-\u003egetSubtitle(), ]; } $this-\u003eshouldDisplayFancyDialog = /* ... some complex conditional using the entities data ... */ ; $this-\u003ecanEditData = /* ... another complex conditional using the entities data ... */ ; } public function getMainEntity(): array { return $this-\u003emainEntity; } public function getRelatedEntityList(): array { return $this-\u003erelatedEntityList; } public function shouldDisplayFancyDialog(): bool { return $this-\u003eshouldDisplayFancyDialog; } public function canEditData(): bool { return $this-\u003ecanEditData; } } 模板和 ViewModel 有一對一的對應關係，這意味著一個視圖只能與特定的 ViewModel 一起使用，反之亦然。這實際上甚至讓我想到，也許我們可以將模板和 ViewModel 封裝在一個視圖物件中，有效地將控制器與模板和 ViewModel 解耦，使其依賴於一個通用的視圖介面，但我從未嘗試過這種方法。\n結論 我們可能會在網路上找到 MVC 的其他變形。然而，以上是我認為跟我工作相關且我認為相對比較有趣的幾種案例。\n儘管如此，我在這裡引用的模式是為桌面應用程式和/或豐富客戶端的情境而創建的，因此它們並不總是 100% 適合 Request \u0026 Response 模式。\n如果您正在進行企業雲應用，並且您正在使用 MVC，那麼您很可能實際上使用的是更接近 MVP 的東西，但無論如何，我的觀點並不是要堅持遵循 MVC 的特定變體或了解所有名稱並對此嚴格要求，我的觀點是我們應該從所有這些中學習，以便我們可以根據需要使用和調整。最終的目標是，像往常一樣，低耦合和高內聚：關注點分離。\n","wordCount":"677","inLanguage":"zh-tw","datePublished":"2023-10-19T10:54:19+08:00","dateModified":"2023-10-19T10:54:19+08:00","author":{"@type":"Person","name":"hgraca"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/hgraca/mvc-and-its-variants/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/hgraca/>Hgracas</a></div><h1 class="post-title entry-hint-parent">[IT] MVC 及其變形</h1><div class=post-meta><span title='2023-10-19 10:54:19 +0800 +0800'>October 19, 2023</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;hgraca&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//hgraca/mvc-and-its-variants.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#1979---model-view-controller aria-label="1979 - Model-View-Controller">1979 - Model-View-Controller</a></li><li><a href=#19872000---pachierarchical-model-view-controller aria-label="1987/2000 - PAC/Hierarchical Model-View-Controller">1987/2000 - PAC/Hierarchical Model-View-Controller</a></li><li><a href=#1996---model-view-presenter aria-label="1996 - Model-View-Presenter">1996 - Model-View-Presenter</a></li><li><a href=#2005---model-view-viewmodel aria-label="2005 - Model-View-ViewModel">2005 - Model-View-ViewModel</a></li><li><a href=#model-view-presenter-viewmodel aria-label=Model-View-Presenter-ViewModel>Model-View-Presenter-ViewModel</a></li><li><a href=#%e7%b5%90%e8%ab%96 aria-label=結論>結論</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>創立一個可維護的應用程式一直是程式設計的一項長期挑戰。</p><p>不久前，我在一家公司工作，其核心業務應用是一個 SaaS 平台，被幾千個客戶公司使用，這項應用程式已經運營了三年，其中的程式碼混雜了 HTML, CSS, 業務邏輯及 SQL，當然，在應用程式推出後的兩年，公司決定開始重構。儘管我們知道這樣的做法是不好的，且我們也知道如何避免，但是這樣的情況還是時常發生。</p><p>然後，回溯到 1970 年代，混合職責是很常見的做法，且人們仍在努力尋找如何改進。隨著應用程式的複雜性提升，對 UI 的更動必然會導致業務邏輯的更改，從而增加了修改的複雜度、執行的時間與 bug 出現的可能性。(因為會有更多的程式碼被更改)。</p><h1 id=1979---model-view-controller>1979 - Model-View-Controller<a hidden class=anchor aria-hidden=true href=#1979---model-view-controller>#</a></h1><p><img alt=mvc loading=lazy src=https://herbertograca.files.wordpress.com/2017/04/mvc.jpg>
為了解決上述問題，Trygve Reenskaug 於 1979 年提出了 MVC 架構，以此來將關注點分離，將 UI 與業務邏輯分離。該模式被應用於 1973年出現的桌面 GUI。</p><p>MVC 架構將程式分為三個部分：</p><ul><li><strong>Model</strong>: 模型，代表了商業邏輯。</li><li><strong>View</strong>: 視圖，代表了 UI 中的組件，如 button, text box 等。</li><li><strong>Controller</strong>: 控制器，負責協調視圖和模型之間的配合，這意味著它：<ul><li>決定要顯示哪些視圖，以及使用什麼數據。</li><li>將使用者行為轉化為業務邏輯。</li></ul></li></ul><blockquote><p><em>A model could be a single object (rather uninteresting), or it could be some structure of objects.</em> - <em><strong>Trygve Reenskaug 1979, MVC</strong></em><br><em>一個模型可以是單一物件(相對無趣)，或可以是一些物件的結構。</em> - <em><strong>特里格維‧倫斯考 1979, MVC</strong></em></p></blockquote><p>其他重要且經典的 MVC 概念有：</p><ol><li>視圖直接使用模型數據物件(model data objects)，以顯示其數據。</li><li>當模型數據發生變化時，它會觸發一個事件，立即更新視圖(1997年，還沒有HTTP)。</li><li>通常，每個視圖都會關聯到一個控制器。</li><li>每個螢幕可以包含數對的視圖與控制器。</li><li>每個控制器可能有多個視圖。</li></ol><p>今日我們熟悉的 HTTP Request & Response 模式，並未使用這樣的 MVC 風格。因為在這種情境下，流程是從視圖到控制器的，如同我們熟悉的，但在另一個方向上，它直接從模型流向視圖，而不經過控制器。</p><p>此外，在現在的 Request & Response 模式中，當數據發生變化時，並不會觸發在瀏覽器中的視圖進行更新(儘管這可以透過使用 web sockets 來實現)。要查看更新的數據，用戶需要發出新的 request，接著數據才能透過控制器返回。</p><h1 id=19872000---pachierarchical-model-view-controller>1987/2000 - PAC/Hierarchical Model-View-Controller<a hidden class=anchor aria-hidden=true href=#19872000---pachierarchical-model-view-controller>#</a></h1><p><img alt=h-mvc loading=lazy src="https://herbertograca.files.wordpress.com/2017/04/hmvc.png?w=486&h=450">
PAC，也被稱為 HMVC，為了提高模組化，將 UI 部分做 <strong>widgetization</strong>。</p><p>例如，當我們有一個視圖，其中的一個部分在其他多個視圖中或甚至在同一個視圖中以完全相同的格視重複使用。一個實際的例子是網頁中的 RSS，它在多個頁面中重複被使用。</p><p>使用 HMVC，處理主要 request 將會將次要的 request 轉發給其它控制器，以獲得 widget 的渲染，然後將其融入主視圖的渲染中。</p><p>就我個人而言，我在 HTTP Request & Response 模式中遇過幾次這種案例，但我發現讓 UI 透過 AJAX 呼叫控制器來渲染 widget 是更簡單的方法，因為它保留了模組化的好處，且不會因嵌套呼叫控制器而增加複雜性，這樣的次要請求可以在像 Varnish 這樣的東西中被緩存，這是一個加分的部分。</p><h1 id=1996---model-view-presenter>1996 - Model-View-Presenter<a hidden class=anchor aria-hidden=true href=#1996---model-view-presenter>#</a></h1><p><img alt=MVP loading=lazy src=https://herbertograca.files.wordpress.com/2017/04/mvp.jpg>
MVC 架構為當時的程式設計提供了重大的改進，然而，隨著應用程式複雜性的增加，對進一步解耦的需求也隨之增加。</p><p>在 1996 年，IBM 子公司 Taligent 公開了他們基於 MVC 架構開發的 MVP 架構，想法是進一步將模型與 UI 進行關注點分離：</p><ul><li>視圖是被動的，且對模型一無所知。</li><li>專注於控制器(presenter)，它們不包含任何業務遲輯，只是在模型中調用命令、查詢，將原始數據傳遞給視圖。</li><li>數據的變化並不會直接觸發視圖的更新：它會透過 presenter 進行，然後 presenter 再更新視圖。這樣可以讓 presenter 在執行視圖更新前執行額外跟呈現相關的邏輯。例如，更新與數據庫中發生變化的數據相關的數據。</li><li>每個視圖都有一個單獨的 presenter。</li></ul><p>這已經更接近我們在今日 Request & Response 模式中看到的：流程總是通過 Controller/Presenter。然而，presenter 仍然不會主動更新視圖，它總是需要執行新的 request 才能使變更可見。</p><p>在 MVP 中，presenter 又被稱為<strong>監督控制器(supervisor controller)</strong>。</p><h1 id=2005---model-view-viewmodel>2005 - Model-View-ViewModel<a hidden class=anchor aria-hidden=true href=#2005---model-view-viewmodel>#</a></h1><p><img alt=MVVM loading=lazy src=https://herbertograca.files.wordpress.com/2017/04/mvvm.jpg>
再次，源於應用程式的複雜性增加，2005年，微軟的 WPF 和 Silverlight 的架構師 John Gossman 宣布了 MVVM 架構，其目標是進一步將 UI 設計與程式碼分離，並提供從視圖到數據模型的數據綁定。</p><blockquote><p><em>[MVVM] is a variation [of MVC] that is tailored for modern UI development platforms where the View is the responsibility of a designer rather than a classic developer. […] the UI part of the application is being developed using different tools, languages and by a different person than is the business logic or data backend.</em> - <em><strong>John Gossman 2005, Introduction to Model/View/ViewModel pattern</strong></em>
<em>[MVVM]是[ MVC]的一種變體，專為現代UI開發平台量身定制，其中視圖是由設計師而非傳統開發人員負責。[…] 應用程序的UI部分是使用不同的工具、語言以及由與業務邏輯或數據後端不同的人來開發的。</em> - <em><strong>約翰‧高斯曼 2005，模型/視圖/視圖模型模式介紹</strong></em></p></blockquote><p>其中，Controller 被 ViewModel 所取代。</p><blockquote><p><em>[The View] encodes the keyboard shortcuts and the controls themselves manage the interaction with the input devices that is the responsibility of Controller in MVC (what exactly happened to Controller in modern GUI development is a long digression…I tend to think it just faded into the background. It is still there, but we don’t have to think about it as much as we did in 1979).</em> - <em><strong>John Gossman 2005, Introduction to Model/View/ViewModel pattern</strong></em>
<em>[視圖]編碼鍵盤快捷鍵，而控制項本身則管理與輸入設備的互動，這是MVC中控制器的責任（現代GUI開發中控制器究竟發生了什麼，是一個長篇的離題&mldr;我傾向於認為它只是淡出了背景。它仍然存在，但我們不必像1979年那樣多考慮它）。</em> - <em><strong>約翰‧高斯曼 2005，模型/視圖/視圖模型模式介紹</strong></em></p></blockquote><p>MVVM 的概念是：</p><ul><li>一個 ViewModel 只對應一個 View，反之亦然。</li><li>將視圖邏輯移至 ViewModel 以簡化視圖。</li><li>視圖中使用的數據與 ViewModel 中的數據之間的一對一映射。</li><li>將 ViewModel 中的數據與 View 中的數據綁定，以便當 ViewModel 中的數據發生變化時，它會立即在 View 中反映出來。</li></ul><p>就像在原始的 MVC 模式中一樣，這種方法在傳統的 request & response 模式中是不可能的，因為 ViewModel 無法主動更新視圖（除非使用web socket），而 MVVM 需要它。此外，ViewModel 具有與視圖中使用的數據匹配的屬性，並非控制器的常見做法。</p><h1 id=model-view-presenter-viewmodel>Model-View-Presenter-ViewModel<a hidden class=anchor aria-hidden=true href=#model-view-presenter-viewmodel>#</a></h1><p><img alt=MVPVM loading=lazy src=https://herbertograca.files.wordpress.com/2017/07/m-v-p-vm1.png>
在為雲端建立複雜的企業應用程式時，我傾向於將應用程式的使用者介面結構理性化為 M-V-P-VM，其中的 ViewModel 就是 Martin Fowler 在 2004 年所稱的 Presentation Model。</p><ul><li><p><strong>Model 模型</strong>
一組包含所有業務邏輯和使用案例的類別。</p></li><li><p><strong>View 視圖</strong>
一個模板，用於使用模板引擎生成 HTML。</p></li><li><p><strong>ViewModel 視圖模型</strong>(aka Presentation Model)
從查詢（或從中提取原始數據的模型實體）接收原始數據，並保留該數據以在模板中使用。它還封裝了複雜的呈現邏輯，以簡化模板。我發現使用 ViewModel 尤其重要，因為我們將不會被誘惑在模板中使用實體，這使我們能夠完全隔離視圖和模型：</p><ul><li>模型中的變化（即實體結構的變化）可能會影響到 ViewModel，但不會影響模板；</li><li>複雜的呈現邏輯不會滲透到領域中（即，在業務實體中創建與呈現邏輯專屬相關的方法），因為我們可以將其封裝在 ViewModel 中。</li><li>模板的依賴性因必須在 ViewModel 中設定而變得明確。使這些依賴性可見可以幫助我們，例如，決定應該從數據庫中急切加載什麼以防止 N+1 問題。</li></ul></li><li><p><strong>Presenter</strong></p></li><li><p>接收一個 HTTP 請求，觸發一個命令或查詢，使用查詢返回的數據，一個 ViewModel，一個模板和一個模板引擎來生成HTML並將其發送回客戶端。所有視圖交互都通過一個 presenter 進行。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/UI/Admin/Some/Controller/Namespace/Detail/SomeEntityDetailController.php
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> <span style=color:#a6e22e>UI\Admin\Some\Controller\Namespace\Detail</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// use ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SomeEntityDetailController</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @var SomeRepositoryInterface
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> $someRepository;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @var RelatedRepositoryInterface
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> $relatedRepository;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @var TemplateEngineInterface
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> $templateEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>__construct</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SomeRepositoryInterface</span> $someRepository,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>RelatedRepositoryInterface</span> $relatedRepository,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>TemplateEngineInterface</span> $templateEngine
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>someRepository</span> <span style=color:#f92672>=</span> $someRepository;
</span></span><span style=display:flex><span>        $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>relatedRepository</span> <span style=color:#f92672>=</span> $relatedRepository;
</span></span><span style=display:flex><span>        $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>templateEngine</span> <span style=color:#f92672>=</span> $templateEngine;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @return mixed
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>int</span> $someEntityId)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        $mainEntity <span style=color:#f92672>=</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>someRepository</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getById</span>($someEntityId);
</span></span><span style=display:flex><span>        $relatedEntityList <span style=color:#f92672>=</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>relatedRepository</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getByParentId</span>($someEntityId);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>templateEngine</span><span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>render</span>(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;@Some/Controller/Namespace/Detail/details.html.twig&#39;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>DetailsViewModel</span>($mainEntity, $relatedEntityList)
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/UI/Admin/Some/Controller/Namespace/Detail/DetailsViewModel.php
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> <span style=color:#a6e22e>UI\Admin\Some\Controller\Namespace\Detail</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// use ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DetailsViewModel</span> <span style=color:#66d9ef>implements</span> <span style=color:#a6e22e>TemplateViewModelInterface</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @var array
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> $mainEntity <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @var array
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> $relatedEntityList <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @var bool
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> $shouldDisplayFancyDialog <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @var bool
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> $canEditData <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/**
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @param SomeEntity $mainEntity
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     * @param RelatedEntity[] $relatedEntityList
</span></span></span><span style=display:flex><span><span style=color:#e6db74>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>__construct</span>(<span style=color:#a6e22e>SomeEntity</span> $mainEntity, <span style=color:#66d9ef>array</span> $relatedEntityList)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>mainEntity</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;name&#39;</span> <span style=color:#f92672>=&gt;</span> $mainEntity<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getName</span>(),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;description&#39;</span> <span style=color:#f92672>=&gt;</span> $mainEntity<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getResume</span>(),
</span></span><span style=display:flex><span>        ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> ($relatedEntityList <span style=color:#66d9ef>as</span> $relatedEntity) {
</span></span><span style=display:flex><span>            $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>relatedEntityList</span>[] <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;title&#39;</span> <span style=color:#f92672>=&gt;</span> $relatedEntity<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getTitle</span>(),
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;subtitle&#39;</span> <span style=color:#f92672>=&gt;</span> $relatedEntity<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>getSubtitle</span>(),
</span></span><span style=display:flex><span>            ];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>shouldDisplayFancyDialog</span> <span style=color:#f92672>=</span> <span style=color:#75715e>/* ... some complex conditional using the entities data ... */</span> ;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>canEditData</span> <span style=color:#f92672>=</span> <span style=color:#75715e>/* ... another complex conditional using the entities data ... */</span> ;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getMainEntity</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>mainEntity</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getRelatedEntityList</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>array</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>relatedEntityList</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>shouldDisplayFancyDialog</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>bool</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>shouldDisplayFancyDialog</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>canEditData</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>bool</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>canEditData</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>模板和 ViewModel 有一對一的對應關係，這意味著一個視圖只能與特定的 ViewModel 一起使用，反之亦然。這實際上甚至讓我想到，也許我們可以將模板和 ViewModel 封裝在一個視圖物件中，有效地將控制器與模板和 ViewModel 解耦，使其依賴於一個通用的視圖介面，但我從未嘗試過這種方法。</p><h1 id=結論>結論<a hidden class=anchor aria-hidden=true href=#結論>#</a></h1><p>我們可能會在網路上找到 MVC 的其他變形。然而，以上是我認為跟我工作相關且我認為相對比較有趣的幾種案例。</p><p>儘管如此，我在這裡引用的模式是為桌面應用程式和/或豐富客戶端的情境而創建的，因此它們並不總是 100% 適合 Request & Response 模式。</p><p>如果您正在進行企業雲應用，並且您正在使用 MVC，那麼您很可能實際上使用的是更接近 MVP 的東西，但無論如何，我的觀點並不是要堅持遵循 MVC 的特定變體或了解所有名稱並對此嚴格要求，我的觀點是我們應該從所有這些中學習，以便我們可以根據需要使用和調整。最終的目標是，像往常一樣，低耦合和高內聚：關注點分離。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/software-architectrue/>Software Architectrue</a></li></ul><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>