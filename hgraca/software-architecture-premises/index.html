<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[IT] 軟體架構前提 The Software Architecture Premises | Rain Hu's Workspace</title>
<meta name=keywords content="Software Architecture"><meta name=description content="在這篇文章中，我將建立有關軟體架構的最初概念，這將有助於更好地理解接下來的文章。
沒有萬靈丹 無論你如何理解我在《軟體架構編年史》中所談論的內容，最重要的是要明白，並不存在萬能的解決方案。儘可能多學習不同的方法，理解每種方法的優點和缺點，以及它們解決的具體技術問題。
然後，在接受新的挑戰時，首先要理解業務和終端用戶的需求。只有在清楚理解這些需求之後，您才能理智地思考應該使用哪種架構風格和模式來更好地解決手頭的問題。
最後，做出你自己的選擇，也許實施其中一種已知的解決方案，或者創建你自己的設計來適應你特定的問題。
Some architectural styles are often portrayed as ‘silver bullet’ solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved. - Roy Fielding, 2000
有些架構風格常被描繪為所有軟體問題的「萬靈丹」解決方案。然而，一個優秀的設計師應該選擇一種與特定問題需求相匹配的風格。 - 羅伊·菲爾丁，2000
Terminology 術語 在軟體開發的世界裡，使用的術語充滿了模糊性，因此，在繼續之前，澄清我所使用的一些術語的意義是非常重要的。
Functional 功能性的 這是任何一段程式碼、方法、類別、類別群組，它在應用程式中擔任純粹的技術角色。它與領域無關，僅代表應用程式中的技術能力。例如：
Layers Factories Repositories Value Objects Views ViewModels Conceptual 概念性的 這是任何一段代碼、方法、類別、一組類別，都反映了應用程式中的領域概念。它與領域直接相關，代表了應用程式中的業務能力。例如：
User Product Stock Management Product Variants Checkout Upsells 這種分離並不意味著一個程式碼單元不能以兩種方式（功能性和概念性）被引用。例如，一個 Money 類別可以代表一個 domain concept，也可以是一個 value object。"><meta name=author content="hgraca"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="[IT] 軟體架構前提 The Software Architecture Premises"><meta property="og:description" content="在這篇文章中，我將建立有關軟體架構的最初概念，這將有助於更好地理解接下來的文章。
沒有萬靈丹 無論你如何理解我在《軟體架構編年史》中所談論的內容，最重要的是要明白，並不存在萬能的解決方案。儘可能多學習不同的方法，理解每種方法的優點和缺點，以及它們解決的具體技術問題。
然後，在接受新的挑戰時，首先要理解業務和終端用戶的需求。只有在清楚理解這些需求之後，您才能理智地思考應該使用哪種架構風格和模式來更好地解決手頭的問題。
最後，做出你自己的選擇，也許實施其中一種已知的解決方案，或者創建你自己的設計來適應你特定的問題。
Some architectural styles are often portrayed as ‘silver bullet’ solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved. - Roy Fielding, 2000
有些架構風格常被描繪為所有軟體問題的「萬靈丹」解決方案。然而，一個優秀的設計師應該選擇一種與特定問題需求相匹配的風格。 - 羅伊·菲爾丁，2000
Terminology 術語 在軟體開發的世界裡，使用的術語充滿了模糊性，因此，在繼續之前，澄清我所使用的一些術語的意義是非常重要的。
Functional 功能性的 這是任何一段程式碼、方法、類別、類別群組，它在應用程式中擔任純粹的技術角色。它與領域無關，僅代表應用程式中的技術能力。例如：
Layers Factories Repositories Value Objects Views ViewModels Conceptual 概念性的 這是任何一段代碼、方法、類別、一組類別，都反映了應用程式中的領域概念。它與領域直接相關，代表了應用程式中的業務能力。例如：
User Product Stock Management Product Variants Checkout Upsells 這種分離並不意味著一個程式碼單元不能以兩種方式（功能性和概念性）被引用。例如，一個 Money 類別可以代表一個 domain concept，也可以是一個 value object。"><meta property="og:type" content="article"><meta property="og:url" content="https://intervalrain.github.io/hgraca/software-architecture-premises/"><meta property="article:section" content="hgraca"><meta property="article:published_time" content="2023-10-14T01:14:17+08:00"><meta property="article:modified_time" content="2023-10-14T01:14:17+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[IT] 軟體架構前提 The Software Architecture Premises"><meta name=twitter:description content="在這篇文章中，我將建立有關軟體架構的最初概念，這將有助於更好地理解接下來的文章。
沒有萬靈丹 無論你如何理解我在《軟體架構編年史》中所談論的內容，最重要的是要明白，並不存在萬能的解決方案。儘可能多學習不同的方法，理解每種方法的優點和缺點，以及它們解決的具體技術問題。
然後，在接受新的挑戰時，首先要理解業務和終端用戶的需求。只有在清楚理解這些需求之後，您才能理智地思考應該使用哪種架構風格和模式來更好地解決手頭的問題。
最後，做出你自己的選擇，也許實施其中一種已知的解決方案，或者創建你自己的設計來適應你特定的問題。
Some architectural styles are often portrayed as ‘silver bullet’ solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved. - Roy Fielding, 2000
有些架構風格常被描繪為所有軟體問題的「萬靈丹」解決方案。然而，一個優秀的設計師應該選擇一種與特定問題需求相匹配的風格。 - 羅伊·菲爾丁，2000
Terminology 術語 在軟體開發的世界裡，使用的術語充滿了模糊性，因此，在繼續之前，澄清我所使用的一些術語的意義是非常重要的。
Functional 功能性的 這是任何一段程式碼、方法、類別、類別群組，它在應用程式中擔任純粹的技術角色。它與領域無關，僅代表應用程式中的技術能力。例如：
Layers Factories Repositories Value Objects Views ViewModels Conceptual 概念性的 這是任何一段代碼、方法、類別、一組類別，都反映了應用程式中的領域概念。它與領域直接相關，代表了應用程式中的業務能力。例如：
User Product Stock Management Product Variants Checkout Upsells 這種分離並不意味著一個程式碼單元不能以兩種方式（功能性和概念性）被引用。例如，一個 Money 類別可以代表一個 domain concept，也可以是一個 value object。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Hgracas","item":"https://intervalrain.github.io/hgraca/"},{"@type":"ListItem","position":2,"name":"[IT] 軟體架構前提 The Software Architecture Premises","item":"https://intervalrain.github.io/hgraca/software-architecture-premises/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[IT] 軟體架構前提 The Software Architecture Premises","name":"[IT] 軟體架構前提 The Software Architecture Premises","description":"在這篇文章中，我將建立有關軟體架構的最初概念，這將有助於更好地理解接下來的文章。\n沒有萬靈丹 無論你如何理解我在《軟體架構編年史》中所談論的內容，最重要的是要明白，並不存在萬能的解決方案。儘可能多學習不同的方法，理解每種方法的優點和缺點，以及它們解決的具體技術問題。\n然後，在接受新的挑戰時，首先要理解業務和終端用戶的需求。只有在清楚理解這些需求之後，您才能理智地思考應該使用哪種架構風格和模式來更好地解決手頭的問題。\n最後，做出你自己的選擇，也許實施其中一種已知的解決方案，或者創建你自己的設計來適應你特定的問題。\nSome architectural styles are often portrayed as ‘silver bullet’ solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved. - Roy Fielding, 2000\n有些架構風格常被描繪為所有軟體問題的「萬靈丹」解決方案。然而，一個優秀的設計師應該選擇一種與特定問題需求相匹配的風格。 - 羅伊·菲爾丁，2000\nTerminology 術語 在軟體開發的世界裡，使用的術語充滿了模糊性，因此，在繼續之前，澄清我所使用的一些術語的意義是非常重要的。\nFunctional 功能性的 這是任何一段程式碼、方法、類別、類別群組，它在應用程式中擔任純粹的技術角色。它與領域無關，僅代表應用程式中的技術能力。例如：\nLayers Factories Repositories Value Objects Views ViewModels Conceptual 概念性的 這是任何一段代碼、方法、類別、一組類別，都反映了應用程式中的領域概念。它與領域直接相關，代表了應用程式中的業務能力。例如：\nUser Product Stock Management Product Variants Checkout Upsells 這種分離並不意味著一個程式碼單元不能以兩種方式（功能性和概念性）被引用。例如，一個 Money 類別可以代表一個 domain concept，也可以是一個 value object。","keywords":["Software Architecture"],"articleBody":"在這篇文章中，我將建立有關軟體架構的最初概念，這將有助於更好地理解接下來的文章。\n沒有萬靈丹 無論你如何理解我在《軟體架構編年史》中所談論的內容，最重要的是要明白，並不存在萬能的解決方案。儘可能多學習不同的方法，理解每種方法的優點和缺點，以及它們解決的具體技術問題。\n然後，在接受新的挑戰時，首先要理解業務和終端用戶的需求。只有在清楚理解這些需求之後，您才能理智地思考應該使用哪種架構風格和模式來更好地解決手頭的問題。\n最後，做出你自己的選擇，也許實施其中一種已知的解決方案，或者創建你自己的設計來適應你特定的問題。\nSome architectural styles are often portrayed as ‘silver bullet’ solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved. - Roy Fielding, 2000\n有些架構風格常被描繪為所有軟體問題的「萬靈丹」解決方案。然而，一個優秀的設計師應該選擇一種與特定問題需求相匹配的風格。 - 羅伊·菲爾丁，2000\nTerminology 術語 在軟體開發的世界裡，使用的術語充滿了模糊性，因此，在繼續之前，澄清我所使用的一些術語的意義是非常重要的。\nFunctional 功能性的 這是任何一段程式碼、方法、類別、類別群組，它在應用程式中擔任純粹的技術角色。它與領域無關，僅代表應用程式中的技術能力。例如：\nLayers Factories Repositories Value Objects Views ViewModels Conceptual 概念性的 這是任何一段代碼、方法、類別、一組類別，都反映了應用程式中的領域概念。它與領域直接相關，代表了應用程式中的業務能力。例如：\nUser Product Stock Management Product Variants Checkout Upsells 這種分離並不意味著一個程式碼單元不能以兩種方式（功能性和概念性）被引用。例如，一個 Money 類別可以代表一個 domain concept，也可以是一個 value object。\nPackage 套件 任何一組按照某些規則理想地組合在一起的類別\nModule 模組 我使用的定義來自於《實踐中的軟體架構（Software Architecture）》一書，該書指出，一個模組是一個功能性的套件，它反映了應用程式中的技術能力。它是解耦的，可以被其他實現替換。對我來說，模組存在於一個較低的粒度級別，例如，「安全模組」或「ORM」，但也存在於像應用程式的客戶端和伺服器這樣的更高粒度級別。模組提供了功能性的內聚。\nComponent 組件 我也採用了《實踐中的軟體架構（Software Architecture）》一書中給出的定義，其中作者將組件定義為反映業務能力的概念性套件。理想情況下，它也應與其他組件和模塊解耦。例如可以是 User、Product 或 Checkout。\n然而，最重要的是要記住，理想情況下，它反映了 Bounded Context。組件提供了概念性的內聚。\nApplication 應用程式 我將應用程式視為面向使用者的程式碼，也就是使用者介面（UI），它是建立在元件之上的。例如，我們可以有一組元件，我們在其上建立一個網路商店。然而，這個網路商店有一個由消費者用來瀏覽和購買產品的使用者介面（商店前台），並且它有另一個獨立的使用者介面，由商店管理員用來管理產品、庫存、付款提供商等（後台）。這些都是建立在相同業務元件之上的兩個獨立應用程式。\nSystem 系統 我將系統視為一組應用程式，這些程式以某種方式共同工作，以滿足各種企業需求，形成一個企業範圍的系統，即企業應用程式。這些應用程式可能建立在相同的組件之上，也可能不是。在前面的網路商店例子中，系統是整個網路商店，包括建立在相同業務組件之上的兩個應用程式（商店前台和管理員），但也包括其他第三方應用程式，如付款提供商或運輸提供商。\nArchitecture 架構 有許多簡單的軟體架構定義，我認為擁有這些定義是好的，但我認為更容易理解的是，甚至更重要的是，定義架構的成果，它應該為項目提供什麼。\nSoftware Architecture […] is the set of structures needed to reason about the system, which comprises software elements, relations among them, and properties of both. - Clements et al, 2010\n軟體架構[…]是用於推理系統所需的結構集合，其中包括軟體元素、它們之間的關係，以及兩者的屬性。 - Clement 等人，2010\n這是我對架構的理解：\n所有與功能開發相關的技術決策，即框架(frameworks)、編碼標準(coding standards)、文檔(documentation)、流程(processes)等。 這些技術決策很難在專案開發後期去做更動。 是對系統的全局觀，對組件們的結構與關係的描述。 它為變動提供緩衝，通常是為了延緩變更。 提供良好的組件與模組的重用(reuse)機制。 它為結果的一致性和流程的輕量化設立標準，如編碼標準、開發階段、持續交付和部署。 這並非僅是一個人的責任，而是屬於該項目中不同功能團隊的一群經驗豐富的開發者的責任。 Architect 架構師 他們是建築學的守護者和推廣者，可以是個人、也可以是團隊。他們是團隊/部門中最有經驗的開發者之一，且有分析高層次問題和解決方案的責任。在做出決策時，總是會被認為是有「質量」的。\n值得注意的是，所有的開發者在某種程度上都會成為架構師，因為他們都需要理解架構，都會以某種方式貢獻於架構，最終，他們都有維護現有架構的責任。\nIvory Tower Architect 象牙塔架構師 全能的象牙塔架構師是架構師的反模式，他承擔起決定所有與架構相關的問題。他剝奪了其他 stakeholder 對架構的貢獻，因為他既不開放，也不容易接受這些貢獻。\n壞味道 Rigidity 剛性 軟體的剛性就是指該軟體難以變更，因為一個變動將引發更多的變動需求。這就像是一個兔子洞：當我們認為快要完成時，卻發現還有更多的程式碼需要被修改，將我們拖入一個看不見盡頭的循環中。\nFragility 脆弱性 當軟體被更改時，它將在預料之外、無關聯且無法預測的地方破裂。\nImmobility 不動性 當一個設計包含了可能在其他系統中有用的部分，但從原始系統中分離它們的努力和風險過大時，該設計就是不動的。\nViscosity 黏度 在一個黏性系統中，做錯事要比做對事容易得多。這意味著，透過短路行為來實施變革，比正確地開發它要來得容易得多。\n如果執行單元測試和/或編譯需要大量時間，導致開發人員可能會繞過程序並在未執行所有自動化測試的情況下實施一個破解，那麼就會發生系統範圍的黏度。\nNeedless repetition 不必要的重複 當必要的抽象化未能完成時，就會發生這種情況，原因可能是時間不足或經驗不足。程式碼可能並未直接被複製貼上，但相同的業務規則在多個地方被定義。\nOpacity 不透明度 這段程式碼的撰寫方式晦澀難懂，我們需要深入研究方法的實現才能理解其功能。\nNeedless complexity 不必要的複雜性 在熱衷於避免其他六種問題的嘗試中，開發者引入了各種抽象和為可能的未來變化做的準備。優秀的軟體設計應該是輕量級的，靈活的，易於閱讀和理解，最重要的是易於變更，這樣你就不必試圖預測未來所有可能的變化。\n","wordCount":"181","inLanguage":"en","datePublished":"2023-10-14T01:14:17+08:00","dateModified":"2023-10-14T01:14:17+08:00","author":{"@type":"Person","name":"hgraca"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/hgraca/software-architecture-premises/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/hgraca/>Hgracas</a></div><h1 class=post-title>[IT] 軟體架構前提 The Software Architecture Premises</h1><div class=post-meta>&lt;span title='2023-10-14 01:14:17 +0800 +0800'>October 14, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;hgraca&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//hgraca/software-architecture-premises.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%b2%92%e6%9c%89%e8%90%ac%e9%9d%88%e4%b8%b9 aria-label=沒有萬靈丹>沒有萬靈丹</a></li><li><a href=#terminology-%e8%a1%93%e8%aa%9e aria-label="Terminology 術語">Terminology 術語</a><ul><li><a href=#functional-%e5%8a%9f%e8%83%bd%e6%80%a7%e7%9a%84 aria-label="Functional 功能性的">Functional 功能性的</a></li><li><a href=#conceptual-%e6%a6%82%e5%bf%b5%e6%80%a7%e7%9a%84 aria-label="Conceptual 概念性的">Conceptual 概念性的</a></li><li><a href=#package-%e5%a5%97%e4%bb%b6 aria-label="Package 套件">Package 套件</a></li><li><a href=#module-%e6%a8%a1%e7%b5%84 aria-label="Module 模組">Module 模組</a></li><li><a href=#component-%e7%b5%84%e4%bb%b6 aria-label="Component 組件">Component 組件</a></li><li><a href=#application-%e6%87%89%e7%94%a8%e7%a8%8b%e5%bc%8f aria-label="Application 應用程式">Application 應用程式</a></li><li><a href=#system-%e7%b3%bb%e7%b5%b1 aria-label="System 系統">System 系統</a></li><li><a href=#architecture-%e6%9e%b6%e6%a7%8b aria-label="Architecture 架構">Architecture 架構</a></li><li><a href=#architect-%e6%9e%b6%e6%a7%8b%e5%b8%ab aria-label="Architect 架構師">Architect 架構師</a></li><li><a href=#ivory-tower-architect-%e8%b1%a1%e7%89%99%e5%a1%94%e6%9e%b6%e6%a7%8b%e5%b8%ab aria-label="Ivory Tower Architect 象牙塔架構師">Ivory Tower Architect 象牙塔架構師</a></li></ul></li><li><a href=#%e5%a3%9e%e5%91%b3%e9%81%93 aria-label=壞味道>壞味道</a><ul><li><a href=#rigidity-%e5%89%9b%e6%80%a7 aria-label="Rigidity 剛性">Rigidity 剛性</a></li><li><a href=#fragility-%e8%84%86%e5%bc%b1%e6%80%a7 aria-label="Fragility 脆弱性">Fragility 脆弱性</a></li><li><a href=#immobility-%e4%b8%8d%e5%8b%95%e6%80%a7 aria-label="Immobility 不動性">Immobility 不動性</a></li><li><a href=#viscosity-%e9%bb%8f%e5%ba%a6 aria-label="Viscosity 黏度">Viscosity 黏度</a></li><li><a href=#needless-repetition-%e4%b8%8d%e5%bf%85%e8%a6%81%e7%9a%84%e9%87%8d%e8%a4%87 aria-label="Needless repetition 不必要的重複">Needless repetition 不必要的重複</a></li><li><a href=#opacity-%e4%b8%8d%e9%80%8f%e6%98%8e%e5%ba%a6 aria-label="Opacity 不透明度">Opacity 不透明度</a></li><li><a href=#needless-complexity-%e4%b8%8d%e5%bf%85%e8%a6%81%e7%9a%84%e8%a4%87%e9%9b%9c%e6%80%a7 aria-label="Needless complexity 不必要的複雜性">Needless complexity 不必要的複雜性</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>在這篇文章中，我將建立有關軟體架構的最初概念，這將有助於更好地理解接下來的文章。</p><h1 id=沒有萬靈丹>沒有萬靈丹<a hidden class=anchor aria-hidden=true href=#沒有萬靈丹>#</a></h1><p>無論你如何理解我在《軟體架構編年史》中所談論的內容，最重要的是要明白，並不存在萬能的解決方案。儘可能多學習不同的方法，理解每種方法的優點和缺點，以及它們解決的具體技術問題。</p><p>然後，在接受新的挑戰時，首先要理解業務和終端用戶的需求。只有在清楚理解這些需求之後，您才能理智地思考應該使用哪種架構風格和模式來更好地解決手頭的問題。</p><p>最後，做出你自己的選擇，也許實施其中一種已知的解決方案，或者創建你自己的設計來適應你特定的問題。</p><blockquote><p><em>Some architectural styles are often portrayed as ‘silver bullet’ solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved.</em> - <strong>Roy Fielding, 2000</strong><br><em>有些架構風格常被描繪為所有軟體問題的「萬靈丹」解決方案。然而，一個優秀的設計師應該選擇一種與特定問題需求相匹配的風格。</em> - <strong>羅伊·菲爾丁，2000</strong></p></blockquote><h1 id=terminology-術語>Terminology 術語<a hidden class=anchor aria-hidden=true href=#terminology-術語>#</a></h1><p>在軟體開發的世界裡，使用的術語充滿了模糊性，因此，在繼續之前，澄清我所使用的一些術語的意義是非常重要的。</p><h2 id=functional-功能性的>Functional 功能性的<a hidden class=anchor aria-hidden=true href=#functional-功能性的>#</a></h2><p>這是任何一段程式碼、方法、類別、類別群組，它在應用程式中擔任純粹的技術角色。它與領域無關，僅代表應用程式中的技術能力。例如：</p><ul><li>Layers</li><li>Factories</li><li>Repositories</li><li>Value Objects</li><li>Views</li><li>ViewModels</li></ul><h2 id=conceptual-概念性的>Conceptual 概念性的<a hidden class=anchor aria-hidden=true href=#conceptual-概念性的>#</a></h2><p>這是任何一段代碼、方法、類別、一組類別，都反映了應用程式中的領域概念。它與領域直接相關，代表了應用程式中的業務能力。例如：</p><ul><li>User</li><li>Product</li><li>Stock Management</li><li>Product Variants</li><li>Checkout</li><li>Upsells</li></ul><p>這種分離並不意味著一個程式碼單元不能以兩種方式（功能性和概念性）被引用。例如，一個 <code>Money</code> 類別可以代表一個 domain concept，也可以是一個 value object。</p><h2 id=package-套件>Package 套件<a hidden class=anchor aria-hidden=true href=#package-套件>#</a></h2><p>任何一組按照某些規則理想地組合在一起的類別</p><h2 id=module-模組>Module 模組<a hidden class=anchor aria-hidden=true href=#module-模組>#</a></h2><p>我使用的定義來自於《<em><strong>實踐中的軟體架構（Software Architecture</strong></em>）》一書，該書指出，一個模組是一個<strong>功能性的套件</strong>，它反映了應用程式中的<strong>技術能力</strong>。它是解耦的，可以被其他實現替換。對我來說，模組存在於一個較低的粒度級別，例如，「<strong>安全模組</strong>」或「<strong>ORM</strong>」，但也存在於像應用程式的<strong>客戶端</strong>和<strong>伺服器</strong>這樣的更高粒度級別。模組提供了功能性的內聚。</p><h2 id=component-組件>Component 組件<a hidden class=anchor aria-hidden=true href=#component-組件>#</a></h2><p>我也採用了《<em><strong>實踐中的軟體架構（Software Architecture</strong></em>）》一書中給出的定義，其中作者將組件定義為反映<strong>業務能力</strong>的<strong>概念性套件</strong>。理想情況下，它也應與其他組件和模塊解耦。例如可以是 <strong>User</strong>、<strong>Product</strong> 或 <strong>Checkout</strong>。</p><p>然而，最重要的是要記住，理想情況下，它反映了 <strong>Bounded Context</strong>。組件提供了概念性的內聚。</p><h2 id=application-應用程式>Application 應用程式<a hidden class=anchor aria-hidden=true href=#application-應用程式>#</a></h2><p>我將應用程式視為面向使用者的程式碼，也就是使用者介面（UI），它是建立在元件之上的。例如，我們可以有一組元件，我們在其上建立一個網路商店。然而，這個網路商店有一個由消費者用來瀏覽和購買產品的使用者介面（商店前台），並且它有另一個獨立的使用者介面，由商店管理員用來管理產品、庫存、付款提供商等（後台）。這些都是建立在相同業務元件之上的兩個獨立應用程式。</p><h2 id=system-系統>System 系統<a hidden class=anchor aria-hidden=true href=#system-系統>#</a></h2><p>我將系統視為一組應用程式，這些程式以某種方式共同工作，以滿足各種企業需求，形成一個企業範圍的系統，即企業應用程式。這些應用程式可能建立在相同的組件之上，也可能不是。在前面的網路商店例子中，系統是整個網路商店，包括建立在相同業務組件之上的兩個應用程式（商店前台和管理員），但也包括其他第三方應用程式，如付款提供商或運輸提供商。</p><h2 id=architecture-架構>Architecture 架構<a hidden class=anchor aria-hidden=true href=#architecture-架構>#</a></h2><p>有許多簡單的軟體架構定義，我認為擁有這些定義是好的，但我認為更容易理解的是，甚至更重要的是，定義架構的成果，它應該為項目提供什麼。</p><blockquote><p><em>Software Architecture […] is the set of structures needed to reason about the system, which comprises software elements, relations among them, and properties of both.</em> - Clements et al, 2010<br><em>軟體架構[…]是用於推理系統所需的結構集合，其中包括軟體元素、它們之間的關係，以及兩者的屬性。</em> - Clement 等人，2010</p></blockquote><p>這是我對架構的理解：</p><ul><li>所有與功能開發相關的技術決策，即框架(frameworks)、編碼標準(coding standards)、文檔(documentation)、流程(processes)等。</li><li>這些技術決策很難在專案開發後期去做更動。</li><li>是對系統的全局觀，對組件們的結構與關係的描述。</li><li>它為變動提供緩衝，通常是為了延緩變更。</li><li>提供良好的組件與模組的重用(reuse)機制。</li><li>它為結果的一致性和流程的輕量化設立標準，如編碼標準、開發階段、持續交付和部署。</li><li>這並非僅是一個人的責任，而是屬於該項目中不同功能團隊的一群經驗豐富的開發者的責任。</li></ul><h2 id=architect-架構師>Architect 架構師<a hidden class=anchor aria-hidden=true href=#architect-架構師>#</a></h2><p>他們是建築學的守護者和推廣者，可以是個人、也可以是團隊。他們是團隊/部門中最有經驗的開發者之一，且有分析高層次問題和解決方案的責任。在做出決策時，總是會被認為是有「質量」的。</p><p>值得注意的是，所有的開發者在某種程度上都會成為架構師，因為他們都需要理解架構，都會以某種方式貢獻於架構，最終，他們都有維護現有架構的責任。</p><h2 id=ivory-tower-architect-象牙塔架構師>Ivory Tower Architect 象牙塔架構師<a hidden class=anchor aria-hidden=true href=#ivory-tower-architect-象牙塔架構師>#</a></h2><p>全能的<strong>象牙塔架構師</strong>是架構師的<strong>反模式</strong>，他承擔起決定所有與架構相關的問題。他剝奪了其他 stakeholder 對架構的貢獻，因為他既不開放，也不容易接受這些貢獻。</p><h1 id=壞味道>壞味道<a hidden class=anchor aria-hidden=true href=#壞味道>#</a></h1><h2 id=rigidity-剛性>Rigidity 剛性<a hidden class=anchor aria-hidden=true href=#rigidity-剛性>#</a></h2><p>軟體的剛性就是指該軟體難以變更，因為一個變動將引發更多的變動需求。這就像是一個兔子洞：當我們認為快要完成時，卻發現還有更多的程式碼需要被修改，將我們拖入一個看不見盡頭的循環中。</p><h2 id=fragility-脆弱性>Fragility 脆弱性<a hidden class=anchor aria-hidden=true href=#fragility-脆弱性>#</a></h2><p>當軟體被更改時，它將在預料之外、無關聯且無法預測的地方破裂。</p><h2 id=immobility-不動性>Immobility 不動性<a hidden class=anchor aria-hidden=true href=#immobility-不動性>#</a></h2><p>當一個設計包含了可能在其他系統中有用的部分，但從原始系統中分離它們的努力和風險過大時，該設計就是不動的。</p><h2 id=viscosity-黏度>Viscosity 黏度<a hidden class=anchor aria-hidden=true href=#viscosity-黏度>#</a></h2><p>在一個黏性系統中，做錯事要比做對事容易得多。這意味著，透過短路行為來實施變革，比正確地開發它要來得容易得多。</p><p>如果執行單元測試和/或編譯需要大量時間，導致開發人員可能會繞過程序並在未執行所有自動化測試的情況下實施一個破解，那麼就會發生系統範圍的黏度。</p><h2 id=needless-repetition-不必要的重複>Needless repetition 不必要的重複<a hidden class=anchor aria-hidden=true href=#needless-repetition-不必要的重複>#</a></h2><p>當必要的抽象化未能完成時，就會發生這種情況，原因可能是時間不足或經驗不足。程式碼可能並未直接被複製貼上，但相同的業務規則在多個地方被定義。</p><h2 id=opacity-不透明度>Opacity 不透明度<a hidden class=anchor aria-hidden=true href=#opacity-不透明度>#</a></h2><p>這段程式碼的撰寫方式晦澀難懂，我們需要深入研究方法的實現才能理解其功能。</p><h2 id=needless-complexity-不必要的複雜性>Needless complexity 不必要的複雜性<a hidden class=anchor aria-hidden=true href=#needless-complexity-不必要的複雜性>#</a></h2><p>在熱衷於避免其他六種問題的嘗試中，開發者引入了各種抽象和為可能的未來變化做的準備。優秀的軟體設計應該是輕量級的，靈活的，易於閱讀和理解，最重要的是易於變更，這樣你就不必試圖預測未來所有可能的變化。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/software-architectrue/>Software Architectrue</a></li></ul></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>