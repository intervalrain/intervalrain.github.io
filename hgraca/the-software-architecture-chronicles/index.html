<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[IT] 軟體架構編年史 The Software Architecture Chronicles | Rain Hu's Workspace</title>
<meta name=keywords content="Software Architecture"><meta name=description content="
前言：這系列文章為翻譯自作者 hgraca。
這篇文章是關於軟體架構系列文章的第一篇。在這些文章中，我將分享我所學習到的軟體架構知識，我如何看待它，以及我如何運用這些知識。
我這一系列的文章稱為「軟體架構編年史」，並非因為我自認為是一位偉大的作家，而是因為我覺得這個名字有點俗氣，又帶點趣味。
在這篇首篇文章中，我將會談論我為何要撰寫這一系列的文章，以及接下來將會有什麼內容。
認識歷史的重要性

Those who fail to learn History are doomed to repeat it. - George Santayana, The Life of Reason, 1905
未能學習歷史的人注定要重蹈覆轍。 - 喬治‧桑塔亞納《理性的生活》，1905
我認為從歷史中學習是非常重要的，它能教導我們事情。在個人層面上，我們終究需要（也希望）能從錯誤中學習。從國家的角度來看，歷史幫助塑造我們的文化、創造群體的概念，因此有了「台灣人」的觀念，一種國家認同。同時，歷史也幫助我們從祖先的錯誤中學習，比如信仰那些有著怪異思想的人，如二戰…
對程式開發者而言，歷史有助於我們仰靠前人的經驗上，少走許多錯的道路，並讓我們「站在巨人的肩膀上」達到更高的境界！
在我成為更好的開發者路上，我閱讀了很多文章，觀看了許多演講，我盡我所能的站在巨人的肩膀上。
有一件事情使我感到困惑，那就是許多意見是基於意見之上的意見…這就像是以訛傳訛，我們最終得到是對於一篇論文、文章或書籍真正內容的扭曲理解。
因此，我開始在網路上搜尋原始的論文、文章和書籍，這些都是我認為對我的工作最重要的概念，並自己對它們進行思考。
這些文章是這種推理的結果，因為我試圖理解這些概念是如何產生的，以某種程度上的時間順序來看。
撰寫這些文章迫使我大量閱讀和思考所有議題，並幫助我理解當代在軟體開發中使用的技術。我希望這些文章能對更多開發者有所幫助。
然而，如果你讀到一些你不理解或是不認同的內容，請告訴我，我非常願意討論這些議題，並從討論中學習，也願意修正我錯誤的觀點。
文章列表
1. 軟體架構前提 (Software Architecture Premises)
2. 程式語言的演進 (Programming Languages Evolution)
3. 架構風格 / 架構模式 / 設計模式 (Architectural Styles vs. Architectural Patterns vs. Design Patterns)
4. 單體架構 (Monolithic Architecture)
5. 分層架構 (Layered Architecture)"><meta name=author content="hgraca"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/hgraca/the-software-architecture-chronicles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/hgraca/the-software-architecture-chronicles/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[IT] 軟體架構編年史 The Software Architecture Chronicles"><meta property="og:description" content=" 前言：這系列文章為翻譯自作者 hgraca。
這篇文章是關於軟體架構系列文章的第一篇。在這些文章中，我將分享我所學習到的軟體架構知識，我如何看待它，以及我如何運用這些知識。
我這一系列的文章稱為「軟體架構編年史」，並非因為我自認為是一位偉大的作家，而是因為我覺得這個名字有點俗氣，又帶點趣味。
在這篇首篇文章中，我將會談論我為何要撰寫這一系列的文章，以及接下來將會有什麼內容。
認識歷史的重要性 Those who fail to learn History are doomed to repeat it. - George Santayana, The Life of Reason, 1905
未能學習歷史的人注定要重蹈覆轍。 - 喬治‧桑塔亞納《理性的生活》，1905
我認為從歷史中學習是非常重要的，它能教導我們事情。在個人層面上，我們終究需要（也希望）能從錯誤中學習。從國家的角度來看，歷史幫助塑造我們的文化、創造群體的概念，因此有了「台灣人」的觀念，一種國家認同。同時，歷史也幫助我們從祖先的錯誤中學習，比如信仰那些有著怪異思想的人，如二戰…
對程式開發者而言，歷史有助於我們仰靠前人的經驗上，少走許多錯的道路，並讓我們「站在巨人的肩膀上」達到更高的境界！
在我成為更好的開發者路上，我閱讀了很多文章，觀看了許多演講，我盡我所能的站在巨人的肩膀上。
有一件事情使我感到困惑，那就是許多意見是基於意見之上的意見…這就像是以訛傳訛，我們最終得到是對於一篇論文、文章或書籍真正內容的扭曲理解。
因此，我開始在網路上搜尋原始的論文、文章和書籍，這些都是我認為對我的工作最重要的概念，並自己對它們進行思考。
這些文章是這種推理的結果，因為我試圖理解這些概念是如何產生的，以某種程度上的時間順序來看。
撰寫這些文章迫使我大量閱讀和思考所有議題，並幫助我理解當代在軟體開發中使用的技術。我希望這些文章能對更多開發者有所幫助。
然而，如果你讀到一些你不理解或是不認同的內容，請告訴我，我非常願意討論這些議題，並從討論中學習，也願意修正我錯誤的觀點。
文章列表 1. 軟體架構前提 (Software Architecture Premises)
2. 程式語言的演進 (Programming Languages Evolution)
3. 架構風格 / 架構模式 / 設計模式 (Architectural Styles vs. Architectural Patterns vs. Design Patterns)
4. 單體架構 (Monolithic Architecture)
5. 分層架構 (Layered Architecture)"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="hgraca"><meta property="article:published_time" content="2023-10-13T23:41:57+08:00"><meta property="article:modified_time" content="2023-10-13T23:41:57+08:00"><meta property="article:tag" content="Software Architectrue"><meta name=twitter:card content="summary"><meta name=twitter:title content="[IT] 軟體架構編年史 The Software Architecture Chronicles"><meta name=twitter:description content="
前言：這系列文章為翻譯自作者 hgraca。
這篇文章是關於軟體架構系列文章的第一篇。在這些文章中，我將分享我所學習到的軟體架構知識，我如何看待它，以及我如何運用這些知識。
我這一系列的文章稱為「軟體架構編年史」，並非因為我自認為是一位偉大的作家，而是因為我覺得這個名字有點俗氣，又帶點趣味。
在這篇首篇文章中，我將會談論我為何要撰寫這一系列的文章，以及接下來將會有什麼內容。
認識歷史的重要性

Those who fail to learn History are doomed to repeat it. - George Santayana, The Life of Reason, 1905
未能學習歷史的人注定要重蹈覆轍。 - 喬治‧桑塔亞納《理性的生活》，1905
我認為從歷史中學習是非常重要的，它能教導我們事情。在個人層面上，我們終究需要（也希望）能從錯誤中學習。從國家的角度來看，歷史幫助塑造我們的文化、創造群體的概念，因此有了「台灣人」的觀念，一種國家認同。同時，歷史也幫助我們從祖先的錯誤中學習，比如信仰那些有著怪異思想的人，如二戰…
對程式開發者而言，歷史有助於我們仰靠前人的經驗上，少走許多錯的道路，並讓我們「站在巨人的肩膀上」達到更高的境界！
在我成為更好的開發者路上，我閱讀了很多文章，觀看了許多演講，我盡我所能的站在巨人的肩膀上。
有一件事情使我感到困惑，那就是許多意見是基於意見之上的意見…這就像是以訛傳訛，我們最終得到是對於一篇論文、文章或書籍真正內容的扭曲理解。
因此，我開始在網路上搜尋原始的論文、文章和書籍，這些都是我認為對我的工作最重要的概念，並自己對它們進行思考。
這些文章是這種推理的結果，因為我試圖理解這些概念是如何產生的，以某種程度上的時間順序來看。
撰寫這些文章迫使我大量閱讀和思考所有議題，並幫助我理解當代在軟體開發中使用的技術。我希望這些文章能對更多開發者有所幫助。
然而，如果你讀到一些你不理解或是不認同的內容，請告訴我，我非常願意討論這些議題，並從討論中學習，也願意修正我錯誤的觀點。
文章列表
1. 軟體架構前提 (Software Architecture Premises)
2. 程式語言的演進 (Programming Languages Evolution)
3. 架構風格 / 架構模式 / 設計模式 (Architectural Styles vs. Architectural Patterns vs. Design Patterns)
4. 單體架構 (Monolithic Architecture)
5. 分層架構 (Layered Architecture)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Hgracas","item":"https://intervalrain.github.io/hgraca/"},{"@type":"ListItem","position":2,"name":"[IT] 軟體架構編年史 The Software Architecture Chronicles","item":"https://intervalrain.github.io/hgraca/the-software-architecture-chronicles/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[IT] 軟體架構編年史 The Software Architecture Chronicles","name":"[IT] 軟體架構編年史 The Software Architecture Chronicles","description":" 前言：這系列文章為翻譯自作者 hgraca。\n這篇文章是關於軟體架構系列文章的第一篇。在這些文章中，我將分享我所學習到的軟體架構知識，我如何看待它，以及我如何運用這些知識。\n我這一系列的文章稱為「軟體架構編年史」，並非因為我自認為是一位偉大的作家，而是因為我覺得這個名字有點俗氣，又帶點趣味。\n在這篇首篇文章中，我將會談論我為何要撰寫這一系列的文章，以及接下來將會有什麼內容。\n認識歷史的重要性 Those who fail to learn History are doomed to repeat it. - George Santayana, The Life of Reason, 1905\n未能學習歷史的人注定要重蹈覆轍。 - 喬治‧桑塔亞納《理性的生活》，1905\n我認為從歷史中學習是非常重要的，它能教導我們事情。在個人層面上，我們終究需要（也希望）能從錯誤中學習。從國家的角度來看，歷史幫助塑造我們的文化、創造群體的概念，因此有了「台灣人」的觀念，一種國家認同。同時，歷史也幫助我們從祖先的錯誤中學習，比如信仰那些有著怪異思想的人，如二戰…\n對程式開發者而言，歷史有助於我們仰靠前人的經驗上，少走許多錯的道路，並讓我們「站在巨人的肩膀上」達到更高的境界！\n在我成為更好的開發者路上，我閱讀了很多文章，觀看了許多演講，我盡我所能的站在巨人的肩膀上。\n有一件事情使我感到困惑，那就是許多意見是基於意見之上的意見…這就像是以訛傳訛，我們最終得到是對於一篇論文、文章或書籍真正內容的扭曲理解。\n因此，我開始在網路上搜尋原始的論文、文章和書籍，這些都是我認為對我的工作最重要的概念，並自己對它們進行思考。\n這些文章是這種推理的結果，因為我試圖理解這些概念是如何產生的，以某種程度上的時間順序來看。\n撰寫這些文章迫使我大量閱讀和思考所有議題，並幫助我理解當代在軟體開發中使用的技術。我希望這些文章能對更多開發者有所幫助。\n然而，如果你讀到一些你不理解或是不認同的內容，請告訴我，我非常願意討論這些議題，並從討論中學習，也願意修正我錯誤的觀點。\n文章列表 1. 軟體架構前提 (Software Architecture Premises)\n2. 程式語言的演進 (Programming Languages Evolution)\n3. 架構風格 / 架構模式 / 設計模式 (Architectural Styles vs. Architectural Patterns vs. Design Patterns)\n4. 單體架構 (Monolithic Architecture)\n5. 分層架構 (Layered Architecture)\n","keywords":["Software Architecture"],"articleBody":" 前言：這系列文章為翻譯自作者 hgraca。\n這篇文章是關於軟體架構系列文章的第一篇。在這些文章中，我將分享我所學習到的軟體架構知識，我如何看待它，以及我如何運用這些知識。\n我這一系列的文章稱為「軟體架構編年史」，並非因為我自認為是一位偉大的作家，而是因為我覺得這個名字有點俗氣，又帶點趣味。\n在這篇首篇文章中，我將會談論我為何要撰寫這一系列的文章，以及接下來將會有什麼內容。\n認識歷史的重要性 Those who fail to learn History are doomed to repeat it. - George Santayana, The Life of Reason, 1905\n未能學習歷史的人注定要重蹈覆轍。 - 喬治‧桑塔亞納《理性的生活》，1905\n我認為從歷史中學習是非常重要的，它能教導我們事情。在個人層面上，我們終究需要（也希望）能從錯誤中學習。從國家的角度來看，歷史幫助塑造我們的文化、創造群體的概念，因此有了「台灣人」的觀念，一種國家認同。同時，歷史也幫助我們從祖先的錯誤中學習，比如信仰那些有著怪異思想的人，如二戰…\n對程式開發者而言，歷史有助於我們仰靠前人的經驗上，少走許多錯的道路，並讓我們「站在巨人的肩膀上」達到更高的境界！\n在我成為更好的開發者路上，我閱讀了很多文章，觀看了許多演講，我盡我所能的站在巨人的肩膀上。\n有一件事情使我感到困惑，那就是許多意見是基於意見之上的意見…這就像是以訛傳訛，我們最終得到是對於一篇論文、文章或書籍真正內容的扭曲理解。\n因此，我開始在網路上搜尋原始的論文、文章和書籍，這些都是我認為對我的工作最重要的概念，並自己對它們進行思考。\n這些文章是這種推理的結果，因為我試圖理解這些概念是如何產生的，以某種程度上的時間順序來看。\n撰寫這些文章迫使我大量閱讀和思考所有議題，並幫助我理解當代在軟體開發中使用的技術。我希望這些文章能對更多開發者有所幫助。\n然而，如果你讀到一些你不理解或是不認同的內容，請告訴我，我非常願意討論這些議題，並從討論中學習，也願意修正我錯誤的觀點。\n文章列表 1. 軟體架構前提 (Software Architecture Premises)\n2. 程式語言的演進 (Programming Languages Evolution)\n3. 架構風格 / 架構模式 / 設計模式 (Architectural Styles vs. Architectural Patterns vs. Design Patterns)\n4. 單體架構 (Monolithic Architecture)\n5. 分層架構 (Layered Architecture)\n6. MVC 及其變形\n1979 - Model-View-Controller 1987/2000 - PAC/Hierachical Model-View-Controller 1996 - Model-View-Presenter 1998 - “Model1” \u0026 “Model2” 2005 - ModelView-ViewModel ???? - Model-View-Presenter-ViewModel 2008 - Resource-Method-Representation 2014 - Action-Domain-Responder 7. EBI 架構 (EBI Architecture)\n8. 包裝與命名空間 (Packaging \u0026 namespacing)\n9. 領域驅動設計 (Domain-Driven Design)\n10. 埠與適配器架構, aka 六邊形架構 (Ports \u0026 Adapter Architecture aka Hexagonal Architecture)\n11. 洋蔥架構 (Onion Architecture)\n12. 乾淨架構 (Clean Architecture)\n13. 事件驅動架構 (Event-Driven Architectrue)\n14. 從CQS到CQRS\n15. 面向服務的架構 (Service Oriented Architecture, SOA)\n16. 明確的架構 #01: DDD, 六角, 洋蔥, 乾淨, CQRS, … 我如何將它們全部組合在一起\n明確的架構 #02: 不僅僅是同心層次\n明確的架構 #03: 在程式碼中反映架構和領域\n明確的架構 #04: 記錄架構\n發展項目: 從 MVP 到 P\n4+1 架構視圖模型\n架構品質\n時間軸 這是我在閱讀了所有這些主題的文章和書籍後，排出的軟體開發演進時間軸。\n1950s Non-structed Programming 1960s Structed Programming Layering: 1 tier UI + 業務邏輯 + 資料儲存 ~1958 - Algol 1970s Procedural/Functional Programming ~1970 - Pascal ~1972 - C 1979 - Model-View-Controller 1980s Object Oriented Programming(OOP): 最初的想法出現在 1960 晚期 Layering: 2 tier UI / 業務邏輯 + 資料儲存 ~1980 - C++ CORBA(Common Object Request Broker Architecture) - 通用物件請求代理架構(儘管第一個穩定版本在1991年推出，但第一次使用是在1980s) ~1986 - Erlang ~1987 - Perl 1987 - PAC aka Hierachical Model-View-Controller 1988 - LSP(Liskov Subsitution Principle) 1990s Layering: 3 tier UI / 業務邏輯(用戶端為瀏覽器時還包含UI呈現邏輯) / 資料儲存 ~1991 - Message Bus ~1991 - Python 1992 - Entity-Boundary-Interactor Architecture aka EBC aka EIC ~1993 - Ruby ~1995 - Delphi, Java, JavaScript, PHP 1996 - Model-View-Presenter 1996 - OCP, ISP, DIP, REP, CRP, CCP, ADP 1997 - SDP, SAP ~1997 - Aspect Oriented Programming(AOP) ~1997 - Web Service ~1997 - ESB - Enterprise Service Bus(儘管創造此詞的書籍於2004出版，當該概念於之前已使用過) 2000s 2002 - SRP 2003 - Domain-Driven-Design 2005 - Model-View-ViewModel 2005 - Ports \u0026 Adapter Architecture aka Hexagonal Architecture 2006? - CQRS \u0026 ES(Command Query Responsibility Segregation \u0026 Event Sourcing) 2008 - Onion Architecture 2009 - Microservices (at Netflix) 2010s 2010 - Data-Context-Interaction Architecture 2012 - Clean Architecture 2014 - C4 Model ","wordCount":"361","inLanguage":"zh-tw","datePublished":"2023-10-13T23:41:57+08:00","dateModified":"2023-10-13T23:41:57+08:00","author":{"@type":"Person","name":"hgraca"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/hgraca/the-software-architecture-chronicles/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/hgraca/>Hgracas</a></div><h1 class="post-title entry-hint-parent">[IT] 軟體架構編年史 The Software Architecture Chronicles</h1><div class=post-meta><span title='2023-10-13 23:41:57 +0800 +0800'>October 13, 2023</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;hgraca&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//hgraca/the-software-architecture-chronicles.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e8%aa%8d%e8%ad%98%e6%ad%b7%e5%8f%b2%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7 aria-label=認識歷史的重要性>認識歷史的重要性</a></li><li><a href=#%e6%96%87%e7%ab%a0%e5%88%97%e8%a1%a8 aria-label=文章列表>文章列表</a></li><li><a href=#%e6%99%82%e9%96%93%e8%bb%b8 aria-label=時間軸>時間軸</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>前言：這系列文章為翻譯自作者 <a href=https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/>hgraca</a>。</p></blockquote><p>這篇文章是關於軟體架構系列文章的第一篇。在這些文章中，我將分享我所學習到的軟體架構知識，我如何看待它，以及我如何運用這些知識。</p><p>我這一系列的文章稱為「軟體架構編年史」，並非因為我自認為是一位偉大的作家，而是因為我覺得這個名字有點俗氣，又帶點趣味。</p><p>在這篇首篇文章中，我將會談論我為何要撰寫這一系列的文章，以及接下來將會有什麼內容。</p><h1 id=認識歷史的重要性>認識歷史的重要性<a hidden class=anchor aria-hidden=true href=#認識歷史的重要性>#</a></h1><blockquote><p><em>Those who fail to learn History are doomed to repeat it.</em> - <strong>George Santayana</strong>, <em><strong>The Life of Reason</strong></em>, <strong>1905</strong><br><em>未能學習歷史的人注定要重蹈覆轍。</em> - <strong>喬治‧桑塔亞納</strong>《<em><strong>理性的生活</strong></em>》，<strong>1905</strong></p></blockquote><p>我認為從歷史中學習是非常重要的，它能教導我們事情。在個人層面上，我們終究需要（也希望）能從錯誤中學習。從國家的角度來看，歷史幫助塑造我們的文化、創造群體的概念，因此有了「台灣人」的觀念，一種國家認同。同時，歷史也幫助我們從祖先的錯誤中學習，比如信仰那些有著怪異思想的人，如二戰…</p><p>對程式開發者而言，歷史有助於我們仰靠前人的經驗上，少走許多錯的道路，並讓我們「站在巨人的肩膀上」達到更高的境界！</p><p>在我成為更好的開發者路上，我閱讀了很多文章，觀看了許多演講，我盡我所能的站在巨人的肩膀上。</p><p>有一件事情使我感到困惑，那就是許多意見是基於意見之上的意見…這就像是以訛傳訛，我們最終得到是對於一篇論文、文章或書籍真正內容的扭曲理解。</p><p>因此，我開始在網路上搜尋原始的論文、文章和書籍，這些都是我認為對我的工作最重要的概念，並自己對它們進行思考。</p><p>這些文章是這種推理的結果，因為我試圖理解這些概念是如何產生的，以某種程度上的時間順序來看。</p><p>撰寫這些文章迫使我大量閱讀和思考所有議題，並幫助我理解當代在軟體開發中使用的技術。我希望這些文章能對更多開發者有所幫助。</p><p>然而，如果你讀到一些你不理解或是不認同的內容，請告訴我，我非常願意討論這些議題，並從討論中學習，也願意修正我錯誤的觀點。</p><h1 id=文章列表>文章列表<a hidden class=anchor aria-hidden=true href=#文章列表>#</a></h1><p><a href=../software-architecture-premises>1. 軟體架構前提 (Software Architecture Premises)</a></p><p><a href=../programming-language-evolution>2. 程式語言的演進 (Programming Languages Evolution)</a></p><p><a href>3. 架構風格 / 架構模式 / 設計模式 (Architectural Styles vs. Architectural Patterns vs. Design Patterns)</a></p><p><a href=../monolithic-architecture>4. 單體架構 (Monolithic Architecture)</a></p><p><a href=../layered-architecture>5. 分層架構 (Layered Architecture)</a></p><p><a href=../mvc-and-its-variants>6. MVC 及其變形</a></p><ul><li><a href=../mvc-and-its-variants/#1979---model-view-controller>1979 - Model-View-Controller</a></li><li><a href=../mvc-and-its-variants/#19872000---pachierarchical-model-view-controller>1987/2000 - PAC/Hierachical Model-View-Controller</a></li><li><a href=../mvc-and-its-variants/#1996---model-view-presenter>1996 - Model-View-Presenter</a></li><li><a href=../model-1-model-2/>1998 - &ldquo;Model1&rdquo; & &ldquo;Model2&rdquo;</a></li><li><a href=../mvc-and-its-variants/#2005---model-view-viewmodel>2005 - ModelView-ViewModel</a></li><li><a href=../mvc-and-its-variants/#model-view-presenter-viewmodel>???? - Model-View-Presenter-ViewModel</a></li><li><a href=../resource-method-representation/>2008 - Resource-Method-Representation</a></li><li><a href=../action-domain-responder>2014 - Action-Domain-Responder</a></li></ul><p><a href=../ebi-architecture>7. EBI 架構 (EBI Architecture)</a></p><p><a href=../packaging-code>8. 包裝與命名空間 (Packaging & namespacing)</a></p><p><a href=../domain-driven-design>9. 領域驅動設計 (Domain-Driven Design)</a></p><p><a href=../ports-adapters-architecture>10. 埠與適配器架構, aka 六邊形架構 (Ports & Adapter Architecture aka Hexagonal Architecture)</a></p><p><a href=../onion-architecture>11. 洋蔥架構 (Onion Architecture)</a></p><p><a href=../clean-architecture>12. 乾淨架構 (Clean Architecture)</a></p><p><a href=../event-driven-architecture>13. 事件驅動架構 (Event-Driven Architectrue)</a></p><p><a href=../from-cqs-to-cqrs>14. 從CQS到CQRS</a></p><p><a href=../service-oriented-architecture-soa>15. 面向服務的架構 (Service Oriented Architecture, SOA)</a></p><p><a href=../explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together>16. 明確的架構 #01: DDD, 六角, 洋蔥, 乾淨, CQRS, &mldr; 我如何將它們全部組合在一起</a></p><ol start=17><li><p>明確的架構 #02: 不僅僅是同心層次</p></li><li><p>明確的架構 #03: 在程式碼中反映架構和領域</p></li><li><p>明確的架構 #04: 記錄架構</p></li><li><p>發展項目: 從 MVP 到 P</p></li><li><p>4+1 架構視圖模型</p></li><li><p>架構品質</p></li></ol><h1 id=時間軸>時間軸<a hidden class=anchor aria-hidden=true href=#時間軸>#</a></h1><p>這是我在閱讀了所有這些主題的文章和書籍後，排出的軟體開發演進時間軸。</p><ul><li>1950s<ul><li><strong>Non-structed Programming</strong></li></ul></li><li>1960s<ul><li><strong>Structed Programming</strong></li><li><strong>Layering: 1 tier</strong> UI + 業務邏輯 + 資料儲存</li><li>~1958 - Algol</li></ul></li><li>1970s<ul><li><strong>Procedural/Functional Programming</strong></li><li>~1970 - Pascal</li><li>~1972 - C</li><li>1979 - <strong>Model-View-Controller</strong></li></ul></li><li>1980s<ul><li><strong>Object Oriented Programming(OOP)</strong>: 最初的想法出現在 1960 晚期</li><li><strong>Layering: 2 tier</strong> UI / 業務邏輯 + 資料儲存</li><li>~1980 - C++</li><li><strong>CORBA</strong>(Common Object Request Broker Architecture) - 通用物件請求代理架構(儘管第一個穩定版本在1991年推出，但第一次使用是在1980s)</li><li>~1986 - Erlang</li><li>~1987 - Perl</li><li>1987 - PAC aka <strong>Hierachical Model-View-Controller</strong></li><li>1988 - <strong>LSP</strong>(Liskov Subsitution Principle)</li></ul></li><li>1990s<ul><li><strong>Layering: 3 tier</strong> UI / 業務邏輯(用戶端為瀏覽器時還包含UI呈現邏輯) / 資料儲存</li><li>~1991 - <strong>Message Bus</strong></li><li>~1991 - Python</li><li>1992 - <strong>Entity-Boundary-Interactor</strong> Architecture aka EBC aka EIC</li><li>~1993 - Ruby</li><li>~1995 - Delphi, Java, JavaScript, PHP</li><li>1996 - <strong>Model-View-Presenter</strong></li><li>1996 - <strong>OCP, ISP, DIP</strong>, REP, CRP, CCP, ADP</li><li>1997 - SDP, SAP</li><li>~1997 - <strong>Aspect Oriented Programming(AOP)</strong></li><li>~1997 - <strong>Web Service</strong></li><li>~1997 - <strong>ESB</strong> - Enterprise Service Bus(儘管創造此詞的書籍於2004出版，當該概念於之前已使用過)</li></ul></li><li>2000s<ul><li>2002 - <strong>SRP</strong></li><li>2003 - <strong>Domain-Driven-Design</strong></li><li>2005 - <strong>Model-View-ViewModel</strong></li><li>2005 - <strong>Ports & Adapter Architecture</strong> aka Hexagonal Architecture</li><li>2006? - <strong>CQRS & ES</strong>(Command Query Responsibility Segregation & Event Sourcing)</li><li>2008 - <strong>Onion Architecture</strong></li><li>2009 - <strong>Microservices</strong> (at Netflix)</li></ul></li><li>2010s<ul><li>2010 - <strong>Data-Context-Interaction Architecture</strong></li><li>2012 - <strong>Clean Architecture</strong></li><li>2014 - C4 Model</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/software-architectrue/>Software Architectrue</a></li></ul><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>