<!DOCTYPE html>
<html lang="zh-tw" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[計算機作業系統] 概述 | Rain Hu&#39;s Workspace</title>
<meta name="keywords" content="OS, CS">
<meta name="description" content="作業系統
簡介



電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)

硬體(hardware)：為系統提供基本的計算資源。

中央處理器(central processing unit, CPU)
記憶體(memory)
I/O 裝置


應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。
使用者(users)
作業系統(Operating system, OS)：



作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。


OS 最主要的兩個功能是：

資源分配：根據需求調配資源分配率(resource utilization)與效能(performance)
監控使用者程式的執行，避免不正常的運作造成對系統的危害。



一個標準的 PC 作業系統應該提供以下的功能：

行程管理(Processing management)
記憶體管理(Memory management)
檔案系統(File system)
網路通訊(Networking)
安全機制(Security)
使用者介面(User interface)
驅動程式(Device drivers)



PC 基本特徵
1. 並行計算(Concurrent computing)

Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。
平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。
作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。

2. 分享(Sharing)

共享是指系統中的資源可以被多個並行進程共同使用。
有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。
互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。

3. 虛擬(Virtual)

虛擬技術把一個物理實體轉換為多個邏輯實體。
主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。
多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。
虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。

4. 異步(Asynchronous)

異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。

基本功能
1. 進程管理(Process management)

進程管理、進程同步、進程通信、死鎖處理、處理調度等。

2. 記憶體管理(Memory management)

記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。

3. 文件管理(File management)

文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。

4. 設備管理(Equipment management)

完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。
主要包含緩衝管理、設備分配、設備處理、虛擬設備等。

系統調用

如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。



  
      
          Linux 的系統調用主要有以下這些：
          
      
  
  
      
          Task
          Commands
      
      
          進程控制
          fork(); exit(); wait();
      
      
          進程通信
          pipe(); shmget(); mmap();
      
      
          文件操作
          open(); read(); write();
      
      
          設備操作
          ioctl(); read(); write();
      
      
          訊息維護
          getpid(); alarm(); sleep();
      
      
          安全
          chmod(); umask(); chown();
      
  



內核與微內核
">
<meta name="author" content="Rain Hu">
<link rel="canonical" href="https://intervalrain.github.io/">
<meta name="google-site-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css" integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/images/rain.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/images/rain.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/images/rain.png">
<link rel="apple-touch-icon" href="http://localhost:1313/images/rain.png">
<link rel="mask-icon" href="http://localhost:1313/images/rain.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh-tw" href="http://localhost:1313/cs/os/intro/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script src="https://utteranc.es/client.js"
    repo="intervalrain.github.io"
    issue-term="pathname"
    label="Comment"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script><meta property="og:url" content="http://localhost:1313/cs/os/intro/">
  <meta property="og:site_name" content="Rain Hu&#39;s Workspace">
  <meta property="og:title" content="[計算機作業系統] 概述">
  <meta property="og:description" content="作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)
硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。
OS 最主要的兩個功能是：
資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：
行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4. 異步(Asynchronous) 異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。 基本功能 1. 進程管理(Process management) 進程管理、進程同步、進程通信、死鎖處理、處理調度等。 2. 記憶體管理(Memory management) 記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。 3. 文件管理(File management) 文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。 4. 設備管理(Equipment management) 完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。 主要包含緩衝管理、設備分配、設備處理、虛擬設備等。 系統調用 如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。 Linux 的系統調用主要有以下這些： Task Commands 進程控制 fork(); exit(); wait(); 進程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 設備操作 ioctl(); read(); write(); 訊息維護 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 內核與微內核 ">
  <meta property="og:locale" content="zh-tw">
  <meta property="og:type" content="article">
    <meta property="article:section" content="cs">
    <meta property="article:published_time" content="2022-07-02T04:00:55+08:00">
    <meta property="article:modified_time" content="2022-07-02T04:00:55+08:00">
    <meta property="article:tag" content="OS">
    <meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[計算機作業系統] 概述">
<meta name="twitter:description" content="作業系統
簡介



電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)

硬體(hardware)：為系統提供基本的計算資源。

中央處理器(central processing unit, CPU)
記憶體(memory)
I/O 裝置


應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。
使用者(users)
作業系統(Operating system, OS)：



作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。


OS 最主要的兩個功能是：

資源分配：根據需求調配資源分配率(resource utilization)與效能(performance)
監控使用者程式的執行，避免不正常的運作造成對系統的危害。



一個標準的 PC 作業系統應該提供以下的功能：

行程管理(Processing management)
記憶體管理(Memory management)
檔案系統(File system)
網路通訊(Networking)
安全機制(Security)
使用者介面(User interface)
驅動程式(Device drivers)



PC 基本特徵
1. 並行計算(Concurrent computing)

Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。
平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。
作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。

2. 分享(Sharing)

共享是指系統中的資源可以被多個並行進程共同使用。
有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。
互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。

3. 虛擬(Virtual)

虛擬技術把一個物理實體轉換為多個邏輯實體。
主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。
多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。
虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。

4. 異步(Asynchronous)

異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。

基本功能
1. 進程管理(Process management)

進程管理、進程同步、進程通信、死鎖處理、處理調度等。

2. 記憶體管理(Memory management)

記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。

3. 文件管理(File management)

文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。

4. 設備管理(Equipment management)

完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。
主要包含緩衝管理、設備分配、設備處理、虛擬設備等。

系統調用

如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。



  
      
          Linux 的系統調用主要有以下這些：
          
      
  
  
      
          Task
          Commands
      
      
          進程控制
          fork(); exit(); wait();
      
      
          進程通信
          pipe(); shmget(); mmap();
      
      
          文件操作
          open(); read(); write();
      
      
          設備操作
          ioctl(); read(); write();
      
      
          訊息維護
          getpid(); alarm(); sleep();
      
      
          安全
          chmod(); umask(); chown();
      
  



內核與微內核
">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "CSes",
      "item": "http://localhost:1313/cs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[計算機作業系統] 概述",
      "item": "http://localhost:1313/cs/os/intro/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[計算機作業系統] 概述",
  "name": "[計算機作業系統] 概述",
  "description": "作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)\n硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。\nOS 最主要的兩個功能是：\n資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：\n行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4. 異步(Asynchronous) 異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。 基本功能 1. 進程管理(Process management) 進程管理、進程同步、進程通信、死鎖處理、處理調度等。 2. 記憶體管理(Memory management) 記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。 3. 文件管理(File management) 文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。 4. 設備管理(Equipment management) 完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。 主要包含緩衝管理、設備分配、設備處理、虛擬設備等。 系統調用 如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。 Linux 的系統調用主要有以下這些： Task Commands 進程控制 fork(); exit(); wait(); 進程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 設備操作 ioctl(); read(); write(); 訊息維護 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 內核與微內核 ",
  "keywords": [
    "OS", "CS"
  ],
  "articleBody": "作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)\n硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。\nOS 最主要的兩個功能是：\n資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：\n行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4. 異步(Asynchronous) 異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。 基本功能 1. 進程管理(Process management) 進程管理、進程同步、進程通信、死鎖處理、處理調度等。 2. 記憶體管理(Memory management) 記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。 3. 文件管理(File management) 文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。 4. 設備管理(Equipment management) 完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。 主要包含緩衝管理、設備分配、設備處理、虛擬設備等。 系統調用 如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。 Linux 的系統調用主要有以下這些： Task Commands 進程控制 fork(); exit(); wait(); 進程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 設備操作 ioctl(); read(); write(); 訊息維護 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 內核與微內核 1. 內核(kernel) 內核是將作業系統功能作為一個緊密結合的整體放到內核。 由於各模塊共享訊息，因此有很高的性能。 2. 微內核(microkernel) 由於作業系統不斷複雜化，因此將一部分作業系統功能移出內核，從而降低內核的複雜性。移出的部分根據分層的原則劃分成若干服務，相互獨立。 在微內核結構下，作業系統被劃分成小的、定義良好的模塊，只有微內核這一個模塊運行在內核模式，其餘模塊運行時在用戶模式。 因為脫試頻繁地在用戶模式與內核模式間進行切換，所以有一定的性能損失。 中斷分類 1. 中斷(interrupt) 由 CPU 執行指令以外的事件引起，如 I/O 完成中斷，表示設備輸入/輸出處理已經完成，處理器能夠發送下一個輸入/輸出請求。此外還有時鐘中斷、控制台中斷等。 2. 異常(exception) 由 CPU 執行指令的內部事件引起，如非法操作碼、地址越界、算術溢位(overflow)等。 3. 陷入(trap) 在用戶程序中使用系統調用。 常見系統類型分類 1. 批次處理系統(Batch Processing System) 一次性的處理已經蒐集的資料。 適合處理週期性的大筆資料。 如大型機(Mainframe)。 2. 多行程系統(Muliprogramming System) 系統中存在多組行程同時(concurrent)執行，避免CPU閒置，提升CPU利用度。\n**注意，不是平行運算(parallel computing) Multiprogramming Degree：指系統內所存在等待執行的行程(proess)數目。 Multiprogramming Degree 愈高，則 CPU 使用度可能愈高，但若產生 Thrashing，可能會使 CPU 效能降低。 振盪(Thrashing)：當 CPU 效能降低時，系統會想引入更多的 process 讓 CPU 盡可能地工作。但當存有太多 process 時，大部分的工作會花費在 Page Fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 的效能越來越低。 降低 Multiprogramming Degree。 利用 Page Fault Frequencry (Ratio) 控制來防止 Thrashing。 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數，以防止 Thrashing。 3. 分時系統(Time Sharing System) 或稱多工系統(Multi-Tasking System)。 多行程系統的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，提升反應時間(Response Time)。 常見配置： 行程排程使用輪詢調度(Robin Round Scheduling, RR Scheduling)。 記憶體空間所有使用者共享。 使用虛擬記憶體技術。 I/O 裝置透過 4. 多核系統與平行系統(Multiprocessor System and Parallel System) 具有一個以上的CPU核心單元組，各核心之間共享記憶體、匯流排等資源，將工作同時分配給多個 CPU 處理。 執行緒數是邏輯上模擬出來的 CPU 核心數，用於多工處理的需要。 多核處理器又可分為： Symmetric Multiprocessing (SMP)：對稱式多處理器，每一個處理器具有相同的功能，可靠度較高，強調負載平衡。 Asymmetric Multiprocessing (ASMP)：非對稱式多處理器，主僕架構。 補充：CPU個數、CPU核心數、CPU執行緒數 5. 分散式系統(Distributed System) 整合各地不同的電腦，以網路連線的方式，將工作分派給不同的電腦執行以提高效率。 需滿足兩個條件： 硬體上每台電腦都是自主的 軟體上用戶將整個系統看作是一台電腦。 一般分為兩類，分別是： 主僕式系(Client-Server System) P2P系統(Peer-to-peer) 好處： 資源共享(Resource Sharing) 加快計算速度(Speed Up) 可靠性(Reliability) 通訊需求(Communication Need) 6. 即時系統(Real Time System) 定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。 依類型可分為兩類： 硬性即時系統(Hard Real Time System) 軟性即時系統(Soft Real Time System) 7. 叢集系統(Clustered System) 叢叢集系統共享儲存裝置，集合許多 CPU 並且由網路連線緊密地連結以完成工作。叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。 通常較不依賴記憶體。 ",
  "wordCount" : "290",
  "inLanguage": "zh-tw",
  "datePublished": "2022-07-02T04:00:55+08:00",
  "dateModified": "2022-07-02T04:00:55+08:00",
  "author":{
    "@type": "Person",
    "name": "Rain Hu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/cs/os/intro/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Rain Hu's Workspace",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/images/rain.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Rain Hu&#39;s Workspace (Alt + H)">
                <img src="http://localhost:1313/images/rain.png" alt="" aria-label="logo"
                    height="35">Rain Hu&#39;s Workspace</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/aboutme" title="About me">
                    <span>About me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/csharp/csharp" title="C#">
                    <span>C#</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/csindex" title="CS">
                    <span>CS</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/leetcode" title="LeetCode">
                    <span>LeetCode</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">首頁</a>&nbsp;»&nbsp;<a href="http://localhost:1313/cs/">CSes</a></div>
    <h1 class="post-title entry-hint-parent">
      [計算機作業系統] 概述
    </h1>
    <div class="post-meta"><span title='2022-07-02 04:00:55 +0800 CST'>July 2, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href="https://github.com/intervalrain/intervalrain.github.io/tree/main/content//CS/OS/intro.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目錄</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e4%bd%9c%e6%a5%ad%e7%b3%bb%e7%b5%b1" aria-label="作業系統">作業系統</a><ul>
                            
                    <li>
                        <a href="#%e7%b0%a1%e4%bb%8b" aria-label="簡介">簡介</a></li>
                    <li>
                        <a href="#pc-%e5%9f%ba%e6%9c%ac%e7%89%b9%e5%be%b5" aria-label="PC 基本特徵">PC 基本特徵</a><ul>
                            
                    <li>
                        <a href="#1-%e4%b8%a6%e8%a1%8c%e8%a8%88%e7%ae%97concurrent-computing" aria-label="1. 並行計算(Concurrent computing)">1. 並行計算(Concurrent computing)</a></li>
                    <li>
                        <a href="#2-%e5%88%86%e4%ba%absharing" aria-label="2. 分享(Sharing)">2. 分享(Sharing)</a></li>
                    <li>
                        <a href="#3-%e8%99%9b%e6%93%acvirtual" aria-label="3. 虛擬(Virtual)">3. 虛擬(Virtual)</a></li>
                    <li>
                        <a href="#4-%e7%95%b0%e6%ad%a5asynchronous" aria-label="4. 異步(Asynchronous)">4. 異步(Asynchronous)</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%9f%ba%e6%9c%ac%e5%8a%9f%e8%83%bd" aria-label="基本功能">基本功能</a><ul>
                            
                    <li>
                        <a href="#1-%e9%80%b2%e7%a8%8b%e7%ae%a1%e7%90%86process-management" aria-label="1. 進程管理(Process management)">1. 進程管理(Process management)</a></li>
                    <li>
                        <a href="#2-%e8%a8%98%e6%86%b6%e9%ab%94%e7%ae%a1%e7%90%86memory-management" aria-label="2. 記憶體管理(Memory management)">2. 記憶體管理(Memory management)</a></li>
                    <li>
                        <a href="#3-%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86file-management" aria-label="3. 文件管理(File management)">3. 文件管理(File management)</a></li>
                    <li>
                        <a href="#4-%e8%a8%ad%e5%82%99%e7%ae%a1%e7%90%86equipment-management" aria-label="4. 設備管理(Equipment management)">4. 設備管理(Equipment management)</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%b3%bb%e7%b5%b1%e8%aa%bf%e7%94%a8" aria-label="系統調用">系統調用</a></li>
                    <li>
                        <a href="#%e5%85%a7%e6%a0%b8%e8%88%87%e5%be%ae%e5%85%a7%e6%a0%b8" aria-label="內核與微內核">內核與微內核</a><ul>
                            
                    <li>
                        <a href="#1-%e5%85%a7%e6%a0%b8kernel" aria-label="1. 內核(kernel)">1. 內核(kernel)</a></li>
                    <li>
                        <a href="#2-%e5%be%ae%e5%85%a7%e6%a0%b8microkernel" aria-label="2. 微內核(microkernel)">2. 微內核(microkernel)</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%b8%ad%e6%96%b7%e5%88%86%e9%a1%9e" aria-label="中斷分類">中斷分類</a><ul>
                            
                    <li>
                        <a href="#1-%e4%b8%ad%e6%96%b7interrupt" aria-label="1. 中斷(interrupt)">1. 中斷(interrupt)</a></li>
                    <li>
                        <a href="#2-%e7%95%b0%e5%b8%b8exception" aria-label="2. 異常(exception)">2. 異常(exception)</a></li>
                    <li>
                        <a href="#3-%e9%99%b7%e5%85%a5trap" aria-label="3. 陷入(trap)">3. 陷入(trap)</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%b8%b8%e8%a6%8b%e7%b3%bb%e7%b5%b1%e9%a1%9e%e5%9e%8b%e5%88%86%e9%a1%9e" aria-label="常見系統類型分類">常見系統類型分類</a><ul>
                            
                    <li>
                        <a href="#1-%e6%89%b9%e6%ac%a1%e8%99%95%e7%90%86%e7%b3%bb%e7%b5%b1batch-processing-system" aria-label="1. 批次處理系統(Batch Processing System)">1. 批次處理系統(Batch Processing System)</a></li>
                    <li>
                        <a href="#2-%e5%a4%9a%e8%a1%8c%e7%a8%8b%e7%b3%bb%e7%b5%b1muliprogramming-system" aria-label="2. 多行程系統(Muliprogramming System)">2. 多行程系統(Muliprogramming System)</a></li>
                    <li>
                        <a href="#3-%e5%88%86%e6%99%82%e7%b3%bb%e7%b5%b1time-sharing-system" aria-label="3. 分時系統(Time Sharing System)">3. 分時系統(Time Sharing System)</a></li>
                    <li>
                        <a href="#4-%e5%a4%9a%e6%a0%b8%e7%b3%bb%e7%b5%b1%e8%88%87%e5%b9%b3%e8%a1%8c%e7%b3%bb%e7%b5%b1multiprocessor-system-and-parallel-system" aria-label="4. 多核系統與平行系統(Multiprocessor System and Parallel System)">4. 多核系統與平行系統(Multiprocessor System and Parallel System)</a></li>
                    <li>
                        <a href="#5-%e5%88%86%e6%95%a3%e5%bc%8f%e7%b3%bb%e7%b5%b1distributed-system" aria-label="5. 分散式系統(Distributed System)">5. 分散式系統(Distributed System)</a></li>
                    <li>
                        <a href="#6-%e5%8d%b3%e6%99%82%e7%b3%bb%e7%b5%b1real-time-system" aria-label="6. 即時系統(Real Time System)">6. 即時系統(Real Time System)</a></li>
                    <li>
                        <a href="#7-%e5%8f%a2%e9%9b%86%e7%b3%bb%e7%b5%b1clustered-system" aria-label="7. 叢集系統(Clustered System)">7. 叢集系統(Clustered System)</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="作業系統">作業系統<a hidden class="anchor" aria-hidden="true" href="#作業系統">#</a></h1>
<h2 id="簡介">簡介<a hidden class="anchor" aria-hidden="true" href="#簡介">#</a></h2>
<p><img alt="computer os" loading="lazy" src="https://2.bp.blogspot.com/-gzomOqKpa74/VLPwd72Q8KI/AAAAAAAAk-E/mnLR8NAJfLY/s640/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2014-12-12%2B%E4%B8%8B%E5%8D%882.48.33-17.png"></p>
<ul>
<li>
<p>電腦系統主要可分成四個部分，或分成<strong>硬體(hardware)</strong>、<strong>軟體(software)</strong>、<strong>數據(data)</strong></p>
<ol>
<li>硬體(hardware)：為系統提供基本的計算資源。
<ol>
<li>中央處理器(central processing unit, CPU)</li>
<li>記憶體(memory)</li>
<li>I/O 裝置</li>
</ol>
</li>
<li>應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。</li>
<li>使用者(users)</li>
<li>作業系統(Operating system, OS)：</li>
</ol>
</li>
<li>
<p>作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。</p>
</li>
<li>
<p>OS 最主要的兩個功能是：</p>
<ul>
<li>資源分配：根據需求調配資源分配率(resource utilization)與效能(performance)</li>
<li>監控使用者程式的執行，避免不正常的運作造成對系統的危害。</li>
</ul>
</li>
<li>
<p>一個標準的 PC 作業系統應該提供以下的功能：</p>
<ul>
<li>行程管理(Processing management)</li>
<li>記憶體管理(Memory management)</li>
<li>檔案系統(File system)</li>
<li>網路通訊(Networking)</li>
<li>安全機制(Security)</li>
<li>使用者介面(User interface)</li>
<li>驅動程式(Device drivers)</li>
</ul>
</li>
</ul>
<h2 id="pc-基本特徵">PC 基本特徵<a hidden class="anchor" aria-hidden="true" href="#pc-基本特徵">#</a></h2>
<h3 id="1-並行計算concurrent-computing">1. 並行計算(Concurrent computing)<a hidden class="anchor" aria-hidden="true" href="#1-並行計算concurrent-computing">#</a></h3>
<ul>
<li>Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而<strong>平行計算(parallel computing)</strong> 則指同一個時間內能運行多個指令。</li>
<li>平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。</li>
<li>作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。</li>
</ul>
<h3 id="2-分享sharing">2. 分享(Sharing)<a hidden class="anchor" aria-hidden="true" href="#2-分享sharing">#</a></h3>
<ul>
<li>共享是指系統中的資源可以被多個並行進程共同使用。</li>
<li>有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。</li>
<li>互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。</li>
</ul>
<h3 id="3-虛擬virtual">3. 虛擬(Virtual)<a hidden class="anchor" aria-hidden="true" href="#3-虛擬virtual">#</a></h3>
<ul>
<li>虛擬技術把一個物理實體轉換為多個邏輯實體。</li>
<li>主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。</li>
<li>多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。</li>
<li>虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。</li>
</ul>
<h3 id="4-異步asynchronous">4. 異步(Asynchronous)<a hidden class="anchor" aria-hidden="true" href="#4-異步asynchronous">#</a></h3>
<ul>
<li>異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。</li>
</ul>
<h2 id="基本功能">基本功能<a hidden class="anchor" aria-hidden="true" href="#基本功能">#</a></h2>
<h3 id="1-進程管理process-management">1. 進程管理(Process management)<a hidden class="anchor" aria-hidden="true" href="#1-進程管理process-management">#</a></h3>
<ul>
<li>進程管理、進程同步、進程通信、死鎖處理、處理調度等。</li>
</ul>
<h3 id="2-記憶體管理memory-management">2. 記憶體管理(Memory management)<a hidden class="anchor" aria-hidden="true" href="#2-記憶體管理memory-management">#</a></h3>
<ul>
<li>記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。</li>
</ul>
<h3 id="3-文件管理file-management">3. 文件管理(File management)<a hidden class="anchor" aria-hidden="true" href="#3-文件管理file-management">#</a></h3>
<ul>
<li>文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。</li>
</ul>
<h3 id="4-設備管理equipment-management">4. 設備管理(Equipment management)<a hidden class="anchor" aria-hidden="true" href="#4-設備管理equipment-management">#</a></h3>
<ul>
<li>完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。</li>
<li>主要包含緩衝管理、設備分配、設備處理、虛擬設備等。</li>
</ul>
<h2 id="系統調用">系統調用<a hidden class="anchor" aria-hidden="true" href="#系統調用">#</a></h2>
<ul>
<li>如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。
<img alt="interface" loading="lazy" src="https://camo.githubusercontent.com/e6e9338fcb2f8c849b5ed9798862d27937d80c94721948dd87c5dec1e739c2c6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f74475056302e706e67"></li>
<li>
<table>
  <thead>
      <tr>
          <th>Linux 的系統調用主要有以下這些：</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Task</strong></td>
          <td><strong>Commands</strong></td>
      </tr>
      <tr>
          <td>進程控制</td>
          <td>fork(); exit(); wait();</td>
      </tr>
      <tr>
          <td>進程通信</td>
          <td>pipe(); shmget(); mmap();</td>
      </tr>
      <tr>
          <td>文件操作</td>
          <td>open(); read(); write();</td>
      </tr>
      <tr>
          <td>設備操作</td>
          <td>ioctl(); read(); write();</td>
      </tr>
      <tr>
          <td>訊息維護</td>
          <td>getpid(); alarm(); sleep();</td>
      </tr>
      <tr>
          <td>安全</td>
          <td>chmod(); umask(); chown();</td>
      </tr>
  </tbody>
</table>
</li>
</ul>
<h2 id="內核與微內核">內核與微內核<a hidden class="anchor" aria-hidden="true" href="#內核與微內核">#</a></h2>
<p><img alt="ring" loading="lazy" src="https://th.bing.com/th/id/R.859db91aeb8ec96109d43097bd911459?rik=lA7Jg6HrEIuyFA&riu=http%3a%2f%2fresources.infosecinstitute.com%2fwp-content%2fuploads%2fKernelDebugging-03012013.jpg&ehk=XDpXoi61cf6s%2fX4BOz3ghmFHsUIdfRiN8q%2f82rDn8%2fM%3d&risl=&pid=ImgRaw&r=0"></p>
<h3 id="1-內核kernel">1. 內核(kernel)<a hidden class="anchor" aria-hidden="true" href="#1-內核kernel">#</a></h3>
<ul>
<li>內核是將作業系統功能作為一個緊密結合的整體放到內核。</li>
<li>由於各模塊共享訊息，因此有很高的性能。</li>
</ul>
<h3 id="2-微內核microkernel">2. 微內核(microkernel)<a hidden class="anchor" aria-hidden="true" href="#2-微內核microkernel">#</a></h3>
<ul>
<li>由於作業系統不斷複雜化，因此將一部分作業系統功能移出內核，從而降低內核的複雜性。移出的部分根據分層的原則劃分成若干服務，相互獨立。</li>
<li>在微內核結構下，作業系統被劃分成小的、定義良好的模塊，只有微內核這一個模塊運行在內核模式，其餘模塊運行時在用戶模式。</li>
<li>因為脫試頻繁地在用戶模式與內核模式間進行切換，所以有一定的性能損失。
<img alt="kernel" loading="lazy" src="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/images/userandkernelmode01.png"></li>
</ul>
<h2 id="中斷分類">中斷分類<a hidden class="anchor" aria-hidden="true" href="#中斷分類">#</a></h2>
<h3 id="1-中斷interrupt">1. 中斷(interrupt)<a hidden class="anchor" aria-hidden="true" href="#1-中斷interrupt">#</a></h3>
<ul>
<li>由 CPU 執行指令以外的事件引起，如 I/O 完成中斷，表示設備輸入/輸出處理已經完成，處理器能夠發送下一個輸入/輸出請求。此外還有時鐘中斷、控制台中斷等。</li>
</ul>
<h3 id="2-異常exception">2. 異常(exception)<a hidden class="anchor" aria-hidden="true" href="#2-異常exception">#</a></h3>
<ul>
<li>由 CPU 執行指令的內部事件引起，如非法操作碼、地址越界、算術溢位(overflow)等。</li>
</ul>
<h3 id="3-陷入trap">3. 陷入(trap)<a hidden class="anchor" aria-hidden="true" href="#3-陷入trap">#</a></h3>
<ul>
<li>在用戶程序中使用系統調用。</li>
</ul>
<h2 id="常見系統類型分類">常見系統類型分類<a hidden class="anchor" aria-hidden="true" href="#常見系統類型分類">#</a></h2>
<h3 id="1-批次處理系統batch-processing-system">1. 批次處理系統(Batch Processing System)<a hidden class="anchor" aria-hidden="true" href="#1-批次處理系統batch-processing-system">#</a></h3>
<ul>
<li>一次性的處理已經蒐集的資料。</li>
<li>適合處理週期性的大筆資料。</li>
<li>如大型機(Mainframe)。</li>
</ul>
<h3 id="2-多行程系統muliprogramming-system">2. 多行程系統(Muliprogramming System)<a hidden class="anchor" aria-hidden="true" href="#2-多行程系統muliprogramming-system">#</a></h3>
<ul>
<li>系統中存在多組行程同時(concurrent)執行，避免CPU閒置，提升CPU利用度。<br>
**注意，不是平行運算(parallel computing)</li>
<li><strong>Multiprogramming Degree</strong>：指系統內所存在等待執行的行程(proess)數目。
Multiprogramming Degree 愈高，則 CPU 使用度可能愈高，但若產生 <strong>Thrashing</strong>，可能會使 CPU 效能降低。
<ul>
<li>振盪(Thrashing)：當 CPU 效能降低時，系統會想引入更多的 process 讓 CPU 盡可能地工作。但當存有太多 process 時，大部分的工作會花費在 Page Fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 的效能越來越低。
<ol>
<li>降低 Multiprogramming Degree。</li>
<li>利用 Page Fault Frequencry (Ratio) 控制來防止 Thrashing。</li>
<li>利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數，以防止 Thrashing。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-分時系統time-sharing-system">3. 分時系統(Time Sharing System)<a hidden class="anchor" aria-hidden="true" href="#3-分時系統time-sharing-system">#</a></h3>
<ul>
<li>或稱多工系統(Multi-Tasking System)。</li>
<li>多行程系統的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，提升反應時間(Response Time)。</li>
<li>常見配置：
<ul>
<li>行程排程使用輪詢調度(Robin Round Scheduling, RR Scheduling)。</li>
<li>記憶體空間所有使用者共享。</li>
<li>使用虛擬記憶體技術。</li>
<li>I/O 裝置透過</li>
</ul>
</li>
</ul>
<h3 id="4-多核系統與平行系統multiprocessor-system-and-parallel-system">4. 多核系統與平行系統(Multiprocessor System and Parallel System)<a hidden class="anchor" aria-hidden="true" href="#4-多核系統與平行系統multiprocessor-system-and-parallel-system">#</a></h3>
<ul>
<li>具有一個以上的CPU核心單元組，各核心之間共享記憶體、匯流排等資源，將工作同時分配給多個 CPU 處理。</li>
<li>執行緒數是邏輯上模擬出來的 CPU 核心數，用於多工處理的需要。</li>
<li>多核處理器又可分為：
<ul>
<li>Symmetric Multiprocessing (SMP)：對稱式多處理器，每一個處理器具有相同的功能，可靠度較高，強調負載平衡。</li>
<li>Asymmetric Multiprocessing (ASMP)：非對稱式多處理器，主僕架構。</li>
</ul>
</li>
<li><a href="/cs/os/cpucorethread/"><em>補充：CPU個數、CPU核心數、CPU執行緒數</em></a></li>
</ul>
<h3 id="5-分散式系統distributed-system">5. 分散式系統(Distributed System)<a hidden class="anchor" aria-hidden="true" href="#5-分散式系統distributed-system">#</a></h3>
<ul>
<li>整合各地不同的電腦，以網路連線的方式，將工作分派給不同的電腦執行以提高效率。</li>
<li>需滿足兩個條件：
<ol>
<li>硬體上每台電腦都是自主的</li>
<li>軟體上用戶將整個系統看作是一台電腦。</li>
</ol>
</li>
<li>一般分為兩類，分別是：
<ol>
<li>主僕式系(Client-Server System)</li>
<li>P2P系統(Peer-to-peer)</li>
</ol>
</li>
<li>好處：
<ul>
<li>資源共享(Resource Sharing)</li>
<li>加快計算速度(Speed Up)</li>
<li>可靠性(Reliability)</li>
<li>通訊需求(Communication Need)</li>
</ul>
</li>
</ul>
<h3 id="6-即時系統real-time-system">6. 即時系統(Real Time System)<a hidden class="anchor" aria-hidden="true" href="#6-即時系統real-time-system">#</a></h3>
<ul>
<li>定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。</li>
<li>依類型可分為兩類：
<ul>
<li>硬性即時系統(Hard Real Time System)</li>
<li>軟性即時系統(Soft Real Time System)</li>
</ul>
</li>
</ul>
<h3 id="7-叢集系統clustered-system">7. 叢集系統(Clustered System)<a hidden class="anchor" aria-hidden="true" href="#7-叢集系統clustered-system">#</a></h3>
<ul>
<li>叢叢集系統共享儲存裝置，集合許多 CPU 並且由網路連線緊密地連結以完成工作。叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。</li>
<li>通常較不依賴記憶體。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/os/">OS</a></li>
      <li><a href="http://localhost:1313/tags/cs/">CS</a></li>
    </ul>

  </footer><script src="https://utteranc.es/client.js"
    repo="Reid00/hugo-blog-talks"
    issue-term="pathname"
    label="Comment"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Rain Hu&#39;s Workspace</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '複製';

        function copyingDone() {
            copybutton.innerHTML = '已複製！';
            setTimeout(() => {
                copybutton.innerHTML = '複製';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
