<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[OS] Lec 1 - Introduction | Rain Hu's Workspace</title>
<meta name=keywords content="OS,Programming,Computer Science"><meta name=description content="概觀作業系統的歷史發展與進程"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://intervalrain.github.io/os/lec1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="[OS] Lec 1 - Introduction"><meta property="og:description" content="概觀作業系統的歷史發展與進程"><meta property="og:type" content="article"><meta property="og:url" content="https://intervalrain.github.io/os/lec1/"><meta property="og:image" content="https://intervalrain.github.io/images/os.png"><meta property="article:section" content="os"><meta property="article:published_time" content="2022-02-24T02:43:30+08:00"><meta property="article:modified_time" content="2022-02-24T02:43:30+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://intervalrain.github.io/images/os.png"><meta name=twitter:title content="[OS] Lec 1 - Introduction"><meta name=twitter:description content="概觀作業系統的歷史發展與進程"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"OSes","item":"https://intervalrain.github.io/os/"},{"@type":"ListItem","position":2,"name":"[OS] Lec 1 - Introduction","item":"https://intervalrain.github.io/os/lec1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[OS] Lec 1 - Introduction","name":"[OS] Lec 1 - Introduction","description":"概觀作業系統的歷史發展與進程","keywords":["OS","Programming","Computer Science"],"articleBody":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。 一個標準 PC 的作業系統應該提供以下功能： 行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers) OS 系統依大小來區分： 大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS 依品牌來區分： 類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。 二、常見的系統類型 Multiprogramming System 系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象) 當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。 [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。 分時系統 Time Sharing System Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置： 行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。 分散式系統 Distributed System 須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：\nClient-Server System Peer-to-peer 舉例：志願計算，使用志願者電腦的閒置計算力，透過網際網路進行資料傳輸(如 Folding@home 蛋白質摺疊研究計畫)\n分散式系統的好處：\n資源共享 (Resource sharing) 加快計算速度 (Speed up) 可靠性 (Reliability)：指不容易因為一台電腦 shut down 而全部崩潰 通訊需求 (Coummunication Need) 補充：勿將 Multiprocessor 與分散式系統混為一談\nSymmetric Multiprocessing (SMP)：對稱式多元處理，每一個處理器具有相同的功能，可靠度高，強調負載平衡。 Asymmetric Multiprocessing (ASMP)：非對稱式多元處理，Master/Slave 架構。 即時系統 Real Time System 定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。 硬性即時系統(Hard Real Time Sydstem)：對於完成工作的時間有極嚴格的限制。若 Prcess 未能於規定的時間內完成，則 Process 即屬失效。(意義同即時系統之定義) 工廠自動化系統、軍事系統、核能安控等。 Application Program 設計上非常重要。 Data 及 Program 皆存在 ROM 或 RAM 中。 不使用虛擬記憶體，因為 Page Fault 的處理時間過長。 減少 os 的干預以降低 Dispatch Latency。 軟性即時系統(Soft Real Time System)：保證高優先權的 Process 必須先於所有低優先權的 Process 完成。 Multimedia System、Virtual Reality等。(影音多媒體的緩衝時間) CPU 的 Scheduling 應能支援 Priority Scheduling 且不能提供類似 Aging 技術。 可和分時系統、virtual memory 共存。 叢集系統 Clustered System 叢集系統共享儲存裝置，集合許多 CPU 並且經由 LAN 連線緊密地連結以完成工作。 叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。 Batch 較好的耐用度、安全性 常用於大量數據分析 常用於醫院、金融業 計算機一次只執行一件事 使用者與計算機的執行沒有互動性 CPU 時常處在閒置的狀態(因為 I/O speed 遠小於 CPU speed) OS 處理完一件事後，才將控制權交給下一個工作 Multi-programming 讓 I/O 與計算的工作可以同時進行，減少 CPU 閒置的時間。\nSpooling(Simultaneous Peripheral Operation On-Line)。\n但仍是一次執行一件事。 OS 的工作包含：\n記憶體管控。 系統必須分配記憶體給不同的程式 CPU 排程。 系統必須決定哪些程式要執行 I/O 系統。 系統提供 I/O 的排程與裝置的分配 Time-sharing System 使用者與系統間具有互動性\nCPU 頻繁的切換不同的工作，所以會有很多時間點可以接收 I/O。 使用者可以及時看到結果。 使用者感受像是同時進行的，但其實是很快速的切換在不同的工作之間。 OS 的工作包含：\nVirtual memory，從硬碟中借儲存空間出來，當作 memory 來使用。 檔案系統和硬碟管理。 同步化(Synchronization) 和 死鎖(deadlock)。 \\( \\def\\arraystretch{1.5}\\begin{array}{|c|c|c|c|}\\hline \u0026\\text{Batch}\u0026\\text{Multi-programming}\u0026\\text{Time-sharing}\\\\\\hline \\text{系統模型}\u0026\\text{單一使用者、單一作業}\u0026\\text{單一使用者、多作業排程}\u0026\\text{多使用者、作業平行處理}\\\\\\hline \\text{目的}\u0026\\text{簡單}\u0026\\text{增加資源利用效率(機本)}\u0026\\text{提升反應速度(人本)}\\\\\\hline \\text{特徵}\u0026\\text{N.A.}\u0026\\text{CPU 排程、記憶體管理、I/O系統}\u0026\\text{檔案系統、虛擬記憶體、同步化、死鎖}\\\\\\hline \\end{array} \\)\n電腦系統結構 桌面系統(Desktop Systems)：單處理器(single processor) PC(personal computer) GUI I/O devices: 鍵盤、滑書、螢幕、印表機… 多元的 OS Window, MacOS, Unix, Linux 缺乏檔案與作業系統的保護 木馬、病毒 平行系統(Parallel Systems)：多處理器(multiprocessor/tightly couplde system) 多核、或多 CPU。 通常共享記憶體 優點： Throughput: 提升計算能力 Economical: 很多裝置可以共用、節省成本 Reliability: 當其中一個 CPU 壞掉時，不會使得電腦完全無法操作。 分類： 對稱式多處理器系統 Symmetric multiprocessor system(SMP) 作業系統控制的每個處理器都扮演相同角色 大多 CPU 屬於這種 需要額外處理 synchronization 非對稱式多處理器系統Asymmetric multiprocessor system 每個處理器被指派處理不同的特殊工作 一個主要的 master CPU 與多個 slave CPUs 常見於極大的系統 多核處理器 Multi-Core Processor 在單一的 CPU 有多核 On-chip communication 比 between-chip communication 還快 One chip with multiple core 比 multiple single-core chips 還節能 Many-Core Processor Nvidia General-Purpose GPU 圖形處理器 Single Instruction Multiple Data 處理矩陣更快 Intel Xeon Phi TILE64 記憶體存取結構(Memory Access Architecture) 統一記憶體存取架構 Uniform memory access(UMA) 非統一記憶體存取架構 Non-uniform memory access(NUMA) 分散式系統(Distributed Systems)： ","wordCount":"423","inLanguage":"en","image":"https://intervalrain.github.io/images/os.png","datePublished":"2022-02-24T02:43:30+08:00","dateModified":"2022-02-24T02:43:30+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/os/lec1/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/os/>OSes</a></div><h1 class=post-title>[OS] Lec 1 - Introduction</h1><div class=post-description>概觀作業系統的歷史發展與進程</div><div class=post-meta>&lt;span title='2022-02-24 02:43:30 +0800 +0800'>February 24, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//OS/Lec1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/os.png alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80os-%e7%b0%a1%e4%bb%8b aria-label="一、OS 簡介">一、OS 簡介</a><ul><li><a href=#%e4%b8%80%e5%80%8b%e6%a8%99%e6%ba%96-pc-%e7%9a%84%e4%bd%9c%e6%a5%ad%e7%b3%bb%e7%b5%b1%e6%87%89%e8%a9%b2%e6%8f%90%e4%be%9b%e4%bb%a5%e4%b8%8b%e5%8a%9f%e8%83%bd aria-label="一個標準 PC 的作業系統應該提供以下功能：">一個標準 PC 的作業系統應該提供以下功能：</a></li><li><a href=#os-%e7%b3%bb%e7%b5%b1%e4%be%9d%e5%a4%a7%e5%b0%8f%e4%be%86%e5%8d%80%e5%88%86 aria-label="OS 系統依大小來區分：">OS 系統依大小來區分：</a></li><li><a href=#%e4%be%9d%e5%93%81%e7%89%8c%e4%be%86%e5%8d%80%e5%88%86 aria-label=依品牌來區分：>依品牌來區分：</a></li></ul></li><li><a href=#%e4%ba%8c%e5%b8%b8%e8%a6%8b%e7%9a%84%e7%b3%bb%e7%b5%b1%e9%a1%9e%e5%9e%8b aria-label=二、常見的系統類型>二、常見的系統類型</a><ul><li><a href=#batch aria-label=Batch>Batch</a></li><li><a href=#multi-programming aria-label=Multi-programming>Multi-programming</a></li><li><a href=#time-sharing-system aria-label="Time-sharing System">Time-sharing System</a></li></ul></li><li><a href=#%e9%9b%bb%e8%85%a6%e7%b3%bb%e7%b5%b1%e7%b5%90%e6%a7%8b aria-label=電腦系統結構>電腦系統結構</a><ul><li><a href=#%e6%a1%8c%e9%9d%a2%e7%b3%bb%e7%b5%b1desktop-systems%e5%96%ae%e8%99%95%e7%90%86%e5%99%a8single-processor aria-label="桌面系統(Desktop Systems)：單處理器(single processor)">桌面系統(Desktop Systems)：單處理器(single processor)</a></li><li><a href=#%e5%b9%b3%e8%a1%8c%e7%b3%bb%e7%b5%b1parallel-systems%e5%a4%9a%e8%99%95%e7%90%86%e5%99%a8multiprocessortightly-couplde-system aria-label="平行系統(Parallel Systems)：多處理器(multiprocessor/tightly couplde system)">平行系統(Parallel Systems)：多處理器(multiprocessor/tightly couplde system)</a><ul><li><a href=#%e5%a4%9a%e6%a0%b8%e8%99%95%e7%90%86%e5%99%a8-multi-core-processor aria-label="多核處理器 Multi-Core Processor">多核處理器 Multi-Core Processor</a></li><li><a href=#many-core-processor aria-label="Many-Core Processor">Many-Core Processor</a></li><li><a href=#%e8%a8%98%e6%86%b6%e9%ab%94%e5%ad%98%e5%8f%96%e7%b5%90%e6%a7%8bmemory-access-architecture aria-label="記憶體存取結構(Memory Access Architecture)">記憶體存取結構(Memory Access Architecture)</a></li><li><a href=#%e7%b5%b1%e4%b8%80%e8%a8%98%e6%86%b6%e9%ab%94%e5%ad%98%e5%8f%96%e6%9e%b6%e6%a7%8b-uniform-memory-accessuma aria-label="統一記憶體存取架構 Uniform memory access(UMA)">統一記憶體存取架構 Uniform memory access(UMA)</a></li><li><a href=#%e9%9d%9e%e7%b5%b1%e4%b8%80%e8%a8%98%e6%86%b6%e9%ab%94%e5%ad%98%e5%8f%96%e6%9e%b6%e6%a7%8b-non-uniform-memory-accessnuma aria-label="非統一記憶體存取架構 Non-uniform memory access(NUMA)">非統一記憶體存取架構 Non-uniform memory access(NUMA)</a></li></ul></li><li><a href=#%e5%88%86%e6%95%a3%e5%bc%8f%e7%b3%bb%e7%b5%b1distributed-systems aria-label="分散式系統(Distributed Systems)：">分散式系統(Distributed Systems)：</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=一os-簡介>一、OS 簡介<a hidden class=anchor aria-hidden=true href=#一os-簡介>#</a></h1><p>作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：</p><ul><li>資源分配者</li><li>監控使用者程式的執行，以防止不正常的運作造成對系統的危害。</li></ul><h2 id=一個標準-pc-的作業系統應該提供以下功能>一個標準 PC 的作業系統應該提供以下功能：<a hidden class=anchor aria-hidden=true href=#一個標準-pc-的作業系統應該提供以下功能>#</a></h2><ul><li>行程管理 (processing management)</li><li>記憶體管理 (memory management)</li><li>檔案系統 (file system)</li><li>網路通訊 (networking)</li><li>安全機制 (security)</li><li>使用者介面 (user integerface)</li><li>驅動程式 (device drivers)</li></ul><h2 id=os-系統依大小來區分>OS 系統依大小來區分：<a hidden class=anchor aria-hidden=true href=#os-系統依大小來區分>#</a></h2><ul><li>大型電腦：IBM OS/360</li><li>個人電腦：Windows、Linux、BSD、Mac OS X</li><li>嵌入式：VxWorks、eCos、Sysbian OS、Palm OS</li></ul><h2 id=依品牌來區分>依品牌來區分：<a hidden class=anchor aria-hidden=true href=#依品牌來區分>#</a></h2><ul><li>類 Unix 家族：包含 System V、BSD 與 Linux。</li><li>微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。</li><li>蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統</li><li>Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。</li></ul><p><img loading=lazy src=/images/OSillustration.png alt=OSillustration>
<img loading=lazy src=/images/LinuxFrame.png alt=LinuxFrame></p><h1 id=二常見的系統類型>二、常見的系統類型<a hidden class=anchor aria-hidden=true href=#二常見的系統類型>#</a></h1><ol><li>Multiprogramming System</li></ol><ul><li>系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel))</li><li><strong>Multiprogramming Degree</strong>：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 <a href="https://en.wikipedia.org/wiki/Thrashing_(computer_science)?msclkid=538c57fda94411ecab513fc0770bc011">Thrashing</a> 現象)<ul><li>當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。<ul><li>[方法1] 降低 Multiprogramming Degree</li><li>[方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。</li><li>[方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。</li></ul></li></ul></li></ul><ol start=2><li>分時系統 Time Sharing System</li></ol><ul><li>Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。</li><li>常見配置：<ul><li>行程排程採用 RR 排程(<a href="https://en.wikipedia.org/wiki/Round-robin_scheduling?msclkid=b581068fa94511ecb177ee89989dbbee">Round-robin scheduling</a>)</li><li>記憶體空間所有使用者分享</li><li>使用虛擬記憶體技術</li><li>I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。</li></ul></li></ul><ol start=3><li>分散式系統 Distributed System</li></ol><ul><li><p>須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：</p><ul><li>Client-Server System</li><li>Peer-to-peer</li></ul></li><li><p>舉例：志願計算，使用志願者電腦的閒置計算力，透過網際網路進行資料傳輸(如 Folding@home 蛋白質摺疊研究計畫)</p></li><li><p>分散式系統的好處：</p><ul><li>資源共享 (Resource sharing)</li><li>加快計算速度 (Speed up)</li><li>可靠性 (Reliability)：指不容易因為一台電腦 shut down 而全部崩潰</li><li>通訊需求 (Coummunication Need)</li></ul><p>補充：勿將 Multiprocessor 與分散式系統混為一談</p><ul><li>Symmetric Multiprocessing (SMP)：對稱式多元處理，每一個處理器具有相同的功能，可靠度高，強調負載平衡。</li><li>Asymmetric Multiprocessing (ASMP)：非對稱式多元處理，Master/Slave 架構。</li></ul></li></ul><ol start=4><li>即時系統 Real Time System</li></ol><ul><li>定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。<ul><li>硬性即時系統(Hard Real Time Sydstem)：對於完成工作的時間有極嚴格的限制。若 Prcess 未能於規定的時間內完成，則 Process 即屬失效。(意義同即時系統之定義)<ul><li>工廠自動化系統、軍事系統、核能安控等。</li><li>Application Program 設計上非常重要。</li><li>Data 及 Program 皆存在 ROM 或 RAM 中。</li><li>不使用虛擬記憶體，因為 Page Fault 的處理時間過長。</li><li>減少 os 的干預以降低 Dispatch Latency。</li></ul></li><li>軟性即時系統(Soft Real Time System)：保證高優先權的 Process 必須先於所有低優先權的 Process 完成。<ul><li>Multimedia System、Virtual Reality等。(影音多媒體的緩衝時間)</li><li>CPU 的 Scheduling 應能支援 Priority Scheduling 且不能提供類似 Aging 技術。</li><li>可和分時系統、virtual memory 共存。</li></ul></li></ul></li></ul><ol start=5><li>叢集系統 Clustered System</li></ol><ul><li>叢集系統共享儲存裝置，集合許多 CPU 並且經由 LAN 連線緊密地連結以完成工作。</li><li>叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。</li></ul><h2 id=batch>Batch<a hidden class=anchor aria-hidden=true href=#batch>#</a></h2><ul><li>較好的耐用度、安全性</li><li>常用於大量數據分析</li><li>常用於醫院、金融業</li><li>計算機一次只執行一件事</li><li>使用者與計算機的執行沒有互動性</li><li>CPU 時常處在閒置的狀態(因為 I/O speed 遠小於 CPU speed)</li><li>OS 處理完一件事後，才將控制權交給下一個工作</li></ul><h2 id=multi-programming>Multi-programming<a hidden class=anchor aria-hidden=true href=#multi-programming>#</a></h2><ul><li><p>讓 I/O 與計算的工作可以同時進行，減少 CPU 閒置的時間。</p></li><li><p><strong>Spooling</strong>(Simultaneous Peripheral Operation On-Line)。</p></li><li><p>但仍是一次執行一件事。
<img loading=lazy src=/images/multiprogramming.png alt=multiprogramming>
<img loading=lazy src=/images/scheduling.png alt=scheduling></p></li><li><p>OS 的工作包含：</p><ul><li>記憶體管控。<ul><li>系統必須分配記憶體給不同的程式</li></ul></li><li>CPU 排程。<ul><li>系統必須決定哪些程式要執行</li></ul></li><li>I/O 系統。<ul><li>系統提供 I/O 的排程與裝置的分配</li></ul></li></ul></li></ul><h2 id=time-sharing-system>Time-sharing System<a hidden class=anchor aria-hidden=true href=#time-sharing-system>#</a></h2><ul><li><p>使用者與系統間具有互動性</p><ul><li>CPU 頻繁的切換不同的工作，所以會有很多時間點可以接收 I/O。</li><li>使用者可以及時看到結果。</li><li>使用者感受像是同時進行的，但其實是很快速的切換在不同的工作之間。</li></ul></li><li><p>OS 的工作包含：</p><ul><li>Virtual memory，從硬碟中借儲存空間出來，當作 memory 來使用。</li><li>檔案系統和硬碟管理。</li><li>同步化(Synchronization) 和 死鎖(deadlock)。</li></ul></li></ul><p>\(
\def\arraystretch{1.5}\begin{array}{|c|c|c|c|}\hline
&\text{Batch}&\text{Multi-programming}&\text{Time-sharing}\\\hline
\text{系統模型}&\text{單一使用者、單一作業}&\text{單一使用者、多作業排程}&\text{多使用者、作業平行處理}\\\hline
\text{目的}&\text{簡單}&\text{增加資源利用效率(機本)}&\text{提升反應速度(人本)}\\\hline
\text{特徵}&\text{N.A.}&\text{CPU 排程、記憶體管理、I/O系統}&\text{檔案系統、虛擬記憶體、同步化、死鎖}\\\hline
\end{array}
\)</p><h1 id=電腦系統結構>電腦系統結構<a hidden class=anchor aria-hidden=true href=#電腦系統結構>#</a></h1><h2 id=桌面系統desktop-systems單處理器single-processor>桌面系統(Desktop Systems)：單處理器(single processor)<a hidden class=anchor aria-hidden=true href=#桌面系統desktop-systems單處理器single-processor>#</a></h2><ul><li>PC(personal computer)</li><li>GUI</li><li>I/O devices: 鍵盤、滑書、螢幕、印表機…</li><li>多元的 OS<ul><li>Window, MacOS, Unix, Linux</li></ul></li><li>缺乏檔案與作業系統的保護<ul><li>木馬、病毒</li></ul></li></ul><h2 id=平行系統parallel-systems多處理器multiprocessortightly-couplde-system>平行系統(Parallel Systems)：多處理器(multiprocessor/tightly couplde system)<a hidden class=anchor aria-hidden=true href=#平行系統parallel-systems多處理器multiprocessortightly-couplde-system>#</a></h2><p><img loading=lazy src=/images/%08systembus.png alt=systembus></p><ul><li>多核、或多 CPU。</li><li>通常共享記憶體</li><li>優點：<ul><li>Throughput: 提升計算能力</li><li>Economical: 很多裝置可以共用、節省成本</li><li>Reliability: 當其中一個 CPU 壞掉時，不會使得電腦完全無法操作。</li></ul></li><li>分類：<ul><li>對稱式多處理器系統 Symmetric multiprocessor system(SMP)<ul><li>作業系統控制的每個處理器都扮演相同角色</li><li>大多 CPU 屬於這種</li><li>需要額外處理 synchronization</li></ul></li><li>非對稱式多處理器系統Asymmetric multiprocessor system<ul><li>每個處理器被指派處理不同的特殊工作</li><li>一個主要的 master CPU 與多個 slave CPUs</li><li>常見於極大的系統</li></ul></li></ul></li></ul><h3 id=多核處理器-multi-core-processor>多核處理器 Multi-Core Processor<a hidden class=anchor aria-hidden=true href=#多核處理器-multi-core-processor>#</a></h3><ul><li>在單一的 CPU 有多核</li><li>On-chip communication 比 between-chip communication 還快</li><li>One chip with multiple core 比 multiple single-core chips 還節能</li></ul><h3 id=many-core-processor>Many-Core Processor<a hidden class=anchor aria-hidden=true href=#many-core-processor>#</a></h3><ul><li>Nvidia General-Purpose GPU 圖形處理器<ul><li>Single Instruction Multiple Data</li><li>處理矩陣更快</li></ul></li><li>Intel Xeon Phi</li><li>TILE64</li></ul><h3 id=記憶體存取結構memory-access-architecture>記憶體存取結構(Memory Access Architecture)<a hidden class=anchor aria-hidden=true href=#記憶體存取結構memory-access-architecture>#</a></h3><h3 id=統一記憶體存取架構-uniform-memory-accessuma>統一記憶體存取架構 Uniform memory access(UMA)<a hidden class=anchor aria-hidden=true href=#統一記憶體存取架構-uniform-memory-accessuma>#</a></h3><h3 id=非統一記憶體存取架構-non-uniform-memory-accessnuma>非統一記憶體存取架構 Non-uniform memory access(NUMA)<a hidden class=anchor aria-hidden=true href=#非統一記憶體存取架構-non-uniform-memory-accessnuma>#</a></h3><h2 id=分散式系統distributed-systems>分散式系統(Distributed Systems)：<a hidden class=anchor aria-hidden=true href=#分散式系統distributed-systems>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/os/>OS</a></li><li><a href=https://intervalrain.github.io/tags/programming/>Programming</a></li><li><a href=https://intervalrain.github.io/tags/computer-science/>Computer Science</a></li></ul></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>