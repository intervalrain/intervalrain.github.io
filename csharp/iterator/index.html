<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[C#] IEnumerable & IEnumerator 迭代器 | Rain Hu's Workspace</title><meta name=keywords content="C#,IEnumerable,IEnumerator,迭代器"><meta name=description content="Introduction to Iterator in C#, including IEnumerator and IEnumerable"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/csharp/iterator/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/csharp/iterator/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[C#] IEnumerable & IEnumerator 迭代器"><meta property="og:description" content="Introduction to Iterator in C#, including IEnumerator and IEnumerable"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="csharp"><meta property="article:published_time" content="2023-02-27T11:50:20+08:00"><meta property="article:modified_time" content="2023-02-27T11:50:20+08:00"><meta property="article:tag" content="C#"><meta name=twitter:card content="summary"><meta name=twitter:title content="[C#] IEnumerable & IEnumerator 迭代器"><meta name=twitter:description content="Introduction to Iterator in C#, including IEnumerator and IEnumerable"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Csharps","item":"https://intervalrain.github.io/csharp/"},{"@type":"ListItem","position":2,"name":"[C#] IEnumerable \u0026 IEnumerator 迭代器","item":"https://intervalrain.github.io/csharp/iterator/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[C#] IEnumerable \u0026 IEnumerator 迭代器","name":"[C#] IEnumerable \u0026 IEnumerator 迭代器","description":"Introduction to Iterator in C#, including IEnumerator and IEnumerable","keywords":["C#","IEnumerable","IEnumerator","迭代器"],"articleBody":"1. 簡介 迭代器包含了以下四種類型 IEnumerable IEnumerable IEnumerator IEnumerator 根據迭代器的返回類型，每個迭代器都有一個 yield type。 IEnuerable 返回 object IEnuerable 返回 string 基本的語法為： public static IEnumerable GetFibonacciSeries(int end) { int cnt = 0; int prev = 0; int curr = 1; while (true) { if (cnt == end) yield break; cnt++; int tmp = curr + prev; yield return curr; prev = curr; curr = tmp; } } public static void Main(string[] args) { foreach(int val in GetFibonacciSeries(10)) { Console.WriteLine(val); } } 2. 延遲執行 雖然同樣的程式可以用 List 的方式重新寫成下面的程式碼，其列印結果也會一樣，但在執行期卻會有很大的差異。 public static List GetFibonacciSeriesList(int end) { int cnt = 0; int prev = 0; int curr = 1; List res = new List(); while (true) { if (cnt == end) break; cnt++; int tmp = curr + prev; res.Add(curr); prev = curr; curr = tmp; } return res; } public static void Main(string[] args) { foreach(int val in GetFibonacciSeriesList(10)) { Console.WriteLine(val); } } 延遲執行屬於 lambda 演算的一部分，目的是「只在需要獲取計算結果時執行程式」。 public static void Main(string[] args) { // 調用迭代器的方法，從 IEnumerable 取得 IEnumerator using (var reader = GetFibonacciSeries(10).GetEnumerator()) { while (reader.MoveNext()) { int val = reader.Current; Console.WriteLine(val); } } } 以上兩段程式碼兩段程式碼在執行期的差別為： 前者在執行到 foreach(int val in GetFibonacciSeriesList(10)) 時，會先將 GetFibonacciSeriesList(10) 執行完取得 List 之後才開始 for loop。 後者在執行到 MoveNext() 時，程式碼才真正被執行。 執行 yield 語句時，程式碼會停止執行： 拋出 exception 方法執行完畢 遇到 yield break 執行到 yield return，迭代器準備返回值。 那麼延遲執行有什麼好處呢？ 不必預先創建一個 List，在 List 本身很大的情況下，可以節省空間。 試想今天的數列是無窮無盡的(如上例的 fibonacci 數列)，使用 List 就顯得太冗餘了。 使用迭代器可以達到 Design Pattern 中的關注點分離(Iteration/Process 分離)，也就是說，在叫用迭代器時，只需關心有沒有辦法迭代到下一個元素。 程式只需完成需求即可退出，大大的增加效率。 試想今天需要向資料庫拿去十筆最新的資料，若不用延遲執行的話，需要將整筆資料庫的資料用某種資料結構儲存下來，再 for-loop 取出十筆。 若使用延遲執行，取得十筆資料就立即退出，可以大大減少執行時間。 3. finally 的處理 觀察下面的程式碼，並對照輸出結果，可以發現，只有出現一次的 In finally block。 只有在執行了 IEnumerator.Dispose() 方法時，才會調用 finally 的區塊。 而每次的 IEnumerator.MoveNext() 都會使程式停止在 yield return。 不管是用 using 搭配 IEnumerable.GetEnumerator()，或是使用 foreach(var val in Iterator()) 回傳的結果都是只有出現一次的 In finally block，代表後者隱含了一條 using 的語句。 public static IEnumerable Iterator() { try { Console.WriteLine(\"Before first yield\"); yield return \"first\"; Console.WriteLine(\"Between yields\"); yield return \"second\"; Console.WriteLine(\"After yields\"); } finally { Console.WriteLine(\"In finally block\"); } } public static void Main(string[] args) { using (var reader = Iterator().GetEnumerator()) { while (reader.MoveNext()) { string val = reader.Current; Console.WriteLine(val); } } } // Before first yield // first // Between yields // second // After yields // In finally block 更多詳細的介紹詳見 [C#] Yield Return ","wordCount":"327","inLanguage":"zh-tw","datePublished":"2023-02-27T11:50:20+08:00","dateModified":"2023-02-27T11:50:20+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/csharp/iterator/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/csharp/>Csharps</a></div><h1 class="post-title entry-hint-parent">[C#] IEnumerable & IEnumerator 迭代器</h1><div class=post-description>Introduction to Iterator in C#, including IEnumerator and IEnumerable</div><div class=post-meta><span title='2023-02-27 11:50:20 +0800 +0800'>February 27, 2023</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//Csharp/iterator.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#1-%e7%b0%a1%e4%bb%8b aria-label="1. 簡介">1. 簡介</a></li><li><a href=#2-%e5%bb%b6%e9%81%b2%e5%9f%b7%e8%a1%8c aria-label="2. 延遲執行">2. 延遲執行</a></li><li><a href=#3-finally-%e7%9a%84%e8%99%95%e7%90%86 aria-label="3. finally 的處理">3. finally 的處理</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=1-簡介>1. 簡介<a hidden class=anchor aria-hidden=true href=#1-簡介>#</a></h2><ul><li>迭代器包含了以下四種類型<ul><li><code>IEnumerable</code></li><li><code>IEnumerable&lt;T></code></li><li><code>IEnumerator</code></li><li><code>IEnumerator&lt;T></code></li></ul></li><li>根據迭代器的返回類型，每個迭代器都有一個 <code>yield type</code>。<ul><li><code>IEnuerable</code> 返回 <code>object</code></li><li><code>IEnuerable&lt;string></code> 返回 <code>string</code></li></ul></li><li>基本的語法為：</li></ul><pre tabindex=0><code class=language-Cs data-lang=Cs>public static IEnumerable&lt;int&gt; GetFibonacciSeries(int end)
{
    int cnt = 0;
    int prev = 0;
    int curr = 1;
    while (true)
    {
        if (cnt == end) yield break;
        cnt++;
        int tmp = curr + prev;
        yield return curr;
        prev = curr;   
        curr = tmp;
    }
}
public static void Main(string[] args)
{
    
    foreach(int val in GetFibonacciSeries(10))
    {
        Console.WriteLine(val);
    }
}    
</code></pre><h2 id=2-延遲執行>2. 延遲執行<a hidden class=anchor aria-hidden=true href=#2-延遲執行>#</a></h2><ul><li>雖然同樣的程式可以用 <code>List&lt;T></code> 的方式重新寫成下面的程式碼，其列印結果也會一樣，但在執行期卻會有很大的差異。</li></ul><pre tabindex=0><code class=language-Cs data-lang=Cs>public static List&lt;int&gt; GetFibonacciSeriesList(int end)
{
    int cnt = 0;
    int prev = 0;
    int curr = 1;
    List&lt;int&gt; res = new List&lt;int&gt;();
    while (true)
    {
        if (cnt == end) break;
        cnt++;
        int tmp = curr + prev;
        res.Add(curr);
        prev = curr;
        curr = tmp;
    }
    return res;
}
public static void Main(string[] args)
{
    foreach(int val in GetFibonacciSeriesList(10))
    {
        Console.WriteLine(val);
    }
}    
</code></pre><ul><li>延遲執行屬於 lambda 演算的一部分，目的是「<strong>只在需要獲取計算結果時執行程式</strong>」。</li></ul><pre tabindex=0><code class=language-Cs data-lang=Cs>public static void Main(string[] args)
{
    // 調用迭代器的方法，從 IEnumerable&lt;T&gt; 取得 IEnumerator&lt;T&gt;
    using (var reader = GetFibonacciSeries(10).GetEnumerator())
    {
        while (reader.MoveNext())
        {
            int val = reader.Current;
            Console.WriteLine(val);
        }
    }
} 
</code></pre><ul><li>以上兩段程式碼兩段程式碼在執行期的差別為：<ul><li>前者在執行到 <code>foreach(int val in GetFibonacciSeriesList(10))</code> 時，會先將 <code>GetFibonacciSeriesList(10)</code> 執行完取得 <code>List&lt;int></code> 之後才開始 <code>for loop</code>。</li><li>後者在執行到 <code>MoveNext()</code> 時，程式碼才真正被執行。</li></ul></li><li>執行 <code>yield</code> 語句時，程式碼會停止執行：<ul><li>拋出 exception</li><li>方法執行完畢</li><li>遇到 yield break</li><li>執行到 yield return，迭代器準備返回值。</li></ul></li><li>那麼延遲執行有什麼好處呢？<ul><li>不必預先創建一個 <code>List&lt;int></code>，在 List 本身很大的情況下，可以節省空間。</li><li>試想今天的數列是無窮無盡的(如上例的 fibonacci 數列)，使用 <code>List&lt;int></code> 就顯得太冗餘了。</li><li>使用迭代器可以達到 Design Pattern 中的<strong>關注點分離</strong>(Iteration/Process 分離)，也就是說，在叫用迭代器時，只需關心有沒有辦法迭代到下一個元素。</li><li>程式只需完成需求即可退出，大大的增加效率。<ul><li>試想今天需要向資料庫拿去十筆最新的資料，若不用延遲執行的話，需要將整筆資料庫的資料用某種資料結構儲存下來，再 for-loop 取出十筆。</li><li>若使用延遲執行，取得十筆資料就立即退出，可以大大減少執行時間。</li></ul></li></ul></li></ul><h2 id=3-finally-的處理>3. finally 的處理<a hidden class=anchor aria-hidden=true href=#3-finally-的處理>#</a></h2><ul><li>觀察下面的程式碼，並對照輸出結果，可以發現，只有出現一次的 <code>In finally block</code>。<ul><li>只有在執行了 <code>IEnumerator&lt;T>.Dispose()</code> 方法時，才會調用 finally 的區塊。</li><li>而每次的 <code>IEnumerator&lt;T>.MoveNext()</code> 都會使程式停止在 <code>yield return</code>。</li></ul></li><li>不管是用 <code>using</code> 搭配 <code>IEnumerable.GetEnumerator()</code>，或是使用 <code>foreach(var val in Iterator())</code> 回傳的結果都是只有出現一次的 <code>In finally block</code>，代表後者隱含了一條 <code>using</code> 的語句。</li></ul><pre tabindex=0><code class=language-Cs data-lang=Cs>public static IEnumerable&lt;string&gt; Iterator()
{
    try 
    {
        Console.WriteLine(&#34;Before first yield&#34;);
        yield return &#34;first&#34;;
        Console.WriteLine(&#34;Between yields&#34;);
        yield return &#34;second&#34;;
        Console.WriteLine(&#34;After yields&#34;);    
    }
    finally
    {
        Console.WriteLine(&#34;In finally block&#34;);
    }
    
}
public static void Main(string[] args)
{
    using (var reader = Iterator().GetEnumerator())
    {
        while (reader.MoveNext())
        {
            string val = reader.Current;
            Console.WriteLine(val);
        }
    }
}   
// Before first yield
// first
// Between yields
// second
// After yields
// In finally block
</code></pre><ul><li>更多詳細的介紹詳見 <a href=/csharp/yield/>[C#] Yield Return</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/c%23/>C#</a></li></ul><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>