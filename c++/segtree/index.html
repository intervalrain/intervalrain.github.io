<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[C++] Segment Tree | Rain Hu's Workspace</title><meta name=keywords content="Segment Tree,線段樹,zkw,C++"><meta name=description content="用 C++ 介紹資料結構線段樹"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/c++/segtree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/c++/segtree/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[C++] Segment Tree"><meta property="og:description" content="用 C++ 介紹資料結構線段樹"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="c++"><meta property="article:published_time" content="2022-10-18T23:14:38+08:00"><meta property="article:modified_time" content="2022-10-18T23:14:38+08:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Programming"><meta property="og:image" content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[C++] Segment Tree"><meta name=twitter:description content="用 C++ 介紹資料結構線段樹"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"C++s","item":"https://intervalrain.github.io/c++/"},{"@type":"ListItem","position":2,"name":"[C++] Segment Tree","item":"https://intervalrain.github.io/c++/segtree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[C++] Segment Tree","name":"[C\u002b\u002b] Segment Tree","description":"用 C++ 介紹資料結構線段樹","keywords":["Segment Tree","線段樹","zkw","C++"],"articleBody":"線段樹 Segment Tree 簡介 線段樹是演算法中常用來維護區間訊息的資料結構。 空間複雜度為 \\(O(n)\\)，\\(n\\) 代表區間數。 查詢的時間複雜度為 \\(O(\\log n+k)\\)，\\(k\\) 代表符合條件的區間數量。 線段樹將每個長度為為 1 的區間劃分為左右兩個區間遞迴求解，把整個線段劃分為一個樹型結構，通過合併左右兩個區間訊息來求得該區間的訊息。 在實現時，我們考慮遞迴建樹，設當前的根節點為 root，如果根節點管轄的區間長度已經是 1，則可以直接根據數組上相應位置的值初始化該節點。否則需將該區間從中點處分割為兩個子區間，分別進入左右子節點遞迴建樹，最後合併兩個子節點的訊息， 建樹 build void build(int s, int t, int p, const vector\u003cint\u003e\u0026 arr){ if (s == t){ tree[p] = SegmentItem(arr[s], 1); return; } int m = s + ((t - s) \u003e\u003e 1); build(s, m, p*2, arr); build(m+1, t, p*2+1, arr); // push_up tree[p] = tree[p*2] + tree[(p*2)+1]; } 查詢 query SegmentItem find(int l, int r, int s, int t, int p){ if (l \u003c= s \u0026\u0026 t \u003c= r){ return tree[p]; } int m = s + ((t - s) \u003e\u003e 1); SegmentItem sum; if (r \u003c= m) return find(l, r, s, m, p*2); if (l \u003e m) return find(l, r, m+1, t, p*2+1); return find(l, r, s, m, p*2) + find(l, r, m+1, t, p*2+1); } zkw 線段樹 來自清華大學張昆瑋(zkw)-《統計的力量》 以非遞迴的方式構建，效率更高，程式更短。 普通的線段樹是從上到下做處理，容易定位根節點，卻不容易定位子節點。 zkw 線段樹是當二叉樹是滿二叉樹時，因為子節點的編號具有以下規律： 葉子節點(left) 全部退化為線段 \\([x,x]\\) 。 \\(n\\) 個數據點則取大於等 \\(n\\)且為 \\(2\\) 的冪次的兩倍作為數組大小。 \\((m=2^a\\ge n)\\) for (int m = 1; m \u003c= n; m \u003e\u003e= 1) 維護點為 \\(n\\) 個。索引為\\([m,m+n)\\)。 子葉數目為 \\(m\\) 個。索引為\\([m,2m)\\) 節點數為 \\(2m-1\\) 個。(數組大小需設 \\(2m\\) 因為 zkw tree是 1-index的) 樹高 \\(H=\\log_2(m)+1\\) 層。 第 \\(h\\) 層有 \\(2^{h-1}\\) 個節點， 該層線段長度為 \\(2^{H-h}\\)。 若某節點為 \\(p\\)，父節點為 \\(p/2\\)，子節點為 \\(2p\\) 和 \\(2p+1\\) int parent = p \u003e\u003e 1; int left = p \u003c\u003c 1; int right = p \u003c\u003c 1 | 1; 若兩節點為 \\(p\\) 與 \\(q\\)，且兩節點互為兄弟節點，則 \\(p\\oplus q=1\\) if (left ^ right) // left 與 right 為兄弟節點 else // left 與 right 不為兄弟節點 除根節點外，左節點皆為偶數，右節點皆為奇數 if (i == 1) // i 為根節點 else if (i \u0026 1) // i 為奇數，為右節點 else if (!(i \u0026 1)) // i 為偶數，為左節點 結構 線段樹索引堆疊： 轉成二進制： 規律： 一個節點的父節點是該數右移 1，低位捨棄。 一個節點的左子節點是該數左移 1，右子節點是該數左移 1 再加 1。 同一層的節點是依次遞增的，第 \\(n\\) 層有 \\(2^{n-1}\\)個節點 最後一層有多少個節點，值域就是多少。 建樹 build 取 m 值有許多版本，有些版本會直接取 \\(m=2^{log_2(n+5)+1}\\)以節省迭代計算 寫成 int n = 1 \u003c\u003c __lg(n+5)+1; 可以有開區間與閉區間兩種做法，差別在於從子葉節點的最左邊 \\(m+i\\) 開始，或是第二個子葉節點 \\(m+1+i\\) 開始。 由下而上更新時，開區間與閉區間的終止條件不同： 開區間的終止條件為兩子節點互為兄弟節點 while (i^j^1) // operation 閉區間的終止條件為右節點小於左節點 while (i \u003c= j) // operation class Tree { private: vector\u003cint\u003e arr; int n, m; // n 為維護點數, m 為 zkw-tree 子葉節點數 public: Tree (vector\u003cint\u003e\u0026 nums){ n = nums.size(); for (m = 1; m \u003c= n; m \u003c\u003c= 1); // 取大於等於 n 且為 2 的冪次的最小整數 arr.assign(2*m, 0); // 節點數設為 2m 個，其中 0 為空節點 } void build(vector\u003cint\u003e nums){ for (int i = 0; i \u003c n; i++) { arr[i+m] = nums[i]; // 從子葉節點最左邊往右更新節點。 mx[i+m] = nums[i]; mn[i+m] = nums[i]; } for (int i = m-1; i; i--){ // 向上更新父節點。 arr[i] = in(x); } } }; 根據不同需求代換 \\(\\text{in(x)}\\)：取和、最大值、最小平 // 取和 arr[i] = arr[i\u003c\u003c1] + arr[i\u003c\u003c1|1]; // 取最大值 arr[i] = max(arr[i\u003c\u003c1], arr[i\u003c\u003c1|1]); // 取最小值 arr[i] = min(arr[i\u003c\u003c1], arr[i\u003c\u003c1|1]); 更新 update 單點修改(以和為例) 更新時，以差分方式，將所有父節點加上更新點的差值。 void update(int i, int val){ int diff = val - arr[m+i] // 原值 arr[m+i] 與新值 val 的差 for (i += m; i; i \u003e\u003e= 1){ arr[i] += diff; } } 查詢 query 單點查詢(以和為例)：閉區間做法 判斷左邊界是否為右節點，若為右節點則加上後往右邊的父節點移動。 判斷右邊界是否為左節點，若為左節點則加上後往左邊的父節點移動。 int query(int left, int right){ int sum = 0; int i = left+m; // 左閉區間 int j = right+m; // 右閉區間 for (; i \u003c= j; i \u003e\u003e= 1, j \u003e\u003e= 1){ if (i \u0026 1) sum += arr[i++]; if (!(j \u0026 1)) sum += arr[j--]; } return sum; } 備註：開區間作法 (0-index 時會出現 -1 的情形，建議使用閉區間) int query(int left, int right){ int sum = 0; int i = left+m-1; int j = right+m+1; for(; i^j^1; i \u003e\u003e= 1, j \u003e\u003e= 1){ if (~i \u0026 1) sum += arr[i^1]; if (j \u0026 1) sum += arr[j^1]; } return sum; } 區間修改 在非遞迴的情況下，標記下傳是比較困難的，所以作法上改成將標記永久化。 具體而言，與查詢類似，當左端點是左子節點且右端點是右子節點時，我們對它的兄弟節點進行修改並標記，表示這顆子樹中的每個節點都要被修改。但單純這樣還不夠，因上述修改還會波及到這些節點的各級祖先，所以我們需要在途中根據實際修改的區間長度來更新各級祖先的值，這種操作需要一路上推到根節點。 (開區間作法) void update(int left, int right, int diff){ int len = 1, cntl = 0, cntr = 0; // cntl, cntr 是左右邊分別實際修改的區間長度 left += m-1; right += m+1; for (; left^right^1; left \u003e\u003e 1, right \u003e\u003e 1, len \u003c\u003c 1){ arr[left] += cntl * diff; arr[right] += cntr * diff; if (~left \u0026 1) { arr[left^1] += diff * len; mark[left^1] += diff; cntl += len; } if (right \u0026 1) { arr[right^1] += diff * len; mark[right^1] += diff; cntr += len; } } for (; left; left \u003e\u003e= 1, right \u003e\u003e= 1){ arr[left] += cntl * diff; arr[right] += cntr * diff; } } 在有區間修改存在時，區間查詢也需要考慮標記的影響。 所以除了加上端點的兄弟節點訊息，沿途中遇到的標記也對答案有貢獻，同樣需要上推到根節點。 int query(int left, int right){ int sum = 0, len = 1, cntl = 0, cntr = 0; left += m - 1; right += m + 1; for (; left^right^1; left \u003e\u003e= 1, right \u003e\u003e= 1, len \u003c\u003c 1){ sum += cntl * mark[left] + cntr * mark[right]; if (~left \u0026 1) sum += arr[left^1], cntl += len; if (right \u0026 1) sum += arr[right^1], cntr += len; } for (; left; left \u003e\u003e 1, right \u003e\u003e 1){ sum += cntl * mark[left] + cntr * mark[right]; } return sum; } 區間查詢最大值： void update(int l, int r, int d) { for (l += N - 1, r += N + 1; l ^ r ^ 1; l \u003e\u003e= 1, r \u003e\u003e= 1) { if (l \u003c N) tree[l] = max(tree[l \u003c\u003c 1], tree[l \u003c\u003c 1 | 1]) + mark[l], tree[r] = max(tree[r \u003c\u003c 1], tree[r \u003c\u003c 1 | 1]) + mark[r]; if (~l \u0026 1) tree[l ^ 1] += d, mark[l ^ 1] += d; if (r \u0026 1) tree[r ^ 1] += d, mark[r ^ 1] += d; } for (; l; l \u003e\u003e= 1, r \u003e\u003e= 1) if (l \u003c N) tree[l] = max(tree[l \u003c\u003c 1], tree[l \u003c\u003c 1 | 1]) + mark[l], tree[r] = max(tree[r \u003c\u003c 1], tree[r \u003c\u003c 1 | 1]) + mark[r]; }; int query(int l, int r) { int maxl = -INF, maxr = -INF; for (l += N - 1, r += N + 1; l ^ r ^ 1; l \u003e\u003e= 1, r \u003e\u003e= 1) { maxl += mark[l], maxr += mark[r]; if (~l \u0026 1) cmax(maxl, tree[l ^ 1]); if (r \u0026 1) cmax(maxr, tree[r ^ 1]); } for (; l; l \u003e\u003e= 1, r \u003e\u003e= 1) maxl += mark[l], maxr += mark[r]; return max(maxl, maxr); }; Leetcode. 307 範例 https://leetcode.com/problems/range-sum-query-mutable/ TreeNode 變形 class NumArray { class SegTree { public: int val; int begin, end; SegTree* left, *right; SegTree(int v):val(v) {} SegTree(int v, int b, int e):val(v), begin(b), end(e) {} SegTree(int v, int b, int e, SegTree* l, SegTree* r) :val(v), begin(b), end(e), left(l), right(r) {} }; SegTree* root; SegTree* build(vector\u003cint\u003e\u0026 nums, int b, int e){ if (e \u003c b) return NULL; if (b == e) return new SegTree(nums[b], b, b); int mid = b + (e-b)/2; SegTree* left = build(nums, b, mid); SegTree* right = build(nums, mid+1, e); return new SegTree(left-\u003eval + right-\u003eval, b, e, left, right); } void update(SegTree* node, int index, int val){ if (node-\u003ebegin == index \u0026\u0026 node-\u003eend == index){ node-\u003eval = val; } else { int mid = node-\u003ebegin + (node-\u003eend - node-\u003ebegin)/2; if (index \u003c= mid){ update(node-\u003eleft, index, val); } else { update(node-\u003eright, index, val); } node-\u003eval = node-\u003eleft-\u003eval + node-\u003eright-\u003eval; } } int query(SegTree* node, int left, int right){ if (node-\u003ebegin == left \u0026\u0026 node-\u003eend == right){ return node-\u003eval; } int mid = node-\u003ebegin + (node-\u003eend - node-\u003ebegin)/2; if (right \u003c= mid){ return query(node-\u003eleft, left, right); } else if (left \u003e mid){ return query(node-\u003eright, left, right); } return query(node-\u003eleft, left, mid) + query(node-\u003eright, mid+1, right); } public: NumArray(vector\u003cint\u003e\u0026 nums) { root = build(nums, 0, nums.size()-1); } void update(int index, int val) { update(root, index, val); } int sumRange(int left, int right) { return query(root, left, right); } }; zkw 線段樹 class NumArray { class SegTree { vector\u003cint\u003e arr; int m, n; public: SegTree(vector\u003cint\u003e\u0026 nums) { n = nums.size(); for (m = 1; m \u003c n; m \u003c\u003c= 1); build(nums); } void build(vector\u003cint\u003e\u0026 nums) { arr.assign(2*m, 0); for (int i = 0; i \u003c n; ++i) arr[m+i] = nums[i]; for (int i = m-1; i; --i) arr[i] = arr[i\u003c\u003c1] + arr[i\u003c\u003c1|1]; } void update(int index, int val) { int diff = val - arr[m+index]; for (index += m; index; index \u003e\u003e= 1) arr[index] += diff; } int query(int left, int right) { int sum = 0; for (int i = left+m, j = right+m; i \u003c= j; i \u003e\u003e= 1, j \u003e\u003e= 1){ if (i \u0026 1) sum += arr[i++]; if (!(j \u0026 1)) sum += arr[j--]; } return sum; } }; public: SegTree* root; NumArray(vector\u003cint\u003e\u0026 nums) { root = new SegTree(nums); } void update(int index, int val) { root-\u003eupdate(index, val); } int sumRange(int left, int right) { return root-\u003equery(left, right); } }; BIT(binary indexed tree) class NumArray { public: class Bit { public: vector\u003cint\u003e bit; int n; Bit(vector\u003cint\u003e\u0026 nums) { n = nums.size(); bit.assign(n+1, 0); for (int i = 0; i \u003c n; i++){ build(i+1, nums[i]); } } void build(int index, int val) { while (index \u003c= n){ bit[index] += val; index = next(index); } } int next(int index) { return index + (index \u0026 -index); } int parent(int index) { return index - (index \u0026 -index); } int getSum(int index) { int sum = 0; while (index){ sum += bit[index]; index = parent(index); } return sum; } }; Bit* bit; NumArray(vector\u003cint\u003e\u0026 nums) { bit = new Bit(nums); } void update(int index, int val) { int diff = val - sumRange(index, index); bit-\u003ebuild(index+1, diff); } int sumRange(int left, int right) { return bit-\u003egetSum(right+1) - bit-\u003egetSum(left); } }; ","wordCount":"1497","inLanguage":"zh-tw","image":"https://intervalrain.github.io/images/cover.jpg","datePublished":"2022-10-18T23:14:38+08:00","dateModified":"2022-10-18T23:14:38+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/c++/segtree/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/c++/>C++s</a></div><h1 class="post-title entry-hint-parent">[C++] Segment Tree</h1><div class=post-description>用 C++ 介紹資料結構線段樹</div><div class=post-meta><span title='2022-10-18 23:14:38 +0800 +0800'>October 18, 2022</span>&nbsp;·&nbsp;8 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//C++/segTree.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e7%b7%9a%e6%ae%b5%e6%a8%b9-segment-tree aria-label="線段樹 Segment Tree">線段樹 Segment Tree</a><ul><li><a href=#%e7%b0%a1%e4%bb%8b aria-label=簡介>簡介</a></li><li><a href=#%e5%bb%ba%e6%a8%b9-build aria-label="建樹 build">建樹 build</a></li><li><a href=#%e6%9f%a5%e8%a9%a2-query aria-label="查詢 query">查詢 query</a></li></ul></li><li><a href=#zkw-%e7%b7%9a%e6%ae%b5%e6%a8%b9 aria-label="zkw 線段樹">zkw 線段樹</a><ul><li><a href=#%e7%b5%90%e6%a7%8b aria-label=結構>結構</a></li><li><a href=#%e5%bb%ba%e6%a8%b9-build-1 aria-label="建樹 build">建樹 build</a></li><li><a href=#%e6%9b%b4%e6%96%b0-update aria-label="更新 update">更新 update</a></li><li><a href=#%e6%9f%a5%e8%a9%a2-query-1 aria-label="查詢 query">查詢 query</a></li><li><a href=#%e5%8d%80%e9%96%93%e4%bf%ae%e6%94%b9 aria-label=區間修改>區間修改</a></li></ul></li><li><a href=#leetcode-307-%e7%af%84%e4%be%8b aria-label="Leetcode. 307 範例">Leetcode. 307 範例</a></li><li><a href=#bitbinary-indexed-tree aria-label="BIT(binary indexed tree)">BIT(binary indexed tree)</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=線段樹-segment-tree>線段樹 Segment Tree<a hidden class=anchor aria-hidden=true href=#線段樹-segment-tree>#</a></h1><h2 id=簡介>簡介<a hidden class=anchor aria-hidden=true href=#簡介>#</a></h2><ul><li>線段樹是演算法中常用來維護<strong>區間訊息</strong>的資料結構。</li><li>空間複雜度為 \(O(n)\)，\(n\) 代表區間數。</li><li>查詢的時間複雜度為 \(O(\log n+k)\)，\(k\) 代表符合條件的區間數量。</li><li>線段樹將每個長度為為 1 的區間劃分為左右兩個區間遞迴求解，把整個線段劃分為一個樹型結構，通過合併左右兩個區間訊息來求得該區間的訊息。</li><li>在實現時，我們考慮遞迴建樹，設當前的根節點為 root，如果根節點管轄的區間長度已經是 1，則可以直接根據數組上相應位置的值初始化該節點。否則需將該區間從中點處分割為兩個子區間，分別進入左右子節點遞迴建樹，最後合併兩個子節點的訊息，</li></ul><h2 id=建樹-build>建樹 build<a hidden class=anchor aria-hidden=true href=#建樹-build>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build</span>(<span style=color:#66d9ef>int</span> s, <span style=color:#66d9ef>int</span> t, <span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>const</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> arr){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>==</span> t){
</span></span><span style=display:flex><span>        tree[p] <span style=color:#f92672>=</span> SegmentItem(arr[s], <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> s <span style=color:#f92672>+</span> ((t <span style=color:#f92672>-</span> s) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    build(s, m, p<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>, arr);
</span></span><span style=display:flex><span>    build(m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, t, p<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, arr);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// push_up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    tree[p] <span style=color:#f92672>=</span> tree[p<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>+</span> tree[(p<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=查詢-query>查詢 query<a hidden class=anchor aria-hidden=true href=#查詢-query>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>SegmentItem <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> s, <span style=color:#66d9ef>int</span> t, <span style=color:#66d9ef>int</span> p){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;=</span> s <span style=color:#f92672>&amp;&amp;</span> t <span style=color:#f92672>&lt;=</span> r){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> tree[p];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> s <span style=color:#f92672>+</span> ((t <span style=color:#f92672>-</span> s) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    SegmentItem sum;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>&lt;=</span> m) <span style=color:#66d9ef>return</span> find(l, r, s, m, p<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&gt;</span> m) <span style=color:#66d9ef>return</span> find(l, r, m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, t, p<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> find(l, r, s, m, p<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span> find(l, r, m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, t, p<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=zkw-線段樹>zkw 線段樹<a hidden class=anchor aria-hidden=true href=#zkw-線段樹>#</a></h1><ul><li>來自清華大學張昆瑋(zkw)-《統計的力量》</li><li>以非遞迴的方式構建，效率更高，程式更短。</li><li>普通的線段樹是從上到下做處理，容易定位根節點，卻不容易定位子節點。</li><li>zkw 線段樹是當二叉樹是<strong>滿二叉樹</strong>時，因為子節點的編號具有以下規律：
<img alt="complete tree" loading=lazy src=https://pic2.zhimg.com/80/v2-0cf514ed4d2feb7db4acf069659c6921_1440w.webp><ul><li>葉子節點(left) 全部退化為線段 \([x,x]\) 。</li><li>\(n\) 個數據點則取大於等 \(n\)且為 \(2\) 的冪次的兩倍作為數組大小。 \((m=2^a\ge n)\)<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; m <span style=color:#f92672>&lt;=</span> n; m <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div></li><li>維護點為 \(n\) 個。索引為\([m,m+n)\)。</li><li>子葉數目為 \(m\) 個。索引為\([m,2m)\)</li><li>節點數為 \(2m-1\) 個。(數組大小需設 \(2m\) 因為 zkw tree是 1-index的)</li><li>樹高 \(H=\log_2(m)+1\) 層。<ul><li>第 \(h\) 層有 \(2^{h-1}\) 個節點，</li><li>該層線段長度為 \(2^{H-h}\)。</li></ul></li><li>若某節點為 \(p\)，父節點為 \(p/2\)，子節點為 \(2p\) 和 \(2p+1\)<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> parent <span style=color:#f92672>=</span> p <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> p <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> p <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div></li><li>若兩節點為 \(p\) 與 \(q\)，且兩節點互為兄弟節點，則 \(p\oplus q=1\)<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>if</span> (left <span style=color:#f92672>^</span> right)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// left 與 right 為兄弟節點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// left 與 right 不為兄弟節點
</span></span></span></code></pre></div></li><li>除根節點外，左節點皆為偶數，右節點皆為奇數<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// i 為根節點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// i 為奇數，為右節點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#75715e>// i 為偶數，為左節點
</span></span></span></code></pre></div></li></ul></li></ul><h2 id=結構>結構<a hidden class=anchor aria-hidden=true href=#結構>#</a></h2><ul><li>線段樹索引堆疊：
<img alt=zkw1 loading=lazy src=/images/zkw1.jpg></li><li>轉成二進制：
<img alt=zkw2 loading=lazy src=/images/zkw2.jpg></li><li>規律：<ul><li>一個節點的父節點是該數右移 1，低位捨棄。</li><li>一個節點的左子節點是該數左移 1，右子節點是該數左移 1 再加 1。</li><li>同一層的節點是依次遞增的，第 \(n\) 層有 \(2^{n-1}\)個節點</li><li>最後一層有多少個節點，值域就是多少。</li></ul></li></ul><h2 id=建樹-build-1>建樹 build<a hidden class=anchor aria-hidden=true href=#建樹-build-1>#</a></h2><ul><li>取 m 值有許多版本，有些版本會直接取 \(m=2^{log_2(n+5)+1}\)以節省迭代計算<ul><li>寫成 <code>int n = 1 &lt;&lt; __lg(n+5)+1;</code></li></ul></li><li>可以有<strong>開區間</strong>與<strong>閉區間</strong>兩種做法，差別在於從子葉節點的最左邊 \(m+i\) 開始，或是第二個子葉節點 \(m+1+i\) 開始。</li><li>由下而上更新時，開區間與閉區間的終止條件不同：<ul><li>開區間的終止條件為兩子節點互為兄弟節點<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>while</span> (i<span style=color:#f92672>^</span>j<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// operation
</span></span></span></code></pre></div></li><li>閉區間的終止條件為右節點小於左節點<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;=</span> j)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// operation
</span></span></span></code></pre></div></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tree</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> arr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n, m;   <span style=color:#75715e>// n 為維護點數, m 為 zkw-tree 子葉節點數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span> 
</span></span><span style=display:flex><span>    Tree (vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums){
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> nums.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (m <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; m <span style=color:#f92672>&lt;=</span> n; m <span style=color:#f92672>&lt;&lt;=</span> <span style=color:#ae81ff>1</span>);   <span style=color:#75715e>// 取大於等於 n 且為 2 的冪次的最小整數
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        arr.assign(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>m, <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>// 節點數設為 2m 個，其中 0 為空節點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> nums){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            arr[i<span style=color:#f92672>+</span>m] <span style=color:#f92672>=</span> nums[i];  <span style=color:#75715e>// 從子葉節點最左邊往右更新節點。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            mx[i<span style=color:#f92672>+</span>m] <span style=color:#f92672>=</span> nums[i];
</span></span><span style=display:flex><span>            mn[i<span style=color:#f92672>+</span>m] <span style=color:#f92672>=</span> nums[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i; i<span style=color:#f92672>--</span>){  <span style=color:#75715e>// 向上更新父節點。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            arr[i] <span style=color:#f92672>=</span> in(x);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>根據不同需求代換 \(\text{in(x)}\)：取和、最大值、最小平</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>    <span style=color:#75715e>// 取和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    arr[i] <span style=color:#f92672>=</span> arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 取最大值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    arr[i] <span style=color:#f92672>=</span> max(arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>], arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 取最小值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    arr[i] <span style=color:#f92672>=</span> min(arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>], arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span>]);
</span></span></code></pre></div><h2 id=更新-update>更新 update<a hidden class=anchor aria-hidden=true href=#更新-update>#</a></h2><ul><li>單點修改(以和為例)</li><li>更新時，以差分方式，將所有父節點加上更新點的差值。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> diff <span style=color:#f92672>=</span> val <span style=color:#f92672>-</span> arr[m<span style=color:#f92672>+</span>i]   <span style=color:#75715e>// 原值 arr[m+i] 與新值 val 的差
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>+=</span> m; i; i <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        arr[i] <span style=color:#f92672>+=</span> diff;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=查詢-query-1>查詢 query<a hidden class=anchor aria-hidden=true href=#查詢-query-1>#</a></h2><ul><li>單點查詢(以和為例)：閉區間做法</li><li>判斷左邊界是否為右節點，若為右節點則加上後往右邊的父節點移動。</li><li>判斷右邊界是否為左節點，若為左節點則加上後往左邊的父節點移動。
<img alt=query loading=lazy src=https://pic2.zhimg.com/80/v2-e3823c417f81dedca9de97ce81fb25f5_1440w.webp></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left<span style=color:#f92672>+</span>m;     <span style=color:#75715e>// 左閉區間
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> right<span style=color:#f92672>+</span>m;    <span style=color:#75715e>// 右閉區間
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (; i <span style=color:#f92672>&lt;=</span> j; i <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) sum <span style=color:#f92672>+=</span> arr[i<span style=color:#f92672>++</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(j <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>)) sum <span style=color:#f92672>+=</span> arr[j<span style=color:#f92672>--</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>備註：開區間作法 (0-index 時會出現 -1 的情形，建議使用閉區間)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left<span style=color:#f92672>+</span>m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> right<span style=color:#f92672>+</span>m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(; i<span style=color:#f92672>^</span>j<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>~</span>i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) sum <span style=color:#f92672>+=</span> arr[i<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) sum <span style=color:#f92672>+=</span> arr[j<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=區間修改>區間修改<a hidden class=anchor aria-hidden=true href=#區間修改>#</a></h2><ul><li>在非遞迴的情況下，標記下傳是比較困難的，所以作法上改成將標記永久化。</li><li>具體而言，與查詢類似，當左端點是左子節點且右端點是右子節點時，我們對它的兄弟節點進行修改並標記，表示這顆子樹中的每個節點都要被修改。但單純這樣還不夠，因上述修改還會波及到這些節點的各級祖先，所以我們需要在途中根據實際修改的區間長度來更新各級祖先的值，這種操作需要一路上推到根節點。
<img alt=range_revise loading=lazy src=https://pic3.zhimg.com/80/v2-107685cb9a76db558ed75ce3979dacde_1440w.webp>
(開區間作法)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right, <span style=color:#66d9ef>int</span> diff){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, cntl <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, cntr <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// cntl, cntr 是左右邊分別實際修改的區間長度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    left <span style=color:#f92672>+=</span> m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    right <span style=color:#f92672>+=</span> m<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; left<span style=color:#f92672>^</span>right<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>; left <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>, right <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>, len <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        arr[left] <span style=color:#f92672>+=</span> cntl <span style=color:#f92672>*</span> diff;
</span></span><span style=display:flex><span>        arr[right] <span style=color:#f92672>+=</span> cntr <span style=color:#f92672>*</span> diff;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>~</span>left <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            arr[left<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> diff <span style=color:#f92672>*</span> len;
</span></span><span style=display:flex><span>            mark[left<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> diff;
</span></span><span style=display:flex><span>            cntl <span style=color:#f92672>+=</span> len;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (right <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            arr[right<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> diff <span style=color:#f92672>*</span> len;
</span></span><span style=display:flex><span>            mark[right<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> diff;
</span></span><span style=display:flex><span>            cntr <span style=color:#f92672>+=</span> len;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; left; left <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, right <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        arr[left] <span style=color:#f92672>+=</span> cntl <span style=color:#f92672>*</span> diff;
</span></span><span style=display:flex><span>        arr[right] <span style=color:#f92672>+=</span> cntr <span style=color:#f92672>*</span> diff;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>在有區間修改存在時，區間查詢也需要考慮標記的影響。</li><li>所以除了加上端點的兄弟節點訊息，沿途中遇到的標記也對答案有貢獻，同樣需要上推到根節點。
<img alt=range_query loading=lazy src=https://pic4.zhimg.com/80/v2-c02f4a74602fbf8b1d8c90012550af77_1440w.webp></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, len <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, cntl <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, cntr <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    left <span style=color:#f92672>+=</span> m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    right <span style=color:#f92672>+=</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; left<span style=color:#f92672>^</span>right<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>; left <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, right <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, len <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> cntl <span style=color:#f92672>*</span> mark[left] <span style=color:#f92672>+</span> cntr <span style=color:#f92672>*</span> mark[right];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>~</span>left <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) sum <span style=color:#f92672>+=</span> arr[left<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>], cntl <span style=color:#f92672>+=</span> len;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (right <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) sum <span style=color:#f92672>+=</span> arr[right<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>], cntr <span style=color:#f92672>+=</span> len;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; left; left <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>, right <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> cntl <span style=color:#f92672>*</span> mark[left] <span style=color:#f92672>+</span> cntr <span style=color:#f92672>*</span> mark[right];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>區間查詢最大值：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (l <span style=color:#f92672>+=</span> N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>+=</span> N <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; l <span style=color:#f92672>^</span> r <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>; l <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;</span> N) tree[l] <span style=color:#f92672>=</span> max(tree[l <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>], tree[l <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>+</span> mark[l],
</span></span><span style=display:flex><span>                    tree[r] <span style=color:#f92672>=</span> max(tree[r <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>], tree[r <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>+</span> mark[r];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>~</span>l <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) tree[l <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> d, mark[l <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> d;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) tree[r <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> d, mark[r <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> d;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; l; l <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;</span> N) tree[l] <span style=color:#f92672>=</span> max(tree[l <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>], tree[l <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>+</span> mark[l],
</span></span><span style=display:flex><span>                    tree[r] <span style=color:#f92672>=</span> max(tree[r <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>], tree[r <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>+</span> mark[r];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> maxl <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>INF, maxr <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>INF;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (l <span style=color:#f92672>+=</span> N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>+=</span> N <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; l <span style=color:#f92672>^</span> r <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>; l <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        maxl <span style=color:#f92672>+=</span> mark[l], maxr <span style=color:#f92672>+=</span> mark[r];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>~</span>l <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) cmax(maxl, tree[l <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) cmax(maxr, tree[r <span style=color:#f92672>^</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (; l; l <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        maxl <span style=color:#f92672>+=</span> mark[l], maxr <span style=color:#f92672>+=</span> mark[r];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> max(maxl, maxr);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h1 id=leetcode-307-範例>Leetcode. 307 範例<a hidden class=anchor aria-hidden=true href=#leetcode-307-範例>#</a></h1><ul><li><a href=https://leetcode.com/problems/range-sum-query-mutable/>https://leetcode.com/problems/range-sum-query-mutable/</a></li></ul><ol><li>TreeNode 變形</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NumArray</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SegTree</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> val;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> begin, end;
</span></span><span style=display:flex><span>        SegTree<span style=color:#f92672>*</span> left, <span style=color:#f92672>*</span>right;
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> v)<span style=color:#f92672>:</span>val(v) {}
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> v, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> e)<span style=color:#f92672>:</span>val(v), begin(b), end(e) {}
</span></span><span style=display:flex><span>        SegTree(<span style=color:#66d9ef>int</span> v, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> e, SegTree<span style=color:#f92672>*</span> l, SegTree<span style=color:#f92672>*</span> r)
</span></span><span style=display:flex><span>            <span style=color:#f92672>:</span>val(v), begin(b), end(e), left(l), right(r) {}
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    SegTree<span style=color:#f92672>*</span> root;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    SegTree<span style=color:#f92672>*</span> <span style=color:#a6e22e>build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> e){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (e <span style=color:#f92672>&lt;</span> b) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>==</span> e) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> SegTree(nums[b], b, b);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> b <span style=color:#f92672>+</span> (e<span style=color:#f92672>-</span>b)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        SegTree<span style=color:#f92672>*</span> left <span style=color:#f92672>=</span> build(nums, b, mid);
</span></span><span style=display:flex><span>        SegTree<span style=color:#f92672>*</span> right <span style=color:#f92672>=</span> build(nums, mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> SegTree(left<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> right<span style=color:#f92672>-&gt;</span>val, b, e, left, right);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(SegTree<span style=color:#f92672>*</span> node, <span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>begin <span style=color:#f92672>==</span> index <span style=color:#f92672>&amp;&amp;</span> node<span style=color:#f92672>-&gt;</span>end <span style=color:#f92672>==</span> index){
</span></span><span style=display:flex><span>            node<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> val;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>begin <span style=color:#f92672>+</span> (node<span style=color:#f92672>-&gt;</span>end <span style=color:#f92672>-</span> node<span style=color:#f92672>-&gt;</span>begin)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&lt;=</span> mid){
</span></span><span style=display:flex><span>                update(node<span style=color:#f92672>-&gt;</span>left, index, val);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                update(node<span style=color:#f92672>-&gt;</span>right, index, val);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            node<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>left<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> node<span style=color:#f92672>-&gt;</span>right<span style=color:#f92672>-&gt;</span>val;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(SegTree<span style=color:#f92672>*</span> node, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>begin <span style=color:#f92672>==</span> left <span style=color:#f92672>&amp;&amp;</span> node<span style=color:#f92672>-&gt;</span>end <span style=color:#f92672>==</span> right){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>val;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>begin <span style=color:#f92672>+</span> (node<span style=color:#f92672>-&gt;</span>end <span style=color:#f92672>-</span> node<span style=color:#f92672>-&gt;</span>begin)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (right <span style=color:#f92672>&lt;=</span> mid){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> query(node<span style=color:#f92672>-&gt;</span>left, left, right);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>&gt;</span> mid){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> query(node<span style=color:#f92672>-&gt;</span>right, left, right);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> query(node<span style=color:#f92672>-&gt;</span>left, left, mid) <span style=color:#f92672>+</span> query(node<span style=color:#f92672>-&gt;</span>right, mid<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, right);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    NumArray(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>        root <span style=color:#f92672>=</span> build(nums, <span style=color:#ae81ff>0</span>, nums.size()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>        update(root, index, val);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sumRange</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> query(root, left, right);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ol start=2><li>zkw 線段樹</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NumArray</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SegTree</span> {
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> arr;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> m, n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        SegTree(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> nums.size();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (m <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; m <span style=color:#f92672>&lt;</span> n; m <span style=color:#f92672>&lt;&lt;=</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            build(nums);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>            arr.assign(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>m, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) arr[m<span style=color:#f92672>+</span>i] <span style=color:#f92672>=</span> nums[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; i; <span style=color:#f92672>--</span>i) arr[i] <span style=color:#f92672>=</span> arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> arr[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> diff <span style=color:#f92672>=</span> val <span style=color:#f92672>-</span> arr[m<span style=color:#f92672>+</span>index];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (index <span style=color:#f92672>+=</span> m; index; index <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>) arr[index] <span style=color:#f92672>+=</span> diff;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left<span style=color:#f92672>+</span>m, j <span style=color:#f92672>=</span> right<span style=color:#f92672>+</span>m; i <span style=color:#f92672>&lt;=</span> j; i <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) sum <span style=color:#f92672>+=</span> arr[i<span style=color:#f92672>++</span>];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(j <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>)) sum <span style=color:#f92672>+=</span> arr[j<span style=color:#f92672>--</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    SegTree<span style=color:#f92672>*</span> root;
</span></span><span style=display:flex><span>    NumArray(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>        root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SegTree(nums);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>        root<span style=color:#f92672>-&gt;</span>update(index, val);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sumRange</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root<span style=color:#f92672>-&gt;</span>query(left, right);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h1 id=bitbinary-indexed-tree>BIT(binary indexed tree)<a hidden class=anchor aria-hidden=true href=#bitbinary-indexed-tree>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NumArray</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bit</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> bit;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>        Bit(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> nums.size();
</span></span><span style=display:flex><span>            bit.assign(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                build(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, nums[i]);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build</span>(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (index <span style=color:#f92672>&lt;=</span> n){
</span></span><span style=display:flex><span>                bit[index] <span style=color:#f92672>+=</span> val;
</span></span><span style=display:flex><span>                index <span style=color:#f92672>=</span> next(index);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>next</span>(<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> index <span style=color:#f92672>+</span> (index <span style=color:#f92672>&amp;</span> <span style=color:#f92672>-</span>index);
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>parent</span>(<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> index <span style=color:#f92672>-</span> (index <span style=color:#f92672>&amp;</span> <span style=color:#f92672>-</span>index);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getSum</span>(<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (index){
</span></span><span style=display:flex><span>                sum <span style=color:#f92672>+=</span> bit[index];
</span></span><span style=display:flex><span>                index <span style=color:#f92672>=</span> parent(index);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> sum;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    Bit<span style=color:#f92672>*</span> bit;
</span></span><span style=display:flex><span>    NumArray(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums) {
</span></span><span style=display:flex><span>        bit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Bit(nums);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>int</span> val) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> diff <span style=color:#f92672>=</span> val <span style=color:#f92672>-</span> sumRange(index, index);
</span></span><span style=display:flex><span>        bit<span style=color:#f92672>-&gt;</span>build(index<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, diff);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sumRange</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bit<span style=color:#f92672>-&gt;</span>getSum(right<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>-</span> bit<span style=color:#f92672>-&gt;</span>getSum(left);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/c++/>C++</a></li><li><a href=https://intervalrain.github.io/tags/programming/>Programming</a></li></ul></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>