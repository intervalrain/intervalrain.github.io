<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 212. Word Search II | Rain Hu's Workspace</title><meta name=keywords content="Leetcode"><meta name=description content="212. Word Search II

Hardness: \(\color{red}\textsf{Hard}\)
Ralated Topics: Array、String、Backtracking、Trie、Matrix


一、題目
Given an m x n board of characters and a list of strings words, return all words on the board.
Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example 1:

Input: board = [[&ldquo;o&rdquo;,&ldquo;a&rdquo;,&ldquo;a&rdquo;,&ldquo;n&rdquo;],[&ldquo;e&rdquo;,&ldquo;t&rdquo;,&ldquo;a&rdquo;,&ldquo;e&rdquo;],[&ldquo;i&rdquo;,&ldquo;h&rdquo;,&ldquo;k&rdquo;,&ldquo;r&rdquo;],[&ldquo;i&rdquo;,&ldquo;f&rdquo;,&ldquo;l&rdquo;,&ldquo;v&rdquo;]], words = [&ldquo;oath&rdquo;,&ldquo;pea&rdquo;,&ldquo;eat&rdquo;,&ldquo;rain&rdquo;]
Output: [&ldquo;eat&rdquo;,&ldquo;oath&rdquo;]

Example 2:"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/leetcode/212/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/leetcode/212/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[LeetCode] 212. Word Search II"><meta property="og:description" content="212. Word Search II
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、String、Backtracking、Trie、Matrix 一、題目 Given an m x n board of characters and a list of strings words, return all words on the board.
Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example 1:
Input: board = [[“o”,“a”,“a”,“n”],[“e”,“t”,“a”,“e”],[“i”,“h”,“k”,“r”],[“i”,“f”,“l”,“v”]], words = [“oath”,“pea”,“eat”,“rain”] Output: [“eat”,“oath”] Example 2:"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="leetcode"><meta property="article:published_time" content="2022-11-05T20:58:11+08:00"><meta property="article:modified_time" content="2022-11-05T20:58:11+08:00"><meta property="article:tag" content="Leetcode"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 212. Word Search II"><meta name=twitter:description content="212. Word Search II

Hardness: \(\color{red}\textsf{Hard}\)
Ralated Topics: Array、String、Backtracking、Trie、Matrix


一、題目
Given an m x n board of characters and a list of strings words, return all words on the board.
Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example 1:

Input: board = [[&ldquo;o&rdquo;,&ldquo;a&rdquo;,&ldquo;a&rdquo;,&ldquo;n&rdquo;],[&ldquo;e&rdquo;,&ldquo;t&rdquo;,&ldquo;a&rdquo;,&ldquo;e&rdquo;],[&ldquo;i&rdquo;,&ldquo;h&rdquo;,&ldquo;k&rdquo;,&ldquo;r&rdquo;],[&ldquo;i&rdquo;,&ldquo;f&rdquo;,&ldquo;l&rdquo;,&ldquo;v&rdquo;]], words = [&ldquo;oath&rdquo;,&ldquo;pea&rdquo;,&ldquo;eat&rdquo;,&ldquo;rain&rdquo;]
Output: [&ldquo;eat&rdquo;,&ldquo;oath&rdquo;]

Example 2:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[LeetCode] 212. Word Search II","item":"https://intervalrain.github.io/leetcode/212/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 212. Word Search II","name":"[LeetCode] 212. Word Search II","description":"212. Word Search II\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、String、Backtracking、Trie、Matrix 一、題目 Given an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nExample 1:\nInput: board = [[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;],[\u0026ldquo;e\u0026rdquo;,\u0026ldquo;t\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;e\u0026rdquo;],[\u0026ldquo;i\u0026rdquo;,\u0026ldquo;h\u0026rdquo;,\u0026ldquo;k\u0026rdquo;,\u0026ldquo;r\u0026rdquo;],[\u0026ldquo;i\u0026rdquo;,\u0026ldquo;f\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;v\u0026rdquo;]], words = [\u0026ldquo;oath\u0026rdquo;,\u0026ldquo;pea\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;rain\u0026rdquo;] Output: [\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;oath\u0026rdquo;] Example 2:\n","keywords":["Leetcode"],"articleBody":"212. Word Search II\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、String、Backtracking、Trie、Matrix 一、題目 Given an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nExample 1:\nInput: board = [[“o”,“a”,“a”,“n”],[“e”,“t”,“a”,“e”],[“i”,“h”,“k”,“r”],[“i”,“f”,“l”,“v”]], words = [“oath”,“pea”,“eat”,“rain”] Output: [“eat”,“oath”] Example 2:\nInput: board = [[“a”,“b”],[“c”,“d”]], words = [“abcb”] Output: [] Example 3:\nInput: Output: Constraints:\nm == board.length n == board[i].length 1 \u003c= m, n \u003c= 12 board[i][j] is a lowercase English letter. 1 \u003c= words.length \u003c= 3 * 104 1 \u003c= words[i].length \u003c= 10 words[i] consists of lowercase English letters. All the strings of words are unique. 二、分析 這題是 [LeetCode] 79. Word Search 的進階題，是 google 愛考的題型，先考你一題基礎題型，再看你能不能進一步微調。如先考最短路徑的「步數」，再考你最短路徑的「路徑」，此種題型容易藏細節，如最短路徑「步數」可以用 bfs，當走到終點立即回傳，但當考題改成路徑時，就不能立即回傳，因為有可能會有多個最短路徑。 這題有許多剪枝技巧： word 的字長不可能大於 board 的總字數，即 m x n。 word 個別的字數需小於 board 各別的字數。 word 如果是重複的字元組成，則重複的字元擺在尾巴可以有分枝的效果。 即 aaaaaaabc 可以處理成，找 cbaaaaaaa。 注意在 search 中回傳 bool 值前，要記得將 backtrack 走完，以免影響其它組解。 三、解題 1. Backtracking Time complexity: \\(O(m\\times n\\times l)\\)，\\(m \\) 為 board.size()，\\(n\\) 為 board[0].size()，\\(l\\) 為 word.length() Space complexity: \\(O(m\\times n)\\) class Board { private: vector\u003cvector\u003cchar\u003e\u003e board; int m, n; int cnt[26]; // 用於上、下、左、右 int dirc[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; // 用於剪枝1與剪枝2，在進行算法前，檢查其是否可能為錯，時間複雜度為 O(1)，所以可以大大降低耗時。 bool isWordNumValid(string\u0026 word) { if (word.length() \u003e m * n) return false; // 剪枝1 int charNum[26] = {0}; for (char c : word) charNum[c-'a']++; for (int i = 0; i \u003c 26; i++) { if (charNum[i] \u003e cnt[i]) return false; // 剪枝2 } return true; } void reverseIfNeeded(string\u0026 word) { int left = word.find_first_not_of(word[0]); // 左邊重複 int right = word.length() - word.find_last_not_of(word[word.length()-1]); // 右邊重複 if (left \u003e right) reverse(word.begin(), word.end()); // 左邊重複較長，則翻轉字串 } bool backtrack(string\u0026 word, int row, int col, int i) { if (i == word.length()) return true; // 到達終止條件，回傳 true if (row \u003c 0 || col \u003c 0 || row \u003e= m || col \u003e= n || board[row][col] != word[i]) return false; // out of bound 或不符合 char tmp = board[row][col]; // 記錄原本的格子 board[row][col] = '#'; // 用 '#' 代表 visited，省去另外創一個 visited 來記錄是否拜訪過 for (const auto\u0026 d : dirc) if (backtrack(word, row+d[0], col+d[1], i+1)) { board[row][col] = tmp; // 記得將 backtrack 更動的部分走完，以免影響其它組解 return true; } board[row][col] = tmp; // 還原格子 return false; } public: Board(vector\u003cvector\u003cchar\u003e\u003e\u0026 board_) { this-\u003eboard = board_; this-\u003em = board_.size(); this-\u003en = board_[0].size(); memset(cnt, 0, sizeof(cnt)); for (const auto\u0026 row : board) { for (char c : row) { cnt[c-'a']++; } } } bool search(string word) { for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (!isWordNumValid(word)) return false; reverseIfNeeded(word); if (backtrack(word, i, j, 0)) return true; } } return false; } }; class Solution { public: vector\u003cstring\u003e findWords(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, vector\u003cstring\u003e\u0026 words) { Board b(board); vector\u003cstring\u003e res; for (const auto\u0026 word : words) { if (b.search(word)) res.push_back(word); } return res; } }; 回目錄 Catalog\n","wordCount":"478","inLanguage":"zh-tw","datePublished":"2022-11-05T20:58:11+08:00","dateModified":"2022-11-05T20:58:11+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/leetcode/212/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a></div><h1 class="post-title entry-hint-parent">[LeetCode] 212. Word Search II</h1><div class=post-meta><span title='2022-11-05 20:58:11 +0800 +0800'>November 5, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//leetcode/212.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-backtracking aria-label="1. Backtracking">1. Backtracking</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>212. Word Search II</strong></p><ul><li>Hardness: \(\color{red}\textsf{Hard}\)</li><li>Ralated Topics: <code>Array</code>、<code>String</code>、<code>Backtracking</code>、<code>Trie</code>、<code>Matrix</code></li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>Given an <code>m x n</code> <code>board</code> of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.<br>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p><strong>Example 1:</strong></p><ul><li><strong>Input:</strong> board = [[&ldquo;o&rdquo;,&ldquo;a&rdquo;,&ldquo;a&rdquo;,&ldquo;n&rdquo;],[&ldquo;e&rdquo;,&ldquo;t&rdquo;,&ldquo;a&rdquo;,&ldquo;e&rdquo;],[&ldquo;i&rdquo;,&ldquo;h&rdquo;,&ldquo;k&rdquo;,&ldquo;r&rdquo;],[&ldquo;i&rdquo;,&ldquo;f&rdquo;,&ldquo;l&rdquo;,&ldquo;v&rdquo;]], words = [&ldquo;oath&rdquo;,&ldquo;pea&rdquo;,&ldquo;eat&rdquo;,&ldquo;rain&rdquo;]</li><li><strong>Output:</strong> [&ldquo;eat&rdquo;,&ldquo;oath&rdquo;]</li></ul><p><strong>Example 2:</strong></p><ul><li><strong>Input:</strong> board = [[&ldquo;a&rdquo;,&ldquo;b&rdquo;],[&ldquo;c&rdquo;,&ldquo;d&rdquo;]], words = [&ldquo;abcb&rdquo;]</li><li><strong>Output:</strong> []</li></ul><p><strong>Example 3:</strong></p><ul><li><strong>Input:</strong></li><li><strong>Output:</strong></li></ul><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 12</code></li><li><code>board[i][j]</code> is a lowercase English letter.</li><li><code>1 &lt;= words.length &lt;= 3 * 104</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> consists of lowercase English letters.</li><li>All the strings of <code>words</code> are unique.</li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>這題是 <a href=/leetcode/79>[LeetCode] 79. Word Search</a> 的進階題，是 google 愛考的題型，先考你一題基礎題型，再看你能不能進一步微調。如先考最短路徑的「步數」，再考你最短路徑的「路徑」，此種題型容易藏細節，如最短路徑「步數」可以用 <code>bfs</code>，當走到終點立即回傳，但當考題改成路徑時，就不能立即回傳，因為有可能會有多個最短路徑。</li><li>這題有許多剪枝技巧：<ol><li><code>word</code> 的字長不可能大於 <code>board</code> 的總字數，即 <code>m x n</code>。</li><li><code>word</code> 個別的字數需小於 <code>board</code> 各別的字數。</li><li><code>word</code> 如果是重複的字元組成，則重複的字元擺在尾巴可以有分枝的效果。<ul><li>即 <code>aaaaaaabc</code> 可以處理成，找 <code>cbaaaaaaa</code>。</li></ul></li></ol></li><li>注意在 <code>search</code> 中回傳 <code>bool</code> 值前，要記得將 <code>backtrack</code> 走完，以免影響其它組解。</li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-backtracking>1. Backtracking<a hidden class=anchor aria-hidden=true href=#1-backtracking>#</a></h4><ul><li>Time complexity: \(O(m\times n\times l)\)，\(m \) 為 <code>board.size()</code>，\(n\) 為 <code>board[0].size()</code>，\(l\) 為 <code>word.length()</code></li><li>Space complexity: \(O(m\times n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Board</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> board;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m, n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt[<span style=color:#ae81ff>26</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 用於上、下、左、右
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> dirc[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>},{<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>},{<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>},{<span style=color:#ae81ff>0</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 用於剪枝1與剪枝2，在進行算法前，檢查其是否可能為錯，時間複雜度為 O(1)，所以可以大大降低耗時。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isWordNumValid</span>(string<span style=color:#f92672>&amp;</span> word) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (word.length() <span style=color:#f92672>&gt;</span> m <span style=color:#f92672>*</span> n) <span style=color:#66d9ef>return</span> false;    <span style=color:#75715e>// 剪枝1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> charNum[<span style=color:#ae81ff>26</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> c : word) charNum[c<span style=color:#f92672>-</span><span style=color:#e6db74>&#39;a&#39;</span>]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>26</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (charNum[i] <span style=color:#f92672>&gt;</span> cnt[i]) <span style=color:#66d9ef>return</span> false;  <span style=color:#75715e>// 剪枝2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reverseIfNeeded</span>(string<span style=color:#f92672>&amp;</span> word) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> word.find_first_not_of(word[<span style=color:#ae81ff>0</span>]);     <span style=color:#75715e>// 左邊重複
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> word.length() <span style=color:#f92672>-</span> word.find_last_not_of(word[word.length()<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);       <span style=color:#75715e>// 右邊重複
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>&gt;</span> right) reverse(word.begin(), word.end());    <span style=color:#75715e>// 左邊重複較長，則翻轉字串
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>backtrack</span>(string<span style=color:#f92672>&amp;</span> word, <span style=color:#66d9ef>int</span> row, <span style=color:#66d9ef>int</span> col, <span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> word.length()) <span style=color:#66d9ef>return</span> true;        <span style=color:#75715e>// 到達終止條件，回傳 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> col <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> row <span style=color:#f92672>&gt;=</span> m <span style=color:#f92672>||</span> col <span style=color:#f92672>&gt;=</span> n <span style=color:#f92672>||</span> board[row][col] <span style=color:#f92672>!=</span> word[i]) <span style=color:#66d9ef>return</span> false;     <span style=color:#75715e>// out of bound 或不符合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>char</span> tmp <span style=color:#f92672>=</span> board[row][col];     <span style=color:#75715e>// 記錄原本的格子
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        board[row][col] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;#&#39;</span>;          <span style=color:#75715e>// 用 &#39;#&#39; 代表 visited，省去另外創一個 visited 來記錄是否拜訪過
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> d : dirc)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (backtrack(word, row<span style=color:#f92672>+</span>d[<span style=color:#ae81ff>0</span>], col<span style=color:#f92672>+</span>d[<span style=color:#ae81ff>1</span>], i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>                board[row][col] <span style=color:#f92672>=</span> tmp;      <span style=color:#75715e>// 記得將 backtrack 更動的部分走完，以免影響其它組解
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        board[row][col] <span style=color:#f92672>=</span> tmp;          <span style=color:#75715e>// 還原格子
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Board(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;&amp;</span> board_) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>board <span style=color:#f92672>=</span> board_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>m <span style=color:#f92672>=</span> board_.size();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>n <span style=color:#f92672>=</span> board_[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>        memset(cnt, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(cnt));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> row : board) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> c : row) {
</span></span><span style=display:flex><span>                cnt[c<span style=color:#f92672>-</span><span style=color:#e6db74>&#39;a&#39;</span>]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>search</span>(string word) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> n; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isWordNumValid(word)) <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>                reverseIfNeeded(word);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (backtrack(word, i, j, <span style=color:#ae81ff>0</span>)) <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> findWords(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;&amp;</span> board, vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&amp;</span> words) {
</span></span><span style=display:flex><span>        Board <span style=color:#a6e22e>b</span>(board);
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> word : words) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (b.search(word)) res.push_back(word);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><a href=/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/leetcode/2131/><span class=title>« 上一頁</span><br><span>[LeetCode] 2131. Longest Palindrome by Concatenating Two Letter Words</span>
</a><a class=next href=https://intervalrain.github.io/leetcode/79/><span class=title>下一頁 »</span><br><span>[LeetCode] 79. Word Search</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>