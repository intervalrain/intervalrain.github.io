<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level | Rain Hu's Workspace</title>
<meta name=keywords content="Leetcode"><meta name=description content="2471. Minimum Number of Operations to Sort a Binary Tree by Level
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://intervalrain.github.io/leetcode/2471/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level"><meta property="og:description" content="2471. Minimum Number of Operations to Sort a Binary Tree by Level
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order."><meta property="og:type" content="article"><meta property="og:url" content="https://intervalrain.github.io/leetcode/2471/"><meta property="article:section" content="leetcode"><meta property="article:published_time" content="2022-11-29T23:55:20+08:00"><meta property="article:modified_time" content="2022-11-29T23:55:20+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level"><meta name=twitter:description content="2471. Minimum Number of Operations to Sort a Binary Tree by Level
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level","item":"https://intervalrain.github.io/leetcode/2471/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level","name":"[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level","description":"2471. Minimum Number of Operations to Sort a Binary Tree by Level\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.","keywords":["Leetcode"],"articleBody":"2471. Minimum Number of Operations to Sort a Binary Tree by Level\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order. The level of a node is the number of edges along the path between it and the root node.\nExample 1:\nInput: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10] Output: 3 Explanation: Swap 4 and 3. The 2nd level becomes [3,4]. Swap 7 and 5. The 3rd level becomes [5,6,8,7]. Swap 8 and 7. The 3rd level becomes [5,6,7,8].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed. Example 2: Input: root = [1,3,2,7,6,5,4] Output: 3 Explanation: Swap 3 and 2. The 2nd level becomes [2,3]. Swap 7 and 4. The 3rd level becomes [4,6,5,7]. Swap 6 and 5. The 3rd level becomes [4,5,6,7].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed. Example 3: Input: root = [1,2,3,4,5,6] Output: 0 Explanation: Each level is already sorted in increasing order so return 0. Constraints:\nThe number of nodes in the tree is in the range [1, 10^5]. 1 \u003c= Node.val \u003c= 10^5 All the values of the tree are unique. 二、分析 這一題最直觀的想法就是先將所有節點用 vector 記錄下來之後，分層去做 minSwaps。 注意到 minSwaps 的實現：想法是，n 個節點 swap 形成一個 cycle，代表進行了 n-1 次 swap，故我們可以觀察得：minSwaps 的次數會等於 n - cycles。 三、解題 1. DFS Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) int minimumOperations(TreeNode* root) { vector\u003cvector\u003cint\u003e\u003e vec; dfs(root, vec, 0); int res = 0; for (auto v : vec) { res += minSwaps(v); } return res; } void dfs(TreeNode* root, vector\u003cvector\u003cint\u003e\u003e\u0026 vec, int depth) { if (!root) return; if (depth == vec.size()) { vec.push_back({}); } vec[depth].push_back(root-\u003eval); dfs(root-\u003eleft, vec, depth+1); dfs(root-\u003eright, vec, depth+1); } int minSwaps(vector\u003cint\u003e\u0026 arr){ int n = arr.size(); map\u003cint,int\u003e map; for (int i = 0; i \u003c n; i++) { map[arr[i]] = i; } vector\u003cbool\u003e vis(n, false); sort(arr.begin(), arr.end()); int ans = 0; for (int i = 0; i \u003c n; i++) { if (vis[i] || map[arr[i]] == i) continue; int j = i, cycle = 0; while (!vis[j]) { vis[j] = true; j = map[arr[j]]; cycle++; } if (cycle \u003e 0) { ans += (cycle-1); } } return ans; } 回目錄 Catalog\n","wordCount":"413","inLanguage":"en","datePublished":"2022-11-29T23:55:20+08:00","dateModified":"2022-11-29T23:55:20+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/leetcode/2471/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a></div><h1 class=post-title>[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level</h1><div class=post-meta>&lt;span title='2022-11-29 23:55:20 +0800 +0800'>November 29, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//leetcode/2471.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-dfs aria-label="1. DFS">1. DFS</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>2471. Minimum Number of Operations to Sort a Binary Tree by Level</strong></p><ul><li>Hardness: \(\color{orange}\textsf{Medium}\)</li><li>Ralated Topics: <code>Tree</code>、<code>Breadth-First Search</code>、<code>Binary Tree</code></li><li>\(\color{blue}\textsf{weekly Contest 319}\)</li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>You are given the <code>root</code> of a binary tree with <strong>unique values</strong>.
In one operation, you can choose any two nodes <strong>at the same level</strong> and swap their values.
Return <em>the minimum number of operations needed to make the values at each level sorted in a <em><strong>strictly increasing order</strong></em></em>.
The <strong>level</strong> of a node is the number of edges along the path between it and the root node.</p><p><strong>Example 1:</strong><br><img loading=lazy src=https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png alt=image1></p><ul><li><strong>Input:</strong> root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]</li><li><strong>Output:</strong> 3</li><li><strong>Explanation:</strong></li></ul><ul><li>Swap 4 and 3. The 2nd level becomes [3,4].</li><li>Swap 7 and 5. The 3rd level becomes [5,6,8,7].</li><li>Swap 8 and 7. The 3rd level becomes [5,6,7,8].<br>We used 3 operations so return 3.<br>It can be proven that 3 is the minimum number of operations needed.</li></ul><p><strong>Example 2:</strong>
<img loading=lazy src=https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png alt=image2></p><ul><li><strong>Input:</strong> root = [1,3,2,7,6,5,4]</li><li><strong>Output:</strong> 3</li><li><strong>Explanation:</strong></li></ul><ul><li>Swap 3 and 2. The 2nd level becomes [2,3].</li><li>Swap 7 and 4. The 3rd level becomes [4,6,5,7].</li><li>Swap 6 and 5. The 3rd level becomes [4,5,6,7].<br>We used 3 operations so return 3.<br>It can be proven that 3 is the minimum number of operations needed.</li></ul><p><strong>Example 3:</strong>
<img loading=lazy src=https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png alt=image3></p><ul><li><strong>Input:</strong> root = [1,2,3,4,5,6]</li><li><strong>Output:</strong> 0</li><li><strong>Explanation:</strong> Each level is already sorted in increasing order so return 0.</li></ul><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 10^5]</code>.</li><li><code>1 &lt;= Node.val &lt;= 10^5</code></li><li>All the values of the tree are <strong>unique</strong>.</li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>這一題最直觀的想法就是先將所有節點用 <code>vector</code> 記錄下來之後，分層去做 <code>minSwaps</code>。</li><li>注意到 <code>minSwaps</code> 的實現：想法是，<code>n</code> 個節點 <code>swap</code> 形成一個 <code>cycle</code>，代表進行了 <code>n-1</code> 次 <code>swap</code>，故我們可以觀察得：<code>minSwaps</code> 的次數會等於 <code>n - cycles</code>。</li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-dfs>1. DFS<a hidden class=anchor aria-hidden=true href=#1-dfs>#</a></h4><ul><li>Time complexity: \(O(n\log n)\)</li><li>Space complexity: \(O(n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>minimumOperations</span>(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> vec; 
</span></span><span style=display:flex><span>    dfs(root, vec, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> v : vec) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>+=</span> minSwaps(v);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(TreeNode<span style=color:#f92672>*</span> root, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> vec, <span style=color:#66d9ef>int</span> depth) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (depth <span style=color:#f92672>==</span> vec.size()) {
</span></span><span style=display:flex><span>        vec.push_back({});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vec[depth].push_back(root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>    dfs(root<span style=color:#f92672>-&gt;</span>left, vec, depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    dfs(root<span style=color:#f92672>-&gt;</span>right, vec, depth<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>minSwaps</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> arr){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> arr.size();
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> map;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        map[arr[i]] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> vis(n, false);
</span></span><span style=display:flex><span>    sort(arr.begin(), arr.end());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (vis[i] <span style=color:#f92672>||</span> map[arr[i]] <span style=color:#f92672>==</span> i) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i, cycle <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>vis[j]) {
</span></span><span style=display:flex><span>            vis[j] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            j <span style=color:#f92672>=</span> map[arr[j]];
</span></span><span style=display:flex><span>            cycle<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cycle <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            ans <span style=color:#f92672>+=</span> (cycle<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/leetcode/2472/><span class=title>« Prev Page</span><br><span>[LeetCode] 2472. Maximum Number of Non-overlapping Palindrome Substrings</span>
</a><a class=next href=https://intervalrain.github.io/leetcode/2470/><span class=title>Next Page »</span><br><span>[LeetCode] 2470. Number of Subarrays With LCM Equal to K</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>