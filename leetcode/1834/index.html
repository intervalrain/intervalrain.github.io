<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 1834. Single-Threaded CPU | Rain Hu's Workspace</title>
<meta name=keywords content="Leetcode"><meta name=description content="1834. Single-Threaded CPU

Hardness: \(\color{orange}\textsf{Medium}\)
Ralated Topics: Array、Sorting、Heap (Priority Queue>


一、題目
You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.
You have a single-threaded CPU that can process at most one task at a time and will act in the following way:"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/leetcode/1834/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/leetcode/1834/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[LeetCode] 1834. Single-Threaded CPU"><meta property="og:description" content="1834. Single-Threaded CPU
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Sorting、Heap (Priority Queue> 一、題目 You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.
You have a single-threaded CPU that can process at most one task at a time and will act in the following way:"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="leetcode"><meta property="article:published_time" content="2022-12-29T22:49:27+08:00"><meta property="article:modified_time" content="2022-12-29T22:49:27+08:00"><meta property="article:tag" content="Leetcode"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 1834. Single-Threaded CPU"><meta name=twitter:description content="1834. Single-Threaded CPU

Hardness: \(\color{orange}\textsf{Medium}\)
Ralated Topics: Array、Sorting、Heap (Priority Queue>


一、題目
You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.
You have a single-threaded CPU that can process at most one task at a time and will act in the following way:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[LeetCode] 1834. Single-Threaded CPU","item":"https://intervalrain.github.io/leetcode/1834/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 1834. Single-Threaded CPU","name":"[LeetCode] 1834. Single-Threaded CPU","description":"1834. Single-Threaded CPU\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Sorting、Heap (Priority Queue\u0026gt; 一、題目 You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.\nYou have a single-threaded CPU that can process at most one task at a time and will act in the following way:\n","keywords":["Leetcode"],"articleBody":"1834. Single-Threaded CPU\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Sorting、Heap (Priority Queue\u003e 一、題目 You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.\nYou have a single-threaded CPU that can process at most one task at a time and will act in the following way:\nIf the CPU is idle and there are no available tasks to process, the CPU remains idle. If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index. Once a task is started, the CPU will process the entire task without stopping. The CPU can finish a task then start a new one instantly. Return the order in which the CPU will process the tasks. Example 1:\nInput: tasks = [[1,2],[2,4],[3,2],[4,1]] Output: [0,2,3,1] Explanation: The events go as follows: At time = 1, task 0 is available to process. Available tasks = {0}. Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}. At time = 2, task 1 is available to process. Available tasks = {1}. At time = 3, task 2 is available to process. Available tasks = {1, 2}. Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}. At time = 4, task 3 is available to process. Available tasks = {1, 3}. At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}. At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}. At time = 10, the CPU finishes task 1 and becomes idle. Example 2:\nInput: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]] Output: [4,3,2,0,1] Explanation: The events go as follows: At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}. Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}. At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}. At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}. At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}. At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}. At time = 40, the CPU finishes task 1 and becomes idle. Constraints:\ntasks.length == n 1 \u003c= n \u003c= 10^5 1 \u003c= enqueueTimei, processingTimei \u003c= 10^9 二、分析 執行緒排程問題，直覺會將所有的 task 排序後，依據時間從 0 走到最後來處理這個問題，但是當秒數很大時，就會浪費很多時間，所以我們應該注意的時每個 trigger point，也就是新的 task 任務加入與結束的時候。 討論兩個情況， 當 Thread 是閒置時，直接跳到最前面的 task(即 trigger point 是任務加入時)。 當 Thread 不是閒置時，會將當下的 task 執行完後，所以得到結束的時間後，一次將符合 enqueueTime 的 task 加入佇列(即 trigger point 是任務結束時)。 由於這裡會優先處理 processingTime 較短的，所以在這裡可以用 min heap 來處理。 需注意，在排序前需先標記索引值。 需注意，timestamp 可能是大數。 三、解題 1. Heap (Priority Queue) Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) vector\u003cint\u003e getOrder(vector\u003cvector\u003cint\u003e\u003e\u0026 tasks) { auto comp = [](const auto\u0026 a, const auto\u0026 b){return a.first == b.first ? a.second \u003e b.second : a.first \u003e b.first;}; priority_queue\u003cpair\u003cint,int\u003e, vector\u003cpair\u003cint,int\u003e\u003e, decltype(comp)\u003e pq(comp); // min heap long long int timestamp = 0; int n = tasks.size(); vector\u003cint\u003e res; for (int i = 0; i \u003c tasks.size(); i++) { tasks[i].push_back(i); // 標記索引值 } sort(tasks.begin(), tasks.end()); // 排序 int i = 0; while (res.size() \u003c n) { if (pq.empty()) { // 閒置時，時間標籤移動到佇列最前面的任務 timestamp = tasks[i][0]; } else { // 非閒置時，將時間標籤移動到任務結束時 auto top = pq.top(); timestamp += top.first; res.push_back(top.second); pq.pop(); } while (i \u003c n \u0026\u0026 tasks[i][0] \u003c= timestamp) { // 加入所有比時間標籤早的任務 pq.push({tasks[i][1], tasks[i][2]}); // 以 {processingTime, index} 的方式加入 min heap i++; } } return res; } 回目錄 Catalog\n","wordCount":"648","inLanguage":"zh-tw","datePublished":"2022-12-29T22:49:27+08:00","dateModified":"2022-12-29T22:49:27+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/leetcode/1834/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a></div><h1 class="post-title entry-hint-parent">[LeetCode] 1834. Single-Threaded CPU</h1><div class=post-meta><span title='2022-12-29 22:49:27 +0800 +0800'>December 29, 2022</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//leetcode/1834.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-heap-priority-queue aria-label="1. Heap (Priority Queue)">1. Heap (Priority Queue)</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>1834. Single-Threaded CPU</strong></p><ul><li>Hardness: \(\color{orange}\textsf{Medium}\)</li><li>Ralated Topics: <code>Array</code>、<code>Sorting</code>、<code>Heap (Priority Queue></code></li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>You are given <code>n</code>​​​​ tasks labeled from <code>0</code> to <code>n - 1</code> represented by a 2D integer array <code>tasks</code>, where <code>tasks[i] = [enqueueTimei, processingTimei]</code> means that the <code>i​​​​​​th​​​​</code> task will be available to process at <code>enqueueTimei</code> and will take <code>processingTimei</code> to finish processing.<br>You have a single-threaded CPU that can process <strong>at most one</strong> task at a time and will act in the following way:</p><ul><li>If the CPU is idle and there are no available tasks to process, the CPU remains idle.</li><li>If the CPU is idle and there are available tasks, the CPU will choose the one with the <strong>shortest processing time</strong>. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.</li><li>Once a task is started, the CPU will <strong>process the entire task</strong> without stopping.</li><li>The CPU can finish a task then start a new one instantly.
Return <em>the order in which the CPU will process the tasks</em>.</li></ul><p><strong>Example 1:</strong></p><ul><li><strong>Input:</strong> tasks = [[1,2],[2,4],[3,2],[4,1]]</li><li><strong>Output:</strong> [0,2,3,1]</li><li><strong>Explanation:</strong> The events go as follows:</li></ul><ul><li>At time = 1, task 0 is available to process. Available tasks = {0}.</li><li>Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.</li><li>At time = 2, task 1 is available to process. Available tasks = {1}.</li><li>At time = 3, task 2 is available to process. Available tasks = {1, 2}.</li><li>Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.</li><li>At time = 4, task 3 is available to process. Available tasks = {1, 3}.</li><li>At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.</li><li>At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.</li><li>At time = 10, the CPU finishes task 1 and becomes idle.</li></ul><p><strong>Example 2:</strong></p><ul><li><strong>Input:</strong> tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]</li><li><strong>Output:</strong> [4,3,2,0,1]</li><li><strong>Explanation:</strong> The events go as follows:</li></ul><ul><li>At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.</li><li>Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.</li><li>At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.</li><li>At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.</li><li>At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.</li><li>At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.</li><li>At time = 40, the CPU finishes task 1 and becomes idle.</li></ul><p><strong>Constraints:</strong></p><ul><li><code>tasks.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= enqueueTimei, processingTimei &lt;= 10^9</code></li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>執行緒排程問題，直覺會將所有的 <code>task</code> 排序後，依據時間從 <code>0</code> 走到最後來處理這個問題，但是當秒數很大時，就會浪費很多時間，所以我們應該注意的時每個 <code>trigger point</code>，也就是新的 <code>task</code> 任務加入與結束的時候。</li><li>討論兩個情況，<ol><li>當 Thread 是閒置時，直接跳到最前面的 <code>task</code>(即 trigger point 是任務加入時)。</li><li>當 Thread 不是閒置時，會將當下的 <code>task</code> 執行完後，所以得到結束的時間後，一次將符合 <code>enqueueTime</code> 的 <code>task</code> 加入佇列(即 trigger point 是任務結束時)。</li></ol></li><li>由於這裡會優先處理 <code>processingTime</code> 較短的，所以在這裡可以用 <code>min heap</code> 來處理。</li><li>需注意，在排序前需先標記索引值。</li><li>需注意，<code>timestamp</code> 可能是大數。</li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-heap-priority-queue>1. Heap (Priority Queue)<a hidden class=anchor aria-hidden=true href=#1-heap-priority-queue>#</a></h4><ul><li>Time complexity: \(O(n\log n)\)</li><li>Space complexity: \(O(n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> getOrder(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> tasks) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> comp <span style=color:#f92672>=</span> [](<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> b){<span style=color:#66d9ef>return</span> a.first <span style=color:#f92672>==</span> b.first <span style=color:#f92672>?</span> a.second <span style=color:#f92672>&gt;</span> b.second : a.first <span style=color:#f92672>&gt;</span> b.first;};
</span></span><span style=display:flex><span>    priority_queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>, <span style=color:#66d9ef>decltype</span>(comp)<span style=color:#f92672>&gt;</span> pq(comp);  <span style=color:#75715e>// min heap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> timestamp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> tasks.size();
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res; 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> tasks.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        tasks[i].push_back(i);      <span style=color:#75715e>// 標記索引值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    sort(tasks.begin(), tasks.end());   <span style=color:#75715e>// 排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (res.size() <span style=color:#f92672>&lt;</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pq.empty()) {               <span style=color:#75715e>// 閒置時，時間標籤移動到佇列最前面的任務
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            timestamp <span style=color:#f92672>=</span> tasks[i][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {                        <span style=color:#75715e>// 非閒置時，將時間標籤移動到任務結束時
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>auto</span> top <span style=color:#f92672>=</span> pq.top();
</span></span><span style=display:flex><span>            timestamp <span style=color:#f92672>+=</span> top.first;
</span></span><span style=display:flex><span>            res.push_back(top.second);
</span></span><span style=display:flex><span>            pq.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>&amp;&amp;</span> tasks[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;=</span> timestamp) { <span style=color:#75715e>// 加入所有比時間標籤早的任務
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            pq.push({tasks[i][<span style=color:#ae81ff>1</span>], tasks[i][<span style=color:#ae81ff>2</span>]});    <span style=color:#75715e>// 以 {processingTime, index} 的方式加入 min heap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/leetcode/1962/><span class=title>« 上一頁</span><br><span>[LeetCode] 1962. Remove Stones to Minimize the Total</span>
</a><a class=next href=https://intervalrain.github.io/leetcode/290/><span class=title>下一頁 »</span><br><span>[LeetCode] 290. Word Pattern</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>