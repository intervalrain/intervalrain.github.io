<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 2463. Minimum Total Distance Traveled | Rain Hu's Workspace</title>
<meta name=keywords content="Leetcode"><meta name=description content="2463. Minimum Total Distance Traveled

Hardness: \(\color{red}\textsf{Hard}\)
Ralated Topics: Array、Dynamic Programming、Sorting
\(\color{blue}\textsf{Weekly Contest 318}\)


一、題目
There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://intervalrain.github.io/leetcode/2463/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="[LeetCode] 2463. Minimum Total Distance Traveled"><meta property="og:description" content="2463. Minimum Total Distance Traveled

Hardness: \(\color{red}\textsf{Hard}\)
Ralated Topics: Array、Dynamic Programming、Sorting
\(\color{blue}\textsf{Weekly Contest 318}\)


一、題目
There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots."><meta property="og:type" content="article"><meta property="og:url" content="https://intervalrain.github.io/leetcode/2463/"><meta property="article:section" content="leetcode"><meta property="article:published_time" content="2022-11-08T23:13:52+08:00"><meta property="article:modified_time" content="2022-11-08T23:13:52+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 2463. Minimum Total Distance Traveled"><meta name=twitter:description content="2463. Minimum Total Distance Traveled

Hardness: \(\color{red}\textsf{Hard}\)
Ralated Topics: Array、Dynamic Programming、Sorting
\(\color{blue}\textsf{Weekly Contest 318}\)


一、題目
There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[LeetCode] 2463. Minimum Total Distance Traveled","item":"https://intervalrain.github.io/leetcode/2463/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 2463. Minimum Total Distance Traveled","name":"[LeetCode] 2463. Minimum Total Distance Traveled","description":"2463. Minimum Total Distance Traveled\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Dynamic Programming、Sorting \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\n","keywords":["Leetcode"],"articleBody":"2463. Minimum Total Distance Traveled\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Dynamic Programming、Sorting \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\nThe positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\nAt any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.\nReturn the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.\nNote that\nAll robots move at the same speed. If two robots move in the same direction, they will never collide. If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other. If a robot passes by a factory that reached its limits, it crosses it as if it does not exist. If the robot moved from a position x to a position y, the distance it moved is |y - x|. Example 1:\nInput: robot = [0,4,6], factory = [[2,2],[6,2]] Output: 4 Explanation: As shown in the figure: The first robot at position 0 moves in the positive direction. It will be repaired at the first factory. The second robot at position 4 moves in the negative direction. It will be repaired at the first factory. The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4. Example 2:\nInput: robot = [1,-1], factory = [[-2,1],[2,1]] Output: 2 Explanation: As shown in the figure: The first robot at position 1 moves in the positive direction. It will be repaired at the second factory. The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2. Constraints:\n1 \u003c= robot.length, factory.length \u003c= 100 factory[j].length == 2 -10^9 \u003c= robot[i], positionj \u003c= 10^9 0 \u003c= limitj \u003c= robot.length The input will be generated such that it is always possible to repair every robot. 二、分析 初見此題，最先想到的方法是 Greedy + Binary Search，想法是每個機器人都先找離自己最近的工廠，解法參考如下，但實際上，第一個機器人的選擇會影響接下來的機器人的最近選擇：如 robot = [9,11,99,101], factory = [[7,1],[10,1],[14,1],[96,1][100,1],[103,1]]，若第一個位置在 9 的機器人選擇了位置在 10 的工廠，則會影響位置在 11 的機器人最近的工廠在 14，而這樣的選擇就導致錯過了最近解。所以這種解法還需要一些修正。 long long minimumTotalDistance(vector\u003cint\u003e\u0026 robot, vector\u003cvector\u003cint\u003e\u003e\u0026 factory) { map\u003cint,int\u003e mp; long long res = 0; for (auto f : factory) { if (f[1] == 0) continue; mp[f[0]] = f[1]; } for (auto r : robot) { auto it = mp.lower_bound(r); if (it == mp.end()) { it--; } else if (it != mp.begin()){ auto right = it--; if (r - it-\u003efirst \u003e right-\u003efirst - r) { it = right; } } res += abs(it-\u003efirst - r); if (it-\u003esecond == 1) { mp.erase(it); } else { it-\u003esecond--; } } 也許可以將透過 sorting 將機器人分為幾個子群對應幾個工廠。 如果用 dfs + memoization 也就是 dynamic programming 的方式應該可解，透過將 factory 扁平化，並經過 sort 的之後，令 dp(i, j) 為總步數，i 為由左數到右第 ith 個機器人，j 為由左數到右第 jth 個工廠的「空位」。 三、解題 1. DP Time complexity: \\(O(m\\times n\\times k)\\) Space complexity: \\(O(m\\times n\\times k)\\) m = robot.size(), n = factory.size(), k = max(factory[i].size()) vector\u003cvector\u003clong long\u003e\u003e dp; long long minimumTotalDistance(vector\u003cint\u003e\u0026 robot, vector\u003cvector\u003cint\u003e\u003e\u0026 factory) { long long res = 0; vector\u003cint\u003e fac; for (auto f : factory) { // 將 factory 扁平化成 1d array int times = f[1]; while (times--) { fac.push_back(f[0]); } } dp = vector\u003cvector\u003clong long\u003e\u003e(robot.size()+1, vector\u003clong long\u003e(fac.size()+1, -1)); sort(robot.begin(), robot.end()); sort(fac.begin(), fac.end()); return dfs(robot, fac, 0, 0); } long long dfs(vector\u003cint\u003e\u0026 robot, vector\u003cint\u003e\u0026 fac, int i, int j) { if (i == robot.size()) return 0; // 當機器人都排列完畢，為終止條件 if (j == fac.size()) return (long long) (LONG_MAX/2); // 工廠空缺空用了，傳回一個有效的大數，使之不會是答案 if (dp[i][j] != -1) return dp[i][j]; dp[i][j] = min( dfs(robot, fac, i+1, j+1) + (long long)abs(robot[i]-fac[j]), // ith 機器人選擇 jth 工廠空位 dfs(robot, fac, i, j+1) // ith 機器人不選擇 jth 工廠空位 ); return dp[i][j]; } 回目錄 Catalog\n","wordCount":"829","inLanguage":"en","datePublished":"2022-11-08T23:13:52+08:00","dateModified":"2022-11-08T23:13:52+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/leetcode/2463/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a></div><h1 class=post-title>[LeetCode] 2463. Minimum Total Distance Traveled</h1><div class=post-meta>&lt;span title='2022-11-08 23:13:52 +0800 +0800'>November 8, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//leetcode/2463.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-dp aria-label="1. DP">1. DP</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>2463. Minimum Total Distance Traveled</strong></p><ul><li>Hardness: \(\color{red}\textsf{Hard}\)</li><li>Ralated Topics: <code>Array</code>、<code>Dynamic Programming</code>、<code>Sorting</code></li><li>\(\color{blue}\textsf{Weekly Contest 318}\)</li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>There are some robots and factories on the X-axis. You are given an integer array <code>robot</code> where <code>robot[i]</code> is the position of the <code>ith</code> robot. You are also given a 2D integer array <code>factory</code> where <code>factory[j] = [positionj, limitj]</code> indicates that <code>positionj</code> is the position of the <code>jth</code> factory and that the <code>jth</code> factory can repair at most <code>limitj</code> robots.</p><p>The positions of each robot are <strong>unique</strong>. The positions of each factory are also <strong>unique</strong>. Note that a robot can be <strong>in the same position</strong> as a factory initially.</p><p>All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.</p><p><strong>At any moment</strong>, you can set the initial direction of moving for <strong>some</strong> robot. Your target is to minimize the total distance traveled by all the robots.<br>Return <em>the minimum total distance traveled by all the robots</em>. The test cases are generated such that all the robots can be repaired.</p><p><strong>Note that</strong></p><ul><li>All robots move at the same speed.</li><li>If two robots move in the same direction, they will never collide.</li><li>If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.</li><li>If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.</li><li>If the robot moved from a position <code>x</code> to a position <code>y</code>, the distance it moved is <code>|y - x|</code>.</li></ul><p><img loading=lazy src=https://assets.leetcode.com/uploads/2022/09/15/example1.jpg alt=ex1>
<strong>Example 1:</strong></p><ul><li><strong>Input:</strong> robot = [0,4,6], factory = [[2,2],[6,2]]</li><li><strong>Output:</strong> 4</li><li><strong>Explanation:</strong> As shown in the figure:</li></ul><ul><li>The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.</li><li>The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.</li><li>The third robot at position 6 will be repaired at the second factory. It does not need to move.<br>The limit of the first factory is 2, and it fixed 2 robots.<br>The limit of the second factory is 2, and it fixed 1 robot.<br>The total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.</li></ul><p><img loading=lazy src=https://assets.leetcode.com/uploads/2022/09/15/example-2.jpg alt=ex2>
<strong>Example 2:</strong></p><ul><li><strong>Input:</strong> robot = [1,-1], factory = [[-2,1],[2,1]]</li><li><strong>Output:</strong> 2</li><li><strong>Explanation:</strong> As shown in the figure:</li></ul><ul><li>The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.</li><li>The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.<br>The limit of the first factory is 1, and it fixed 1 robot.<br>The limit of the second factory is 1, and it fixed 1 robot.<br>The total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.</li></ul><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li><li><code>factory[j].length == 2</code></li><li><code>-10^9 &lt;= robot[i], positionj &lt;= 10^9</code></li><li><code>0 &lt;= limitj &lt;= robot.length</code></li><li>The input will be generated such that it is always possible to repair every robot.</li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>初見此題，最先想到的方法是 <code>Greedy</code> + <code>Binary Search</code>，想法是每個機器人都先找離自己最近的工廠，解法參考如下，但實際上，第一個機器人的選擇會影響接下來的機器人的最近選擇：如 <code>robot = [9,11,99,101], factory = [[7,1],[10,1],[14,1],[96,1][100,1],[103,1]]</code>，若第一個位置在 <code>9</code> 的機器人選擇了位置在 <code>10</code> 的工廠，則會影響位置在 <code>11</code> 的機器人最近的工廠在 <code>14</code>，而這樣的選擇就導致錯過了最近解。所以這種解法還需要一些修正。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>minimumTotalDistance</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> robot, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> factory) {
</span></span><span style=display:flex><span>    map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> mp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> f : factory) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (f[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        mp[f[<span style=color:#ae81ff>0</span>]] <span style=color:#f92672>=</span> f[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> r : robot) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> mp.lower_bound(r);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (it <span style=color:#f92672>==</span> mp.end()) {
</span></span><span style=display:flex><span>            it<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (it <span style=color:#f92672>!=</span> mp.begin()){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> right <span style=color:#f92672>=</span> it<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>-</span> it<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&gt;</span> right<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>-</span> r) {
</span></span><span style=display:flex><span>                it <span style=color:#f92672>=</span> right;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        res <span style=color:#f92672>+=</span> abs(it<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>-</span> r);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (it<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            mp.erase(it);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            it<span style=color:#f92672>-&gt;</span>second<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>也許可以將透過 <code>sorting</code> 將機器人分為幾個子群對應幾個工廠。</li><li>如果用 <code>dfs</code> + <code>memoization</code> 也就是 <code>dynamic programming</code> 的方式應該可解，透過將 <code>factory</code> 扁平化，並經過 <code>sort</code> 的之後，令 <code>dp(i, j)</code> 為總步數，<code>i</code> 為由左數到右第 <code>ith</code> 個機器人，<code>j</code> 為由左數到右第 <code>jth</code> 個工廠的「空位」。</li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-dp>1. DP<a hidden class=anchor aria-hidden=true href=#1-dp>#</a></h4><ul><li>Time complexity: \(O(m\times n\times k)\)</li><li>Space complexity: \(O(m\times n\times k)\)</li><li><code>m = robot.size()</code>, <code>n = factory.size()</code>, <code>k = max(factory[i].size())</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;&gt;</span> dp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>minimumTotalDistance</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> robot, vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> factory) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> fac;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> f : factory) {        <span style=color:#75715e>// 將 factory 扁平化成 1d array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> times <span style=color:#f92672>=</span> f[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (times<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>            fac.push_back(f[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    dp <span style=color:#f92672>=</span> vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;&gt;</span>(robot.size()<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span>(fac.size()<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    sort(robot.begin(), robot.end());
</span></span><span style=display:flex><span>    sort(fac.begin(), fac.end());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dfs(robot, fac, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>dfs</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> robot, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> fac, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> robot.size()) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;    <span style=color:#75715e>// 當機器人都排列完畢，為終止條件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (j <span style=color:#f92672>==</span> fac.size()) <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>) (LONG_MAX<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>);  <span style=color:#75715e>// 工廠空缺空用了，傳回一個有效的大數，使之不會是答案
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (dp[i][j] <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> dp[i][j];
</span></span><span style=display:flex><span>    dp[i][j] <span style=color:#f92672>=</span> min(
</span></span><span style=display:flex><span>        dfs(robot, fac, i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> (<span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)abs(robot[i]<span style=color:#f92672>-</span>fac[j]),    <span style=color:#75715e>// ith 機器人選擇 jth 工廠空位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        dfs(robot, fac, i, j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)                                         <span style=color:#75715e>// ith 機器人不選擇 jth 工廠空位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dp[i][j];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/leetcode/1544/><span class=title>« Prev Page</span><br><span>[LeetCode] 1544. Make The String Great</span>
</a><a class=next href=https://intervalrain.github.io/leetcode/2462/><span class=title>Next Page »</span><br><span>[LeetCode] 2462. Total Cost to Hire K</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>