<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 2467. Most Profitable Path in a Tree | Rain Hu's Workspace</title><meta name=keywords content="Leetcode"><meta name=description content="2467. Most Profitable Path in a Tree

Hardness: \(\color{orange}\textsf{Medium}\)
Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph
\(\color{blue}\textsf{Biweekly Contest 91}\)


一、題目
There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.
At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4c6c0beaf1dfe52cd0f712a5896ac127e66fd064cfc598e04750f496d470699e.css integrity="sha256-TGwL6vHf5SzQ9xKliWrBJ+Zv0GTPxZjgR1D0ltRwaZ4=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/leetcode/2467/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/leetcode/2467/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[LeetCode] 2467. Most Profitable Path in a Tree"><meta property="og:description" content="2467. Most Profitable Path in a Tree
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="leetcode"><meta property="article:published_time" content="2022-11-24T01:09:51+08:00"><meta property="article:modified_time" content="2022-11-24T01:09:51+08:00"><meta property="article:tag" content="Leetcode"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 2467. Most Profitable Path in a Tree"><meta name=twitter:description content="2467. Most Profitable Path in a Tree

Hardness: \(\color{orange}\textsf{Medium}\)
Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph
\(\color{blue}\textsf{Biweekly Contest 91}\)


一、題目
There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.
At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[LeetCode] 2467. Most Profitable Path in a Tree","item":"https://intervalrain.github.io/leetcode/2467/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 2467. Most Profitable Path in a Tree","name":"[LeetCode] 2467. Most Profitable Path in a Tree","description":"2467. Most Profitable Path in a Tree\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:\n","keywords":["Leetcode"],"articleBody":"2467. Most Profitable Path in a Tree\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:\nthe price needed to open the gate at node i, if amount[i] is negative, or, the cash reward obtained on opening the gate at node i, otherwise. The game goes on as follows: Initially, Alice is at node 0 and Bob is at node bob. At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that: If the gate is already open, no price will be required, nor will there be any cash reward. If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each. If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other. Return the maximum net income Alice can have if she travels towards the optimal leaf node. Example 1:\nInput: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6] Output: 6 Explanation:\nThe above diagram represents the given tree. The game goes as follows: Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\nAlice’s net income is now -2. Both Alice and Bob move to node 1.\nSince they reach here simultaneously, they open the gate together and share the reward.\nAlice’s net income becomes -2 + (4 / 2) = 0. Alice moves on to node 3. Since Bob already opened its gate, Alice’s income remains unchanged.\nBob moves on to node 0, and stops moving. Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income. Example 2:\nInput: edges = [[0,1]], bob = 1, amount = [-7280,2350] Output: -7280 Explanation:\nAlice follows the path 0-\u003e1 whereas Bob follows the path 1-\u003e0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280. Constraints:\n2 \u003c= n \u003c= 10^5 edges.length == n - 1 edges[i].length == 2 0 \u003c= ai, bi \u003c n ai != bi edges represents a valid tree. 1 \u003c= bob \u003c n amount.length == n amount[i] is an even integer in the range [-10^4, 10^4]. 二、分析 先將 graph 建起來。 用 dfs 遍歷所有節點，並回傳 {gain, collide}。 三、解題 1. DFS Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int mostProfitablePath(vector\u003cvector\u003cint\u003e\u003e\u0026 edges, int bob, vector\u003cint\u003e\u0026 amount) { vector\u003cvector\u003cint\u003e\u003e graph(amount.size()); for (const auto\u0026 edge : edges) { graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); } vector\u003cbool\u003e vis(amount.size(), false); return dfs(graph, 0, bob, amount, vis, 1)[0]; } vector\u003cint\u003e dfs(vector\u003cvector\u003cint\u003e\u003e\u0026 graph, int alice, int bob, vector\u003cint\u003e\u0026 amount, vector\u003cbool\u003e\u0026 vis, int round) { int res = INT_MIN; vis[alice] = true; int collide = alice == bob ? 1 : 0; for (int\u0026 next : graph[alice]) { if (vis[next]) continue; vector\u003cint\u003e tmp = dfs(graph, next, bob, amount, vis, round+1); if (tmp[1] \u003e 0) collide = tmp[1] + 1; res = max(res, tmp[0]); } if (collide \u003e 0 \u0026\u0026 collide \u003c= round) { if (collide == round) amount[alice] \u003e\u003e= 1; else amount[alice] = 0; } return {res == INT_MIN ? amount[alice] : amount[alice] + res, collide}; } 回目錄 Catalog\n","wordCount":"690","inLanguage":"zh-tw","datePublished":"2022-11-24T01:09:51+08:00","dateModified":"2022-11-24T01:09:51+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/leetcode/2467/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a></div><h1 class="post-title entry-hint-parent">[LeetCode] 2467. Most Profitable Path in a Tree</h1><div class=post-meta><span title='2022-11-24 01:09:51 +0800 +0800'>November 24, 2022</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//leetcode/2467.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-dfs aria-label="1. DFS">1. DFS</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>2467. Most Profitable Path in a Tree</strong></p><ul><li>Hardness: \(\color{orange}\textsf{Medium}\)</li><li>Ralated Topics: <code>Array</code>、<code>Tree</code>、<code>Depth-First Search</code>、<code>Breadth-First Search</code>、<code>Graph</code></li><li>\(\color{blue}\textsf{Biweekly Contest 91}\)</li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, rooted at node <code>0</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an edge between nodes <code>ai</code> and <code>bi</code> in the tree.
At every node <code>i</code>, there is a gate. You are also given an array of even integers <code>amount</code>, where <code>amount[i]</code> represents:</p><ul><li>the price needed to open the gate at node <code>i</code>, if <code>amount[i]</code> is negative, or,</li><li>the cash reward obtained on opening the gate at node <code>i</code>, otherwise.
The game goes on as follows:</li><li>Initially, Alice is at node <code>0</code> and Bob is at node <code>bob</code>.</li><li>At every second, Alice and Bob <strong>each</strong> move to an adjacent node. Alice moves towards some <strong>leaf node</strong>, while Bob moves towards node <code>0</code>.</li><li>For <strong>every</strong> node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:<ul><li>If the gate is <strong>already open</strong>, no price will be required, nor will there be any cash reward.</li><li>If Alice and Bob reach the node <strong>simultaneously</strong>, they share the price/reward for opening the gate there. In other words, if the price to open the gate is <code>c</code>, then both Alice and Bob pay <code>c / 2</code> each. Similarly, if the reward at the gate is <code>c</code>, both of them receive <code>c / 2</code> each.</li></ul></li><li>If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node <code>0</code>, he stops moving. Note that these events are <strong>independent</strong> of each other.
Return <em>the <em><strong>maximum</strong></em> net income Alice can have if she travels towards the optimal leaf node</em>.</li></ul><p><strong>Example 1:</strong><br><img alt=eg1 loading=lazy src=https://assets.leetcode.com/uploads/2022/10/29/eg1.png></p><ul><li><strong>Input:</strong> edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]</li><li><strong>Output:</strong> 6</li><li><strong>Explanation:</strong><br>The above diagram represents the given tree. The game goes as follows:</li></ul><ul><li>Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.<br>Alice&rsquo;s net income is now -2.</li><li>Both Alice and Bob move to node 1.<br>Since they reach here simultaneously, they open the gate together and share the reward.<br>Alice&rsquo;s net income becomes -2 + (4 / 2) = 0.</li><li>Alice moves on to node 3. Since Bob already opened its gate, Alice&rsquo;s income remains unchanged.<br>Bob moves on to node 0, and stops moving.</li><li>Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.<br>Now, neither Alice nor Bob can make any further moves, and the game ends.<br>It is not possible for Alice to get a higher net income.</li></ul><p><img alt=eg2 loading=lazy src=https://assets.leetcode.com/uploads/2022/10/29/eg2.png>
<strong>Example 2:</strong></p><ul><li><strong>Input:</strong> edges = [[0,1]], bob = 1, amount = [-7280,2350]</li><li><strong>Output:</strong> -7280</li><li><strong>Explanation:</strong><br>Alice follows the path 0->1 whereas Bob follows the path 1->0.<br>Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280.</li></ul><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li><code>edges</code> represents a valid tree.</li><li><code>1 &lt;= bob &lt; n</code></li><li><code>amount.length == n</code></li><li><code>amount[i]</code> is an <strong>even</strong> integer in the range <code>[-10^4, 10^4]</code>.</li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>先將 <code>graph</code> 建起來。</li><li>用 <code>dfs</code> 遍歷所有節點，並回傳 {gain, collide}。</li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-dfs>1. DFS<a hidden class=anchor aria-hidden=true href=#1-dfs>#</a></h4><ul><li>Time complexity: \(O(n)\)</li><li>Space complexity: \(O(n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mostProfitablePath</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> edges, <span style=color:#66d9ef>int</span> bob, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> amount) {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> graph(amount.size());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> edge : edges) {
</span></span><span style=display:flex><span>        graph[edge[<span style=color:#ae81ff>0</span>]].push_back(edge[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>        graph[edge[<span style=color:#ae81ff>1</span>]].push_back(edge[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> vis(amount.size(), false);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dfs(graph, <span style=color:#ae81ff>0</span>, bob, amount, vis, <span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dfs(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> graph, <span style=color:#66d9ef>int</span> alice, <span style=color:#66d9ef>int</span> bob, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> amount, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;&amp;</span> vis, <span style=color:#66d9ef>int</span> round) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> INT_MIN;
</span></span><span style=display:flex><span>    vis[alice] <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> collide <span style=color:#f92672>=</span> alice <span style=color:#f92672>==</span> bob <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> next : graph[alice]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (vis[next]) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> tmp <span style=color:#f92672>=</span> dfs(graph, next, bob, amount, vis, round<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tmp[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) collide <span style=color:#f92672>=</span> tmp[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> max(res, tmp[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (collide <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> collide <span style=color:#f92672>&lt;=</span> round) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (collide <span style=color:#f92672>==</span> round) amount[alice] <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> amount[alice] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {res <span style=color:#f92672>==</span> INT_MIN <span style=color:#f92672>?</span> amount[alice] <span style=color:#f92672>:</span> amount[alice] <span style=color:#f92672>+</span> res, collide};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/leetcode/1926/><span class=title>« 上一頁</span><br><span>[LeetCode] 1926. Nearest Exit from Entrance in Maze</span>
</a><a class=next href=https://intervalrain.github.io/leetcode/2468/><span class=title>下一頁 »</span><br><span>[LeetCode] 2468. Split Message Based on Limit</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>