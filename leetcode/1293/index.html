<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination | Rain Hu's Workspace</title>
<meta name=keywords content="Leetcode"><meta name=description content="1293. Shortest Path in a Grid with Obstacles Elimination

Hardness: \(\color{red}\textsf{Hard}\)
Ralated Topics: Array、Breadth-First Search、Matrix


一、題目
You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.
Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/leetcode/1293/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/leetcode/1293/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination"><meta property="og:description" content="1293. Shortest Path in a Grid with Obstacles Elimination
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.
Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1."><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="leetcode"><meta property="article:published_time" content="2022-10-30T21:29:37+08:00"><meta property="article:modified_time" content="2022-10-30T21:29:37+08:00"><meta property="article:tag" content="Leetcode"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination"><meta name=twitter:description content="1293. Shortest Path in a Grid with Obstacles Elimination

Hardness: \(\color{red}\textsf{Hard}\)
Ralated Topics: Array、Breadth-First Search、Matrix


一、題目
You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.
Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination","item":"https://intervalrain.github.io/leetcode/1293/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination","name":"[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination","description":"1293. Shortest Path in a Grid with Obstacles Elimination\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.\nReturn the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.\n","keywords":["Leetcode"],"articleBody":"1293. Shortest Path in a Grid with Obstacles Elimination\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.\nReturn the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.\nExample 1:\nInput: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1 Output: 6 Explanation:\nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -\u003e (0,1) -\u003e (0,2) -\u003e (1,2) -\u003e (2,2) -\u003e (3,2) -\u003e (4,2). Example 2: Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1 Output: -1 Explanation:\nWe need to eliminate at least two obstacles to find such a walk. Constraints:\nm == grid.length n == grid[i].length 1 \u003c= m, n \u003c= 40 1 \u003c= k \u003c= m * n grid[i][j] is either 0 or 1. grid[0][0] == grid[m - 1][n - 1] == 0 二、分析 本題可以搭配 BFS，最早滿足終止條件時，回傳即為最短路徑。 由於本題並非可以單純的藉 visited 來記錄是否拜訪過，因為多了一個變數 k，所以在此可以將 vector","wordCount":"365","inLanguage":"zh-tw","datePublished":"2022-10-30T21:29:37+08:00","dateModified":"2022-10-30T21:29:37+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/leetcode/1293/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a></div><h1 class="post-title entry-hint-parent">[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination</h1><div class=post-meta><span title='2022-10-30 21:29:37 +0800 +0800'>October 30, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//leetcode/1293.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-bfs aria-label="1. BFS">1. BFS</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>1293. Shortest Path in a Grid with Obstacles Elimination</strong></p><ul><li>Hardness: \(\color{red}\textsf{Hard}\)</li><li>Ralated Topics: <code>Array</code>、<code>Breadth-First Search</code>、<code>Matrix</code></li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>You are given an <code>m x n</code> integer matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (obstacles). You can move up, down, left, or right from and to an empty cell in <strong>one step</strong>.<br>Return <em>the minimum number of</em> <em><strong>steps</strong></em> <em>to walk from the upper left corner</em> <code>(0, 0)</code> <em>to the lower right conrer</em> <code>m-1, n-1</code> <em>given that you can eliminate</em> <em><strong>at most</strong></em> <code>k</code> <em>obstacles</em>. If it is not possible to find such walk return <code>-1</code>.</p><p><strong>Example 1:</strong><br><img alt=short1-grid loading=lazy src=https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg></p><ul><li><strong>Input:</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1</li><li><strong>Output:</strong> 6</li><li><strong>Explanation:</strong><br>The shortest path without eliminating any obstacle is 10.<br>The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).</li></ul><p><strong>Example 2:</strong>
<img alt=short2-grid loading=lazy src=https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg></p><ul><li><strong>Input:</strong> grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1</li><li><strong>Output:</strong> -1</li><li><strong>Explanation:</strong><br>We need to eliminate at least two obstacles to find such a walk.</li></ul><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 40</code></li><li><code>1 &lt;= k &lt;= m * n</code></li><li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li><li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>本題可以搭配 <code>BFS</code>，最早滿足終止條件時，回傳即為最短路徑。</li><li>由於本題並非可以單純的藉 <code>visited</code> 來記錄是否拜訪過，因為多了一個變數 <code>k</code>，所以在此可以將 <code>vector&lt;vector&lt;bool>> visited</code> 換成 <code>vector&lt;vector&lt;int>> visited</code>，並將記錄的值改成<strong>剩餘可消除障礙物的次數</strong>，依 <code>greedy</code> 的想法，在走同樣的距離下，<strong>剩餘可消除障礙物的次數</strong>愈多愈好，故我們可將拜訪過，但「剩餘次數少於或等於 <code>visited[row][col]</code>」的節點跳過。</li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-bfs>1. BFS<a hidden class=anchor aria-hidden=true href=#1-bfs>#</a></h4><ul><li>Time complexity: \(O(m\times n\times k)\)</li><li>Space complexity: \(O(m\times n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> dirc[<span style=color:#ae81ff>4</span>][<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>},{<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>},{<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>},{<span style=color:#ae81ff>0</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>}};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>shortestPath</span>(vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;&amp;</span> grid, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> grid.size(), n <span style=color:#f92672>=</span> grid[<span style=color:#ae81ff>0</span>].size();
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> visited(m, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(n, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));  <span style=color:#75715e>// 餘愈多愈好，故預設為 -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    queue<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q; <span style=color:#75715e>// {row, col, len, k}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    q.push({<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>,k});
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> info <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> row <span style=color:#f92672>=</span> info[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> col <span style=color:#f92672>=</span> info[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> info[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> bomb <span style=color:#f92672>=</span> info[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 超出範圍 out of bound
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> col <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> row <span style=color:#f92672>&gt;=</span> m <span style=color:#f92672>||</span> col <span style=color:#f92672>&gt;=</span> n) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 終止條件，到達右下角 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (row <span style=color:#f92672>==</span> m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> col <span style=color:#f92672>==</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>return</span> len;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 遇到障礙物
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (grid[row][col] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (bomb <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) 
</span></span><span style=display:flex><span>                bomb<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> 
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 減枝：拜訪過且剩餘次數較少者跳過
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (visited[row][col] <span style=color:#f92672>&gt;=</span> bomb) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        visited[row][col] <span style=color:#f92672>=</span> bomb;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 將下一步加入佇列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> d : dirc){
</span></span><span style=display:flex><span>            q.push({row<span style=color:#f92672>+</span>d[<span style=color:#ae81ff>0</span>], col<span style=color:#f92672>+</span>d[<span style=color:#ae81ff>1</span>], len<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, bomb});
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/leetcode/19/><span class=title>« 上一頁</span><br><span>[LeetCode] 19. Remove Nth Node From End of List</span>
</a><a class=next href=https://intervalrain.github.io/leetcode/2136/><span class=title>下一頁 »</span><br><span>[LeetCode] 2136. Earliest Possible Day of Full Bloom</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>