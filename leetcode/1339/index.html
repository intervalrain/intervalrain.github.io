<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[LeetCode] 1339. Maximum Product of Splitted Binary Tree | Rain Hu's Workspace</title>
<meta name=keywords content="Leetcode"><meta name=description content="1339. Maximum Product of Splitted Binary Tree

Hardness: \(\color{orange}\textsf{Medium}\)
Ralated Topics: Tree、Depth-First Search、Binary Tree


一、題目
Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.
Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.
Note that you need to maximize the answer before taking the mod and not after taking it."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/leetcode/1339/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/leetcode/1339/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[LeetCode] 1339. Maximum Product of Splitted Binary Tree"><meta property="og:description" content="1339. Maximum Product of Splitted Binary Tree
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.
Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.
Note that you need to maximize the answer before taking the mod and not after taking it."><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="leetcode"><meta property="article:published_time" content="2022-12-10T20:12:36+08:00"><meta property="article:modified_time" content="2022-12-10T20:12:36+08:00"><meta property="article:tag" content="Leetcode"><meta name=twitter:card content="summary"><meta name=twitter:title content="[LeetCode] 1339. Maximum Product of Splitted Binary Tree"><meta name=twitter:description content="1339. Maximum Product of Splitted Binary Tree

Hardness: \(\color{orange}\textsf{Medium}\)
Ralated Topics: Tree、Depth-First Search、Binary Tree


一、題目
Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.
Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.
Note that you need to maximize the answer before taking the mod and not after taking it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[LeetCode] 1339. Maximum Product of Splitted Binary Tree","item":"https://intervalrain.github.io/leetcode/1339/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[LeetCode] 1339. Maximum Product of Splitted Binary Tree","name":"[LeetCode] 1339. Maximum Product of Splitted Binary Tree","description":"1339. Maximum Product of Splitted Binary Tree\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.\nNote that you need to maximize the answer before taking the mod and not after taking it.\n","keywords":["Leetcode"],"articleBody":"1339. Maximum Product of Splitted Binary Tree\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.\nNote that you need to maximize the answer before taking the mod and not after taking it.\nExample 1:\nInput: root = [1,2,3,4,5,6] Output: 110 Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (10*10) Example 2: Input: root = [1,null,2,3,4,null,null,5,6] Output: 90 Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6) Constraints:\nThe number of nodes in the tree is in the range [2, 5 * 10^4]. 1 \u003c= Node.val \u003c= 10^4 二、分析 這一題的關鍵在於，求切斷的 edge 兩邊的乘積為最大值。而一但我們知道整棵樹的總和之後，我們便只要知道切斷的其中一邊的和為多少，便可以知道另一邊的和為多少。 one = total - another 經觀察我們可以發現，節點與其所有子葉的和，代表了切斷的 edge 的其中一邊。 故我們只需遍歷整個樹，並把當下節點與所有子葉的和，記錄到 vector 中，再利用 one = total - another 的關係，求得最大乘積。 需要注意此題為大數問題，要注意返回的值要先比較之後才取餘數。 三、解題 1. DFS Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) #define ll long long int #define MOD 1000000007 int maxProduct(TreeNode* root) { vector\u003cll\u003e vec; int total = dfs(root, vec); // 遍歷樹，並算出整棵樹的和 ll res = 0; for (ll\u0026 x : vec) { res = max(res, x * (total-x)); // 截斷邊的兩側樹的和分別為 x 與 total - x } return res % MOD; } int dfs(TreeNode* root, vector\u003cll\u003e vec) { if (!root) return 0; int left = dfs(root-\u003eleft, vec); int right = dfs(root-\u003eright, vec); vec.push_back(root-\u003eval + left + right); // 將子樹的總和記到 vector 中 return vec.back(); // 返回子樹的總和，讓父節點可以使用 } 回目錄 Catalog\n","wordCount":"278","inLanguage":"zh-tw","datePublished":"2022-12-10T20:12:36+08:00","dateModified":"2022-12-10T20:12:36+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/leetcode/1339/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a></div><h1 class="post-title entry-hint-parent">[LeetCode] 1339. Maximum Product of Splitted Binary Tree</h1><div class=post-meta><span title='2022-12-10 20:12:36 +0800 +0800'>December 10, 2022</span>&nbsp;·&nbsp;2 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//leetcode/1339.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%a1%8c%e7%9b%ae aria-label=一、題目>一、題目</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9e%90 aria-label=二、分析>二、分析</a></li><li><a href=#%e4%b8%89%e8%a7%a3%e9%a1%8c aria-label=三、解題>三、解題</a><ul><li><a href=#1-dfs aria-label="1. DFS">1. DFS</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>1339. Maximum Product of Splitted Binary Tree</strong></p><ul><li>Hardness: \(\color{orange}\textsf{Medium}\)</li><li>Ralated Topics: <code>Tree</code>、<code>Depth-First Search</code>、<code>Binary Tree</code></li></ul><hr><h3 id=一題目>一、題目<a hidden class=anchor aria-hidden=true href=#一題目>#</a></h3><p>Given the <code>root</code> of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.<br>Return <em>the maximum product of the sums of the two subtrees</em>. Since the answer may be too large, return it <strong>modulo</strong> <code>10^9 + 7</code>.<br><strong>Note</strong> that you need to maximize the answer before taking the mod and not after taking it.</p><p><strong>Example 1:</strong><br><img alt=sample1 loading=lazy src=https://assets.leetcode.com/uploads/2020/01/21/sample_1_1699.png></p><ul><li><strong>Input:</strong> root = [1,2,3,4,5,6]</li><li><strong>Output:</strong> 110</li><li><strong>Explanation:</strong> Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (10*10)</li></ul><p><strong>Example 2:</strong>
<img alt=sample2 loading=lazy src=https://assets.leetcode.com/uploads/2020/01/21/sample_2_1699.png></p><ul><li><strong>Input:</strong> root = [1,null,2,3,4,null,null,5,6]</li><li><strong>Output:</strong> 90</li><li><strong>Explanation:</strong> Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)</li></ul><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[2, 5 * 10^4]</code>.</li><li><code>1 &lt;= Node.val &lt;= 10^4</code></li></ul><hr><h3 id=二分析>二、分析<a hidden class=anchor aria-hidden=true href=#二分析>#</a></h3><ul><li>這一題的關鍵在於，求切斷的 <code>edge</code> 兩邊的乘積為最大值。而一但我們知道整棵樹的總和之後，我們便只要知道切斷的其中一邊的和為多少，便可以知道另一邊的和為多少。<ul><li><code>one = total - another</code></li></ul></li><li>經觀察我們可以發現，<strong>節點與其所有子葉的和</strong>，代表了切斷的 <code>edge</code> 的其中一邊。</li><li>故我們只需遍歷整個樹，並把<strong>當下節點與所有子葉的和</strong>，記錄到 <code>vector</code> 中，再利用 <code>one = total - another</code> 的關係，求得最大乘積。</li><li>需要注意此題為大數問題，要注意返回的值要先比較之後才取餘數。</li></ul><h3 id=三解題>三、解題<a hidden class=anchor aria-hidden=true href=#三解題>#</a></h3><h4 id=1-dfs>1. DFS<a hidden class=anchor aria-hidden=true href=#1-dfs>#</a></h4><ul><li>Time complexity: \(O(n)\)</li><li>Space complexity: \(O(n)\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#define ll long long int
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MOD 1000000007
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxProduct</span>(TreeNode<span style=color:#f92672>*</span> root) {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> vec;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> total <span style=color:#f92672>=</span> dfs(root, vec); <span style=color:#75715e>// 遍歷樹，並算出整棵樹的和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ll res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (ll<span style=color:#f92672>&amp;</span> x : vec) {
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> max(res, x <span style=color:#f92672>*</span> (total<span style=color:#f92672>-</span>x));  <span style=color:#75715e>// 截斷邊的兩側樹的和分別為 x 與 total - x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(TreeNode<span style=color:#f92672>*</span> root, vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> vec) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> dfs(root<span style=color:#f92672>-&gt;</span>left, vec);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> right <span style=color:#f92672>=</span> dfs(root<span style=color:#f92672>-&gt;</span>right, vec);
</span></span><span style=display:flex><span>    vec.push_back(root<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>+</span> left <span style=color:#f92672>+</span> right);    <span style=color:#75715e>// 將子樹的總和記到 vector 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> vec.back();                          <span style=color:#75715e>// 返回子樹的總和，讓父節點可以使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><a href=/leetcode>回目錄 Catalog</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/leetcode/>Leetcode</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/leetcode/1026/><span class=title>« 上一頁</span><br><span>[LeetCode] 1026. Maximum Difference Between Node and Ancestor</span>
</a><a class=next href=https://intervalrain.github.io/leetcode/124/><span class=title>下一頁 »</span><br><span>[LeetCode] 124. Binary Tree Maximum Path Sum</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>