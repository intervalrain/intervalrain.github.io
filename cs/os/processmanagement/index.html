<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[計算機作業系統] 進程管理 | Rain Hu's Workspace</title><meta name=keywords content="OS,CS"><meta name=description content="進程管理
進程與執行緒
1. 進程(process)

進程是資源分配的基本單位。
進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。


2. 執行緒(thread)

執行緒又稱線程，是獨立調度的基本單位。
一個進程可以有多個執行緒，它們共享進程資源。
以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。


3. 區別

擁有資源

進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。


調度

執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。


系統開銷

由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。
同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。


通訊

執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。



進程狀態的切換


就緒就態(ready)：等待被調度
執行狀態(running)
阻塞狀態(waiting)：等待資源

只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。
阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。



進程調度演算法

不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。

1. 批次處理系統(batch system)

批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。

1.1 先來先服務(first-come first-served, FCFS)

非搶占式的調度，按照請求的順序進行調度。
有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長

1.2 短作業優先(shortest job first, SJF)

非搶占式的調度算法，按估計運行時間最短的順序進行調度。
長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。

1.3 最短剩餘時間優先(shortest remaining time next, SRTN)

最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。

2. 交互式系統(time-sharing system)

交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。

2.1 時間片段輪轉(robin round scheduling, RR)

將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。
時間片段輪轉演算法的效率和時間片段的大小很有關係：

因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。
而如果時間片段過長，那麼實時性就不能得到保証。



2.2 優先級調度(priority scheduling)

為每個進程分配一個優先級，按優先級進行調度。
為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。

2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ)

一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。
多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,&mldr;。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。
每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。


3. 實時系統(real time system)

實時系統要求一個請求在一個確定時間內得到響應。
分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。

進程同步
1. 臨界區

對臨界資源進行訪問的那段代碼稱為臨界區。
為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。

// entry section
// crtical section;
// exit section
2. 同步與互斥(synchronization and mutex)

同步(synchronization)：多個進程因為合作產生的直接制約關係，使得進程有一定的先後執行關係。
互斥(mutual exclusion, mutex)：多個進程在同一時刻只有一個進程能進入臨界區。

3. 號誌(Semaphore)

號誌，或稱信號量，是一個整數變數，可以對其執行 down 和 up 操作，也就是常見的 P 和 V 操作。

down：如果號誌量大於 0，執行 -1 操作；如果號誌等於 0，進程睡眠，等待號誌大於 0。
up：對號誌執行 +1 操作，喚醒睡眠的進程讓其完成 down 操作。


down 和 up 操作需要被設計成原語，不可分割，通常的做法是在執行這些操作的時候屏蔽中斷。
如果號誌的取值只能為 0 或者 1，那麼就成為了互斥(mutex)，0 表示臨界區已經加鎖，1 表示臨界區解鎖。

typedef int semaphore;
semaphore mutex = 1;
void P1(){
    down(&amp;mutex);
    // critical section
    up(&amp;mutex);
}

void P2(){
    down(&amp;mutex);
    // critical section
    up(&amp;mutex);
}

使用號誌實現生產者-消費者問題
"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/cs/os/processmanagement/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/cs/os/processmanagement/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[計算機作業系統] 進程管理"><meta property="og:description" content="進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 通訊 執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.3 最短剩餘時間優先(shortest remaining time next, SRTN) 最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。 2. 交互式系統(time-sharing system) 交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。 2.1 時間片段輪轉(robin round scheduling, RR) 將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。 時間片段輪轉演算法的效率和時間片段的大小很有關係： 因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。 而如果時間片段過長，那麼實時性就不能得到保証。 2.2 優先級調度(priority scheduling) 為每個進程分配一個優先級，按優先級進行調度。 為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。 2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ) 一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。 多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,…。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。 每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。 3. 實時系統(real time system) 實時系統要求一個請求在一個確定時間內得到響應。 分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。 進程同步 1. 臨界區 對臨界資源進行訪問的那段代碼稱為臨界區。 為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。 // entry section // crtical section; // exit section 2. 同步與互斥(synchronization and mutex) 同步(synchronization)：多個進程因為合作產生的直接制約關係，使得進程有一定的先後執行關係。 互斥(mutual exclusion, mutex)：多個進程在同一時刻只有一個進程能進入臨界區。 3. 號誌(Semaphore) 號誌，或稱信號量，是一個整數變數，可以對其執行 down 和 up 操作，也就是常見的 P 和 V 操作。 down：如果號誌量大於 0，執行 -1 操作；如果號誌等於 0，進程睡眠，等待號誌大於 0。 up：對號誌執行 +1 操作，喚醒睡眠的進程讓其完成 down 操作。 down 和 up 操作需要被設計成原語，不可分割，通常的做法是在執行這些操作的時候屏蔽中斷。
如果號誌的取值只能為 0 或者 1，那麼就成為了互斥(mutex)，0 表示臨界區已經加鎖，1 表示臨界區解鎖。 typedef int semaphore; semaphore mutex = 1; void P1(){ down(&amp;mutex); // critical section up(&amp;mutex); } void P2(){ down(&amp;mutex); // critical section up(&amp;mutex); } 使用號誌實現生產者-消費者問題 "><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="cs"><meta property="article:published_time" content="2022-07-02T04:00:55+08:00"><meta property="article:modified_time" content="2022-07-02T04:00:55+08:00"><meta property="article:tag" content="OS"><meta property="article:tag" content="CS"><meta name=twitter:card content="summary"><meta name=twitter:title content="[計算機作業系統] 進程管理"><meta name=twitter:description content="進程管理
進程與執行緒
1. 進程(process)

進程是資源分配的基本單位。
進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。


2. 執行緒(thread)

執行緒又稱線程，是獨立調度的基本單位。
一個進程可以有多個執行緒，它們共享進程資源。
以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。


3. 區別

擁有資源

進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。


調度

執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。


系統開銷

由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。
同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。


通訊

執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。



進程狀態的切換


就緒就態(ready)：等待被調度
執行狀態(running)
阻塞狀態(waiting)：等待資源

只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。
阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。



進程調度演算法

不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。

1. 批次處理系統(batch system)

批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。

1.1 先來先服務(first-come first-served, FCFS)

非搶占式的調度，按照請求的順序進行調度。
有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長

1.2 短作業優先(shortest job first, SJF)

非搶占式的調度算法，按估計運行時間最短的順序進行調度。
長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。

1.3 最短剩餘時間優先(shortest remaining time next, SRTN)

最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。

2. 交互式系統(time-sharing system)

交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。

2.1 時間片段輪轉(robin round scheduling, RR)

將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。
時間片段輪轉演算法的效率和時間片段的大小很有關係：

因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。
而如果時間片段過長，那麼實時性就不能得到保証。



2.2 優先級調度(priority scheduling)

為每個進程分配一個優先級，按優先級進行調度。
為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。

2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ)

一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。
多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,&mldr;。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。
每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。


3. 實時系統(real time system)

實時系統要求一個請求在一個確定時間內得到響應。
分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。

進程同步
1. 臨界區

對臨界資源進行訪問的那段代碼稱為臨界區。
為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。

// entry section
// crtical section;
// exit section
2. 同步與互斥(synchronization and mutex)

同步(synchronization)：多個進程因為合作產生的直接制約關係，使得進程有一定的先後執行關係。
互斥(mutual exclusion, mutex)：多個進程在同一時刻只有一個進程能進入臨界區。

3. 號誌(Semaphore)

號誌，或稱信號量，是一個整數變數，可以對其執行 down 和 up 操作，也就是常見的 P 和 V 操作。

down：如果號誌量大於 0，執行 -1 操作；如果號誌等於 0，進程睡眠，等待號誌大於 0。
up：對號誌執行 +1 操作，喚醒睡眠的進程讓其完成 down 操作。


down 和 up 操作需要被設計成原語，不可分割，通常的做法是在執行這些操作的時候屏蔽中斷。
如果號誌的取值只能為 0 或者 1，那麼就成為了互斥(mutex)，0 表示臨界區已經加鎖，1 表示臨界區解鎖。

typedef int semaphore;
semaphore mutex = 1;
void P1(){
    down(&amp;mutex);
    // critical section
    up(&amp;mutex);
}

void P2(){
    down(&amp;mutex);
    // critical section
    up(&amp;mutex);
}

使用號誌實現生產者-消費者問題
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"CSes","item":"https://intervalrain.github.io/cs/"},{"@type":"ListItem","position":2,"name":"[計算機作業系統] 進程管理","item":"https://intervalrain.github.io/cs/os/processmanagement/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[計算機作業系統] 進程管理","name":"[計算機作業系統] 進程管理","description":"進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 通訊 執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.3 最短剩餘時間優先(shortest remaining time next, SRTN) 最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。 2. 交互式系統(time-sharing system) 交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。 2.1 時間片段輪轉(robin round scheduling, RR) 將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。 時間片段輪轉演算法的效率和時間片段的大小很有關係： 因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。 而如果時間片段過長，那麼實時性就不能得到保証。 2.2 優先級調度(priority scheduling) 為每個進程分配一個優先級，按優先級進行調度。 為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。 2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ) 一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。 多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,\u0026hellip;。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。 每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。 3. 實時系統(real time system) 實時系統要求一個請求在一個確定時間內得到響應。 分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。 進程同步 1. 臨界區 對臨界資源進行訪問的那段代碼稱為臨界區。 為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。 // entry section // crtical section; // exit section 2. 同步與互斥(synchronization and mutex) 同步(synchronization)：多個進程因為合作產生的直接制約關係，使得進程有一定的先後執行關係。 互斥(mutual exclusion, mutex)：多個進程在同一時刻只有一個進程能進入臨界區。 3. 號誌(Semaphore) 號誌，或稱信號量，是一個整數變數，可以對其執行 down 和 up 操作，也就是常見的 P 和 V 操作。 down：如果號誌量大於 0，執行 -1 操作；如果號誌等於 0，進程睡眠，等待號誌大於 0。 up：對號誌執行 +1 操作，喚醒睡眠的進程讓其完成 down 操作。 down 和 up 操作需要被設計成原語，不可分割，通常的做法是在執行這些操作的時候屏蔽中斷。\n如果號誌的取值只能為 0 或者 1，那麼就成為了互斥(mutex)，0 表示臨界區已經加鎖，1 表示臨界區解鎖。 typedef int semaphore; semaphore mutex = 1; void P1(){ down(\u0026amp;mutex); // critical section up(\u0026amp;mutex); } void P2(){ down(\u0026amp;mutex); // critical section up(\u0026amp;mutex); } 使用號誌實現生產者-消費者問題 ","keywords":["OS","CS"],"articleBody":"進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 通訊 執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.3 最短剩餘時間優先(shortest remaining time next, SRTN) 最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。 2. 交互式系統(time-sharing system) 交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。 2.1 時間片段輪轉(robin round scheduling, RR) 將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。 時間片段輪轉演算法的效率和時間片段的大小很有關係： 因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。 而如果時間片段過長，那麼實時性就不能得到保証。 2.2 優先級調度(priority scheduling) 為每個進程分配一個優先級，按優先級進行調度。 為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。 2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ) 一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。 多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,…。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。 每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。 3. 實時系統(real time system) 實時系統要求一個請求在一個確定時間內得到響應。 分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。 進程同步 1. 臨界區 對臨界資源進行訪問的那段代碼稱為臨界區。 為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。 // entry section // crtical section; // exit section 2. 同步與互斥(synchronization and mutex) 同步(synchronization)：多個進程因為合作產生的直接制約關係，使得進程有一定的先後執行關係。 互斥(mutual exclusion, mutex)：多個進程在同一時刻只有一個進程能進入臨界區。 3. 號誌(Semaphore) 號誌，或稱信號量，是一個整數變數，可以對其執行 down 和 up 操作，也就是常見的 P 和 V 操作。 down：如果號誌量大於 0，執行 -1 操作；如果號誌等於 0，進程睡眠，等待號誌大於 0。 up：對號誌執行 +1 操作，喚醒睡眠的進程讓其完成 down 操作。 down 和 up 操作需要被設計成原語，不可分割，通常的做法是在執行這些操作的時候屏蔽中斷。\n如果號誌的取值只能為 0 或者 1，那麼就成為了互斥(mutex)，0 表示臨界區已經加鎖，1 表示臨界區解鎖。 typedef int semaphore; semaphore mutex = 1; void P1(){ down(\u0026mutex); // critical section up(\u0026mutex); } void P2(){ down(\u0026mutex); // critical section up(\u0026mutex); } 使用號誌實現生產者-消費者問題 問題描述：使用一個緩衝區來保存物品，只有緩沖區沒有滿，生產者才可以放入物品；只有緩衝區不為空，消費者才可以拿走物品。 因為緩衝區屬於臨界資源，因此需要使用一個互斥 mutex 來控制對緩衝區的互斥訪問。 為了同步生產者和消費者的行為，需要記錄緩衝區中物品的數量。數量可以使用號誌來進行統計，這裡需要使用兩個號誌：empty 記錄空緩衝區的數量，full 記錄滿緩衝區的數量。其中，empty 號誌是在生產者進程中使用，當 empty 不為 0 時，生產者才可以放入物品；full 號誌是在消費者進程中使用，當 full 號誌不為 0 時，消費者才可以取走物品。 注意，不能先對緩衝區進行加鎖，再測試號誌。也就是說，不能先執行 down(mutex) 再執行 down(empty)。如果這麼做了，那麼可能會出現這種情況：生產者對緩衝區加鎖後，執行 down(empty) 操作，發現 empty = 0，此時生產者睡眠。消費者不能進入臨界區，因為生產者對緩衝區加鎖了，消費者就無法執行 up(empty) 操作，empty 永遠都為 0，導致生產者永遠等待下，不會釋放鎖，消費者因此也會永遠等待下去。 #define N 100 typedef int semaphore; semaphore mutex = 1; semaphore empty = N; semaphore full = 0; void producer() { while(TRUE) { int item = produce_item(); down(\u0026empty); up(\u0026mutex); // entry section insert_item(item); // critical section up(\u0026mutex); // exit section up(\u0026full); } } void consumer() { while(TRUE) { down(\u0026full); down(\u0026mutex); // entry section int item = remove_item(); // critical section consume_item(item); // exit section up(\u0026mutex); up(\u0026empty); } } 4. 管程 使用號誌機制實現的生產者消費者問題需要客戶端代碼做很多控制，而管程把控制的代碼獨立出來，不僅不容易出錯，也使得客戶端程式碼調用更容易。 C 語言不支持管程，下面的示範程式碼使用了類 Pascal 語言來描述管程。範例程式碼的管程提供 insert() 和 remove() 方法，客戶端程式碼通過調用這兩個方法來解決生產者-消費者問題。 monitor ProducerConsumer integer i condition c; procedure insert(); begin // ... end procedure remove(); begin // ... end end monitor; 管程有一個重要特性：在一個時刻只能有一個進程使用管程。進程在無法繼續執行的時候不能一直占用管程，否則其它進程永遠不能使用管程。 管程引入了條件變量以及相關的操作：wait() 和 signal() 來實現同步操作。對條件變數執行 wait() 操作會導致調用進程阻塞，把管程讓出來給另一個進程持有。signal() 操作用於喚醒被阻塞的進程。 monitor ProducerConsumer condition full, empty; integer count = 0; conditon c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N - 1 then signal(full); end; end monitor; precedure producer begin while true do begin item = produce_item; ProducerConsumer.insert(item); end; end; Procedure consumer begin while true do begin item = ProducerConsumer.remove; consume_item(item); end; end; 經典同步問題 1. 哲學家進餐問題 問題描述：五個哲學家圍著一張圓桌，每個哲學家面前放著食物。哲學家的生活有兩種交替活動：吃飯和思考。當一個哲學家吃飯時，需要先拿起自己左右邊的兩根筷子，並且一次只能拿起一根筷子。 若所有哲學家同時拿起左手邊的筷子，那麼所有哲學家都在等待其它哲學家吃完並放下手中的筷子，導致 dead lock。 為了防止 dead lock 的產生，可以設置兩個條件： 必須同時拿起左右兩根筷子； 只有在兩個鄰居都沒有進餐的情況下才允許進餐。 #define N 5 #define LEFT (i + N - 1) % N #define RIGHT (i + 1) % N #define THINKING 0 #define HUNGRY 1 #define EATING 2 typedef int semaphore; int state[N]; // philosopher's state semaphore mutex = 1; // mutex for critical section semaphore s[N]; // semaphore of philosopher void philosopher(int i){ while(TRUE){ think(i); take_two(i); eat(i); put_two(i); } } void take_two(int i){ down(\u0026mutex); state[i] = HUNGRY; check(i); up(\u0026mutex); down(\u0026s[i]); // eat only if receive notification, or wait } void put_two(int i){ down(\u0026mutex); state[i] = THINKING; check(LEFT); // notify left and right check(RIGHT); up(\u0026mutex); } void eat(int i){ down(\u0026mutex); state[i] = EATING; up(\u0026mutex); } void check(int i ){ if (state[i] == HUNGRY \u0026\u0026 state[LEFT] != EATING \u0026\u0026 state[EIGHT] != EATING){ state[i] = EATING; up(\u0026s[i]); } } 2. 讀寫問題 問題描述：允許多個進程同時對數據進行讀操作，但是不允許讀和寫以及寫和寫操作同時發生。 一個整數變數 count 記錄在對數據進行讀操作的進程數量，一個互斥量 count_mutex 用於對 count 加鎖，一個互斥量 data_mutex 用於對讀寫的數據加鎖。 typedef int semaphore semaphore count_mutex = 1; semaphore data_mutex = 1; int count = 0; void reader(){ while(TRUE) { down(\u0026count_mutex); count++; if(count == 1) down(\u0026data_mutex); up(\u0026count_mutex); read(); down(\u0026count_mutex); count--; if(count == 0) up(\u0026data_mutex); up(\u0026count_mutex); } } void writer(){ while(TRUE) { down(\u0026data_mutex); write(); up(\u0026data_mutex); } } 以上範例可能會造成作家飢餓(starve)。只有當讀者早於作家進入佇列中，它才會進行等待。 int readcount, writecount; // initial value = 0 semaphore, rmutex, wmutex, readLock, resource; // initial value = 1 void reader() { // Entry section down(\u0026readLock); // reader is trying to enter down(\u0026mutex); // lock to increase readcount readcount++; if (readcount == 1) down(\u0026resource); // if you are the first reader then lock the source up(\u0026rmutex); // release for other readers up(\u0026readLock); // done with trying to access the resource // critical section // // Exit section down(\u0026mutex); // reserve exit section - avoid race condition with readers readcount--; // indicate you're leaving if (readcount == 0) // checks if you are last reader leaving up(\u0026resource); // if last, you must release the locked resource up(\u0026rmutex); // release exit section for other readers } void writer() { // Entry section down(\u0026wmutex); // reserve entry section for writers - avoids race conditions writecount++; // report yourself as a writing entering if (writecount == 1) // checks if you're the first writer down(\u0026readLock); // if you're first, then you must lock the readers out. Prevent them from trying to enter CS up(\u0026wmutex); // release entry section // critical section down(\u0026resource) // reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource // up(\u0026resource) // release file // Exit section down(\u0026wmutex); // release exit section writecount--; // indicate you're leaving if (writecount == 0) // check if you're the last writer up(\u0026readLock); // if you're last writer, you must unlock the readers. Allows them to try enter CS for reading up(\u0026wmutex); // release exit section } 我們可以觀察到每個讀者都被強迫上鎖。另一方面，作家無須各自上鎖。一旦第一個作家把 Readlcok 鎖上，則會等到佇列中沒有作家時才會被釋放。 從以上兩個範例我們可以發現，讀者與作家有一方必須飢餓(starve)。以下第三個範例的新增條件，會限制沒有執行緒被允許飢餓(starve)，也就是說，以下操作將會在一段時間之後停止。 int readCount // init to 0; number of readers currently accessing resource // all semaphore initialized to 1 Semaphore resourceAccess; // controls access (read/write) to the resource Semaphore readCountAccess; // for syncing changes to shared variable readCount Semaphore serviceQueue; // FAIRNESS: preserves ordering of requests (signaling must be FIFO) void writer(){ down(\u0026servcieQueue); // wait in line to be services // down(\u0026resourceAccess); // request exclusive access to resource // up(\u0026serviceQueue); // let next in line be serviced // writeResource(); // writing is performed // // up(\u0026resourceAccess); // release resource access for next reader/writer // } void reader(){ down(\u0026serviceQueue); // wait in line to be serviced down(\u0026readCountAccess); // request exclusive access to readCount // if (readCount == 0) // if there are no readers already reading down(\u0026resourceAccess); // request resource access for reader (writer blocked) readCount++; // update count of active readers // up(\u0026serviceQueue); // let next in line be serviced up(\u0026readCountAccess); // release access to readCount // readResource() // reading is performed // down(\u0026readCountAccess); // request exclusive access to readCount // readCount--; // update count of active readers if (readCount == 0) // if there are no readers left up(\u0026resourceAccess); // release resource access for all // up(\u0026readCountAccess) // release access to readCount } 進程通訊 進程同步與進程通訊很容易混淆，它們的區別在： 進程同步(process synchronization)：控制多個進程按一定順序執行。 進程通訊(process communication)：進程間傳遞訊息 進程通訊是一種手段，進程同步是一種目的。也可以說，為了能夠達成進程同步的目的，需要讓進程進行通訊，傳遞一些進程同步所需要的訊息。 1. 管道 管道是通用調用 pipe 函數創建的，fd[0] 用於讀，fd[1] 用於寫。 #include int pipe(int fd[2]); 它具有以下的限制：\n只支持半雙工通訊(單向交替傳輸) 只能在父子進程或者兄弟進程中使用。 2. FIFO 也稱為管道，去除了管道只能在父子進程中的使用限制。 #include int mkfifo(const char *path, mode_t mode); int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用於客戶-伺服器應用程式中，FIFO 用於匯聚點，在客戶進程與伺服器進程之間傳遞數據。 3. 訊息佇列 相較於 FIFO，訊息佇列有以下優點： 消息佇列可以獨立於讀寫進程存在，從而避免了 FIFO 中同步管道的打開和關閉時可能產生的困難。 避免了 FIFO 的同步阻塞問題，不需要進程自己提供同步方法。 讀進程可以根據訊息類型有選擇性地接收訊息，而不像 FIFO 那樣只能全盤地接受。 4. 訊號量 一個計數器，用於為多個進程提供對共享數據的物件作訪問。 5. 記憶體共享 允許多個進程共享一個給定的記憶體空間。因為數據不需要在進程之間複制，所以這是最快的一種 IPC(Inter-Process Communication)。 需要使用訊號量來同步對共享記憶體的訪問。 多個進程可以將同一個文件映射到它們的地址空間從而實現共享記憶體。另外 XSI 共享記憶體不是使用文件，而是使用記憶體的匿名段。 6. word 套接 與其它通訊機制不同的是，它可以用於不同機器間的進程通訊。 ","wordCount":"1186","inLanguage":"zh-tw","datePublished":"2022-07-02T04:00:55+08:00","dateModified":"2022-07-02T04:00:55+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/cs/os/processmanagement/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/cs/>CSes</a></div><h1 class="post-title entry-hint-parent">[計算機作業系統] 進程管理</h1><div class=post-meta><span title='2022-07-02 04:00:55 +0800 +0800'>July 2, 2022</span>&nbsp;·&nbsp;6 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//CS/OS/processManagement.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e9%80%b2%e7%a8%8b%e7%ae%a1%e7%90%86 aria-label=進程管理>進程管理</a><ul><li><a href=#%e9%80%b2%e7%a8%8b%e8%88%87%e5%9f%b7%e8%a1%8c%e7%b7%92 aria-label=進程與執行緒>進程與執行緒</a><ul><li><a href=#1-%e9%80%b2%e7%a8%8bprocess aria-label="1. 進程(process)">1. 進程(process)</a></li><li><a href=#2-%e5%9f%b7%e8%a1%8c%e7%b7%92thread aria-label="2. 執行緒(thread)">2. 執行緒(thread)</a></li><li><a href=#3-%e5%8d%80%e5%88%a5 aria-label="3. 區別">3. 區別</a></li></ul></li><li><a href=#%e9%80%b2%e7%a8%8b%e7%8b%80%e6%85%8b%e7%9a%84%e5%88%87%e6%8f%9b aria-label=進程狀態的切換>進程狀態的切換</a></li><li><a href=#%e9%80%b2%e7%a8%8b%e8%aa%bf%e5%ba%a6%e6%bc%94%e7%ae%97%e6%b3%95 aria-label=進程調度演算法>進程調度演算法</a><ul><li><a href=#1-%e6%89%b9%e6%ac%a1%e8%99%95%e7%90%86%e7%b3%bb%e7%b5%b1batch-system aria-label="1. 批次處理系統(batch system)">1. 批次處理系統(batch system)</a><ul><li><a href=#11-%e5%85%88%e4%be%86%e5%85%88%e6%9c%8d%e5%8b%99first-come-first-served-fcfs aria-label="1.1 先來先服務(first-come first-served, FCFS)">1.1 先來先服務(first-come first-served, FCFS)</a></li><li><a href=#12-%e7%9f%ad%e4%bd%9c%e6%a5%ad%e5%84%aa%e5%85%88shortest-job-first-sjf aria-label="1.2 短作業優先(shortest job first, SJF)">1.2 短作業優先(shortest job first, SJF)</a></li><li><a href=#13-%e6%9c%80%e7%9f%ad%e5%89%a9%e9%a4%98%e6%99%82%e9%96%93%e5%84%aa%e5%85%88shortest-remaining-time-next-srtn aria-label="1.3 最短剩餘時間優先(shortest remaining time next, SRTN)">1.3 最短剩餘時間優先(shortest remaining time next, SRTN)</a></li></ul></li><li><a href=#2-%e4%ba%a4%e4%ba%92%e5%bc%8f%e7%b3%bb%e7%b5%b1time-sharing-system aria-label="2. 交互式系統(time-sharing system)">2. 交互式系統(time-sharing system)</a><ul><li><a href=#21-%e6%99%82%e9%96%93%e7%89%87%e6%ae%b5%e8%bc%aa%e8%bd%89robin-round-scheduling-rr aria-label="2.1 時間片段輪轉(robin round scheduling, RR)">2.1 時間片段輪轉(robin round scheduling, RR)</a></li><li><a href=#22-%e5%84%aa%e5%85%88%e7%b4%9a%e8%aa%bf%e5%ba%a6priority-scheduling aria-label="2.2 優先級調度(priority scheduling)">2.2 優先級調度(priority scheduling)</a></li><li><a href=#23-%e5%a4%9a%e7%b4%9a%e5%8f%8d%e9%a5%8b%e4%bd%87%e5%88%97multilevel-feedback-queue-scheduling-mlfq aria-label="2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ)">2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ)</a></li></ul></li><li><a href=#3-%e5%af%a6%e6%99%82%e7%b3%bb%e7%b5%b1real-time-system aria-label="3. 實時系統(real time system)">3. 實時系統(real time system)</a></li></ul></li><li><a href=#%e9%80%b2%e7%a8%8b%e5%90%8c%e6%ad%a5 aria-label=進程同步>進程同步</a><ul><li><a href=#1-%e8%87%a8%e7%95%8c%e5%8d%80 aria-label="1. 臨界區">1. 臨界區</a></li><li><a href=#2-%e5%90%8c%e6%ad%a5%e8%88%87%e4%ba%92%e6%96%a5synchronization-and-mutex aria-label="2. 同步與互斥(synchronization and mutex)">2. 同步與互斥(synchronization and mutex)</a></li><li><a href=#3-%e8%99%9f%e8%aa%8csemaphore aria-label="3. 號誌(Semaphore)">3. 號誌(Semaphore)</a></li><li><a href=#4-%e7%ae%a1%e7%a8%8b aria-label="4. 管程">4. 管程</a></li></ul></li><li><a href=#%e7%b6%93%e5%85%b8%e5%90%8c%e6%ad%a5%e5%95%8f%e9%a1%8c aria-label=經典同步問題>經典同步問題</a><ul><li><a href=#1-%e5%93%b2%e5%ad%b8%e5%ae%b6%e9%80%b2%e9%a4%90%e5%95%8f%e9%a1%8c aria-label="1. 哲學家進餐問題">1. 哲學家進餐問題</a></li><li><a href=#2-%e8%ae%80%e5%af%ab%e5%95%8f%e9%a1%8c aria-label="2. 讀寫問題">2. 讀寫問題</a></li></ul></li><li><a href=#%e9%80%b2%e7%a8%8b%e9%80%9a%e8%a8%8a aria-label=進程通訊>進程通訊</a><ul><li><a href=#1-%e7%ae%a1%e9%81%93 aria-label="1. 管道">1. 管道</a></li><li><a href=#2-fifo aria-label="2. FIFO">2. FIFO</a></li><li><a href=#3-%e8%a8%8a%e6%81%af%e4%bd%87%e5%88%97 aria-label="3. 訊息佇列">3. 訊息佇列</a></li><li><a href=#4-%e8%a8%8a%e8%99%9f%e9%87%8f aria-label="4. 訊號量">4. 訊號量</a></li><li><a href=#5-%e8%a8%98%e6%86%b6%e9%ab%94%e5%85%b1%e4%ba%ab aria-label="5. 記憶體共享">5. 記憶體共享</a></li><li><a href=#6-word-%e5%a5%97%e6%8e%a5 aria-label="6. word 套接">6. word 套接</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=進程管理>進程管理<a hidden class=anchor aria-hidden=true href=#進程管理>#</a></h1><h2 id=進程與執行緒>進程與執行緒<a hidden class=anchor aria-hidden=true href=#進程與執行緒>#</a></h2><h3 id=1-進程process>1. 進程(process)<a hidden class=anchor aria-hidden=true href=#1-進程process>#</a></h3><ul><li>進程是資源分配的基本單位。</li><li>進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。
<img alt=PCB loading=lazy src="https://www.usna.edu/Users/cs/bilzor/ic411/calendar.php?key=c8bc3778e1e290e4a99e60360fa8c03a340b21ad&type=class&event=6"></li></ul><h3 id=2-執行緒thread>2. 執行緒(thread)<a hidden class=anchor aria-hidden=true href=#2-執行緒thread>#</a></h3><ul><li>執行緒又稱線程，是獨立調度的基本單位。</li><li>一個進程可以有多個執行緒，它們共享進程資源。</li><li>以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。
<img alt=thread loading=lazy src=https://4.bp.blogspot.com/-QyEW1jszBJM/UnUsSC-mVOI/AAAAAAAAABY/Z94NgDcWTb4/s640/process-thread.png></li></ul><h3 id=3-區別>3. 區別<a hidden class=anchor aria-hidden=true href=#3-區別>#</a></h3><ol><li>擁有資源<ul><li>進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。</li></ul></li><li>調度<ul><li>執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。</li></ul></li><li>系統開銷<ul><li>由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。</li><li>同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。</li></ul></li><li>通訊<ul><li>執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。</li></ul></li></ol><h2 id=進程狀態的切換>進程狀態的切換<a hidden class=anchor aria-hidden=true href=#進程狀態的切換>#</a></h2><p><img alt="process state" loading=lazy src=https://jingtao.fun/images/%E8%AF%BB%E4%B9%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20201102105129598.png></p><ul><li>就緒就態(ready)：等待被調度</li><li>執行狀態(running)</li><li>阻塞狀態(waiting)：等待資源<ul><li>只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。</li><li>阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。</li></ul></li></ul><h2 id=進程調度演算法>進程調度演算法<a hidden class=anchor aria-hidden=true href=#進程調度演算法>#</a></h2><ul><li>不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。</li></ul><h3 id=1-批次處理系統batch-system>1. 批次處理系統(batch system)<a hidden class=anchor aria-hidden=true href=#1-批次處理系統batch-system>#</a></h3><ul><li>批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。</li></ul><h4 id=11-先來先服務first-come-first-served-fcfs>1.1 先來先服務(first-come first-served, FCFS)<a hidden class=anchor aria-hidden=true href=#11-先來先服務first-come-first-served-fcfs>#</a></h4><ul><li>非搶占式的調度，按照請求的順序進行調度。</li><li>有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長</li></ul><h4 id=12-短作業優先shortest-job-first-sjf>1.2 短作業優先(shortest job first, SJF)<a hidden class=anchor aria-hidden=true href=#12-短作業優先shortest-job-first-sjf>#</a></h4><ul><li>非搶占式的調度算法，按估計運行時間最短的順序進行調度。</li><li>長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。</li></ul><h4 id=13-最短剩餘時間優先shortest-remaining-time-next-srtn>1.3 最短剩餘時間優先(shortest remaining time next, SRTN)<a hidden class=anchor aria-hidden=true href=#13-最短剩餘時間優先shortest-remaining-time-next-srtn>#</a></h4><ul><li>最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。</li></ul><h3 id=2-交互式系統time-sharing-system>2. 交互式系統(time-sharing system)<a hidden class=anchor aria-hidden=true href=#2-交互式系統time-sharing-system>#</a></h3><ul><li>交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。</li></ul><h4 id=21-時間片段輪轉robin-round-scheduling-rr>2.1 時間片段輪轉(robin round scheduling, RR)<a hidden class=anchor aria-hidden=true href=#21-時間片段輪轉robin-round-scheduling-rr>#</a></h4><ul><li>將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。</li><li>時間片段輪轉演算法的效率和時間片段的大小很有關係：<ul><li>因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。</li><li>而如果時間片段過長，那麼實時性就不能得到保証。</li></ul></li></ul><h4 id=22-優先級調度priority-scheduling>2.2 優先級調度(priority scheduling)<a hidden class=anchor aria-hidden=true href=#22-優先級調度priority-scheduling>#</a></h4><ul><li>為每個進程分配一個優先級，按優先級進行調度。</li><li>為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。</li></ul><h4 id=23-多級反饋佇列multilevel-feedback-queue-scheduling-mlfq>2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ)<a hidden class=anchor aria-hidden=true href=#23-多級反饋佇列multilevel-feedback-queue-scheduling-mlfq>#</a></h4><ul><li>一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。</li><li>多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,&mldr;。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。</li><li>每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。
<img alt=MLFQ loading=lazy src=https://i.pinimg.com/736x/9e/56/96/9e5696a52f10453be9717470b28a44c7--round-robin-robins.jpg></li></ul><h3 id=3-實時系統real-time-system>3. 實時系統(real time system)<a hidden class=anchor aria-hidden=true href=#3-實時系統real-time-system>#</a></h3><ul><li>實時系統要求一個請求在一個確定時間內得到響應。</li><li>分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。</li></ul><h2 id=進程同步>進程同步<a hidden class=anchor aria-hidden=true href=#進程同步>#</a></h2><h3 id=1-臨界區>1. 臨界區<a hidden class=anchor aria-hidden=true href=#1-臨界區>#</a></h3><ul><li>對臨界資源進行訪問的那段代碼稱為臨界區。</li><li>為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// entry section
</span></span></span><span style=display:flex><span><span style=color:#75715e>// crtical section;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// exit section
</span></span></span></code></pre></div><h3 id=2-同步與互斥synchronization-and-mutex>2. 同步與互斥(synchronization and mutex)<a hidden class=anchor aria-hidden=true href=#2-同步與互斥synchronization-and-mutex>#</a></h3><ul><li>同步(synchronization)：多個進程因為合作產生的直接制約關係，使得進程有一定的先後執行關係。</li><li>互斥(mutual exclusion, mutex)：多個進程在同一時刻只有一個進程能進入臨界區。</li></ul><h3 id=3-號誌semaphore>3. 號誌(Semaphore)<a hidden class=anchor aria-hidden=true href=#3-號誌semaphore>#</a></h3><ul><li>號誌，或稱信號量，是一個整數變數，可以對其執行 down 和 up 操作，也就是常見的 P 和 V 操作。<ul><li><strong>down</strong>：如果號誌量大於 0，執行 -1 操作；如果號誌等於 0，進程睡眠，等待號誌大於 0。</li><li><strong>up</strong>：對號誌執行 +1 操作，喚醒睡眠的進程讓其完成 down 操作。</li></ul></li><li>down 和 up 操作需要被設計成原語，不可分割，通常的做法是在執行這些操作的時候屏蔽中斷。<br>如果號誌的取值只能為 0 或者 1，那麼就成為了互斥(mutex)，0 表示臨界區已經加鎖，1 表示臨界區解鎖。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> semaphore;
</span></span><span style=display:flex><span>semaphore mutex <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>P1</span>(){
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// critical section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>P2</span>(){
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// critical section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p><strong>使用號誌實現生產者-消費者問題</strong>
<img alt=producer-consumer-problem loading=lazy src="https://th.bing.com/th/id/R.dbbe36e7d63143d6defdab98ece8fff8?rik=J8NwPrcsGHP7jw&pid=ImgRaw&r=0"></p><ul><li>問題描述：使用一個緩衝區來保存物品，只有緩沖區沒有滿，生產者才可以放入物品；只有緩衝區不為空，消費者才可以拿走物品。</li><li>因為緩衝區屬於臨界資源，因此需要使用一個互斥 mutex 來控制對緩衝區的互斥訪問。</li><li>為了同步生產者和消費者的行為，需要記錄緩衝區中物品的數量。數量可以使用號誌來進行統計，這裡需要使用兩個號誌：empty 記錄空緩衝區的數量，full 記錄滿緩衝區的數量。其中，empty 號誌是在生產者進程中使用，當 empty 不為 0 時，生產者才可以放入物品；full 號誌是在消費者進程中使用，當 full 號誌不為 0 時，消費者才可以取走物品。</li><li>注意，不能先對緩衝區進行加鎖，再測試號誌。也就是說，不能先執行 down(mutex) 再執行 down(empty)。如果這麼做了，那麼可能會出現這種情況：生產者對緩衝區加鎖後，執行 down(empty) 操作，發現 empty = 0，此時生產者睡眠。消費者不能進入臨界區，因為生產者對緩衝區加鎖了，消費者就無法執行 up(empty) 操作，empty 永遠都為 0，導致生產者永遠等待下，不會釋放鎖，消費者因此也會永遠等待下去。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#define N 100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> semaphore;
</span></span><span style=display:flex><span>semaphore mutex <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>semaphore empty <span style=color:#f92672>=</span> N;
</span></span><span style=display:flex><span>semaphore full <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>producer</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(TRUE) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> item <span style=color:#f92672>=</span> produce_item();
</span></span><span style=display:flex><span>        down(<span style=color:#f92672>&amp;</span>empty);
</span></span><span style=display:flex><span>        up(<span style=color:#f92672>&amp;</span>mutex);                 <span style=color:#75715e>// entry section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        insert_item(item);          <span style=color:#75715e>// critical section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        up(<span style=color:#f92672>&amp;</span>mutex);                 <span style=color:#75715e>// exit section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        up(<span style=color:#f92672>&amp;</span>full);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>consumer</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(TRUE) {
</span></span><span style=display:flex><span>        down(<span style=color:#f92672>&amp;</span>full);
</span></span><span style=display:flex><span>        down(<span style=color:#f92672>&amp;</span>mutex);               <span style=color:#75715e>// entry section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> item <span style=color:#f92672>=</span> remove_item();   <span style=color:#75715e>// critical section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        consume_item(item);         <span style=color:#75715e>// exit section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        up(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>        up(<span style=color:#f92672>&amp;</span>empty);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-管程>4. 管程<a hidden class=anchor aria-hidden=true href=#4-管程>#</a></h3><ul><li>使用號誌機制實現的生產者消費者問題需要客戶端代碼做很多控制，而管程把控制的代碼獨立出來，不僅不容易出錯，也使得客戶端程式碼調用更容易。</li><li>C 語言不支持管程，下面的示範程式碼使用了類 Pascal 語言來描述管程。範例程式碼的管程提供 <code>insert()</code> 和 <code>remove()</code> 方法，客戶端程式碼通過調用這兩個方法來解決生產者-消費者問題。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span>monitor ProducerConsumer
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>integer</span> i
</span></span><span style=display:flex><span>    condition c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    procedure insert();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    procedure remove();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> monitor;
</span></span></code></pre></div><ul><li>管程有一個重要特性：在一個時刻只能有一個進程使用管程。進程在無法繼續執行的時候不能一直占用管程，否則其它進程永遠不能使用管程。</li><li>管程引入了<strong>條件變量</strong>以及相關的操作：<code>wait()</code> 和 <code>signal()</code> 來實現同步操作。對條件變數執行 <code>wait()</code> 操作會導致調用進程阻塞，把管程讓出來給另一個進程持有。<code>signal()</code> 操作用於喚醒被阻塞的進程。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span>monitor ProducerConsumer
</span></span><span style=display:flex><span>    condition full, empty;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>integer</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    conditon c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    procedure insert(item: <span style=color:#66d9ef>integer</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> count <span style=color:#f92672>=</span> N then <span style=color:#66d9ef>wait</span>(full);
</span></span><span style=display:flex><span>        insert_item(item);
</span></span><span style=display:flex><span>        count <span style=color:#f92672>:=</span> count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> then signal(empty);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> remove: <span style=color:#66d9ef>integer</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> then <span style=color:#66d9ef>wait</span>(empty);
</span></span><span style=display:flex><span>        remove <span style=color:#f92672>=</span> remove_item;
</span></span><span style=display:flex><span>        count <span style=color:#f92672>:=</span> count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> count <span style=color:#f92672>=</span> N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> then signal(full);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> monitor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>precedure producer
</span></span><span style=display:flex><span><span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> true <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        item <span style=color:#f92672>=</span> produce_item;
</span></span><span style=display:flex><span>        ProducerConsumer.insert(item);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Procedure consumer
</span></span><span style=display:flex><span><span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> true <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        item <span style=color:#f92672>=</span> ProducerConsumer.remove;
</span></span><span style=display:flex><span>        consume_item(item);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>;
</span></span></code></pre></div><hr><h2 id=經典同步問題>經典同步問題<a hidden class=anchor aria-hidden=true href=#經典同步問題>#</a></h2><h3 id=1-哲學家進餐問題>1. 哲學家進餐問題<a hidden class=anchor aria-hidden=true href=#1-哲學家進餐問題>#</a></h3><p><img alt=philosopher loading=lazy src=https://camo.githubusercontent.com/7f8eb6362323b56a5dd8ec061d7ea0c5b0d07a842132598bbed860a8bb941317/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61393037376630362d373538342d346632622d386332302d3361386534363932383832302e6a7067></p><ul><li>問題描述：五個哲學家圍著一張圓桌，每個哲學家面前放著食物。哲學家的生活有兩種交替活動：吃飯和思考。當一個哲學家吃飯時，需要先拿起自己左右邊的兩根筷子，並且一次只能拿起一根筷子。</li><li>若所有哲學家同時拿起左手邊的筷子，那麼所有哲學家都在等待其它哲學家吃完並放下手中的筷子，導致 dead lock。</li><li>為了防止 dead lock 的產生，可以設置兩個條件：<ul><li>必須同時拿起左右兩根筷子；</li><li>只有在兩個鄰居都沒有進餐的情況下才允許進餐。</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#define N 5
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define LEFT (i + N - 1) % N
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define RIGHT (i + 1) % N
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define THINKING 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define HUNGRY   1
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EATING   2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> semaphore;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> state[N];           <span style=color:#75715e>// philosopher&#39;s state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>semaphore mutex <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;    <span style=color:#75715e>// mutex for critical section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>semaphore s[N];         <span style=color:#75715e>// semaphore of philosopher
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>philosopher</span>(<span style=color:#66d9ef>int</span> i){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(TRUE){
</span></span><span style=display:flex><span>        think(i);
</span></span><span style=display:flex><span>        take_two(i);
</span></span><span style=display:flex><span>        eat(i);
</span></span><span style=display:flex><span>        put_two(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>take_two</span>(<span style=color:#66d9ef>int</span> i){
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    state[i] <span style=color:#f92672>=</span> HUNGRY;
</span></span><span style=display:flex><span>    check(i);
</span></span><span style=display:flex><span>    up(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>s[i]);        <span style=color:#75715e>// eat only if receive notification, or wait
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put_two</span>(<span style=color:#66d9ef>int</span> i){
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    state[i] <span style=color:#f92672>=</span> THINKING;
</span></span><span style=display:flex><span>    check(LEFT);        <span style=color:#75715e>// notify left and right
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    check(RIGHT);
</span></span><span style=display:flex><span>    up(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>eat</span>(<span style=color:#66d9ef>int</span> i){
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>    state[i] <span style=color:#f92672>=</span> EATING;
</span></span><span style=display:flex><span>    up(<span style=color:#f92672>&amp;</span>mutex);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>check</span>(<span style=color:#66d9ef>int</span> i ){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (state[i] <span style=color:#f92672>==</span> HUNGRY <span style=color:#f92672>&amp;&amp;</span> state[LEFT] <span style=color:#f92672>!=</span> EATING <span style=color:#f92672>&amp;&amp;</span> state[EIGHT] <span style=color:#f92672>!=</span> EATING){
</span></span><span style=display:flex><span>        state[i] <span style=color:#f92672>=</span> EATING;
</span></span><span style=display:flex><span>        up(<span style=color:#f92672>&amp;</span>s[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-讀寫問題>2. 讀寫問題<a hidden class=anchor aria-hidden=true href=#2-讀寫問題>#</a></h3><ul><li>問題描述：允許多個進程同時對數據進行讀操作，但是不允許讀和寫以及寫和寫操作同時發生。</li><li>一個整數變數 count 記錄在對數據進行讀操作的進程數量，一個互斥量 count_mutex 用於對 count 加鎖，一個互斥量 data_mutex 用於對讀寫的數據加鎖。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> semaphore
</span></span><span style=display:flex><span>semaphore count_mutex <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>semaphore data_mutex <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reader</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(TRUE) {
</span></span><span style=display:flex><span>        down(<span style=color:#f92672>&amp;</span>count_mutex);
</span></span><span style=display:flex><span>        count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(count <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) down(<span style=color:#f92672>&amp;</span>data_mutex);
</span></span><span style=display:flex><span>        up(<span style=color:#f92672>&amp;</span>count_mutex);
</span></span><span style=display:flex><span>        read();
</span></span><span style=display:flex><span>        down(<span style=color:#f92672>&amp;</span>count_mutex);
</span></span><span style=display:flex><span>        count<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) up(<span style=color:#f92672>&amp;</span>data_mutex);
</span></span><span style=display:flex><span>        up(<span style=color:#f92672>&amp;</span>count_mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writer</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(TRUE) {
</span></span><span style=display:flex><span>        down(<span style=color:#f92672>&amp;</span>data_mutex);
</span></span><span style=display:flex><span>        write();
</span></span><span style=display:flex><span>        up(<span style=color:#f92672>&amp;</span>data_mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>以上範例可能會造成作家飢餓(starve)。只有當讀者早於作家進入佇列中，它才會進行等待。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> readcount, writecount;                      <span style=color:#75715e>// initial value = 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>semaphore, rmutex, wmutex, readLock, resource;  <span style=color:#75715e>// initial value = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reader</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Entry section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    down(<span style=color:#f92672>&amp;</span>readLock);                <span style=color:#75715e>// reader is trying to enter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    down(<span style=color:#f92672>&amp;</span>mutex);                   <span style=color:#75715e>// lock to increase readcount
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    readcount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (readcount <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        down(<span style=color:#f92672>&amp;</span>resource);            <span style=color:#75715e>// if you are the first reader then lock the source
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>rmutex);                    <span style=color:#75715e>// release for other readers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>readLock);                  <span style=color:#75715e>// done with trying to access the resource
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// critical section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;reading is performed&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Exit section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    down(<span style=color:#f92672>&amp;</span>mutex);                   <span style=color:#75715e>// reserve exit section - avoid race condition with readers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    readcount<span style=color:#f92672>--</span>;                    <span style=color:#75715e>// indicate you&#39;re leaving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (readcount <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)             <span style=color:#75715e>// checks if you are last reader leaving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        up(<span style=color:#f92672>&amp;</span>resource);              <span style=color:#75715e>// if last, you must release the locked resource
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>rmutex);                    <span style=color:#75715e>// release exit section for other readers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writer</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Entry section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    down(<span style=color:#f92672>&amp;</span>wmutex);                  <span style=color:#75715e>// reserve entry section for writers - avoids race conditions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    writecount<span style=color:#f92672>++</span>;                   <span style=color:#75715e>// report yourself as a writing entering
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (writecount <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)            <span style=color:#75715e>// checks if you&#39;re the first writer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        down(<span style=color:#f92672>&amp;</span>readLock);            <span style=color:#75715e>// if you&#39;re first, then you must lock the readers out. Prevent them from trying to enter CS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>wmutex);                    <span style=color:#75715e>// release entry section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// critical section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    down(<span style=color:#f92672>&amp;</span>resource)                 <span style=color:#75715e>// reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;writing is performed&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>resource)                   <span style=color:#75715e>// release file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Exit section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    down(<span style=color:#f92672>&amp;</span>wmutex);                  <span style=color:#75715e>// release exit section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    writecount<span style=color:#f92672>--</span>;                   <span style=color:#75715e>// indicate you&#39;re leaving
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (writecount <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)            <span style=color:#75715e>// check if you&#39;re the last writer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        up(<span style=color:#f92672>&amp;</span>readLock);              <span style=color:#75715e>// if you&#39;re last writer, you must unlock the readers. Allows them to try enter CS for reading
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>wmutex);                    <span style=color:#75715e>// release exit section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>我們可以觀察到每個讀者都被強迫上鎖。另一方面，作家無須各自上鎖。一旦第一個作家把 Readlcok 鎖上，則會等到佇列中沒有作家時才會被釋放。</li><li>從以上兩個範例我們可以發現，讀者與作家有一方必須飢餓(starve)。以下第三個範例的新增條件，會限制沒有執行緒被允許飢餓(starve)，也就是說，以下操作將會在一段時間之後停止。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> readCount                       <span style=color:#75715e>// init to 0; number of readers currently accessing resource
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// all semaphore initialized to 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Semaphore resourceAccess;           <span style=color:#75715e>// controls access (read/write) to the resource
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Semaphore readCountAccess;          <span style=color:#75715e>// for syncing changes to shared variable readCount
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Semaphore serviceQueue;             <span style=color:#75715e>// FAIRNESS: preserves ordering of requests (signaling must be FIFO)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writer</span>(){
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>servcieQueue);            <span style=color:#75715e>// wait in line to be services
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;enter&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    down(<span style=color:#f92672>&amp;</span>resourceAccess);          <span style=color:#75715e>// request exclusive access to resource
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;/enter&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>serviceQueue);              <span style=color:#75715e>// let next in line be serviced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &lt;write&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    writeResource();                <span style=color:#75715e>// writing is performed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;/write&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &lt;exit&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>resourceAccess);            <span style=color:#75715e>// release resource access for next reader/writer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;/exit&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reader</span>(){
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>serviceQueue);            <span style=color:#75715e>// wait in line to be serviced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    down(<span style=color:#f92672>&amp;</span>readCountAccess);         <span style=color:#75715e>// request exclusive access to readCount
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;enter&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (readCount <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)             <span style=color:#75715e>// if there are no readers already reading
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        down(<span style=color:#f92672>&amp;</span>resourceAccess);      <span style=color:#75715e>// request resource access for reader (writer blocked)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    readCount<span style=color:#f92672>++</span>;                    <span style=color:#75715e>// update count of active readers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;/enter&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>serviceQueue);              <span style=color:#75715e>// let next in line be serviced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>readCountAccess);           <span style=color:#75715e>// release access to readCount
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &lt;read&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    readResource()                  <span style=color:#75715e>// reading is performed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;/read&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    down(<span style=color:#f92672>&amp;</span>readCountAccess);         <span style=color:#75715e>// request exclusive access to readCount
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;exit&gt; 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    readCount<span style=color:#f92672>--</span>;                    <span style=color:#75715e>// update count of active readers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (readCount <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)             <span style=color:#75715e>// if there are no readers left
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        up(<span style=color:#f92672>&amp;</span>resourceAccess);        <span style=color:#75715e>// release resource access for all
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &lt;/exit&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    up(<span style=color:#f92672>&amp;</span>readCountAccess)            <span style=color:#75715e>// release access to readCount
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=進程通訊>進程通訊<a hidden class=anchor aria-hidden=true href=#進程通訊>#</a></h2><ul><li>進程同步與進程通訊很容易混淆，它們的區別在：<ul><li>進程同步(process synchronization)：控制多個進程按一定順序執行。</li><li>進程通訊(process communication)：進程間傳遞訊息</li></ul></li><li>進程通訊是一種手段，進程同步是一種目的。也可以說，為了能夠達成進程同步的目的，需要讓進程進行通訊，傳遞一些進程同步所需要的訊息。</li></ul><h3 id=1-管道>1. 管道<a hidden class=anchor aria-hidden=true href=#1-管道>#</a></h3><ul><li>管道是通用調用 pipe 函數創建的，<code>fd[0]</code> 用於讀，<code>fd[1]</code> 用於寫。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>pipe</span>(<span style=color:#66d9ef>int</span> fd[<span style=color:#ae81ff>2</span>]);
</span></span></code></pre></div><p>它具有以下的限制：</p><ul><li>只支持半雙工通訊(單向交替傳輸)</li><li>只能在父子進程或者兄弟進程中使用。
<img alt=pipe loading=lazy src=https://notes.shichao.io/apue/figure_15.3.png></li></ul><h3 id=2-fifo>2. FIFO<a hidden class=anchor aria-hidden=true href=#2-fifo>#</a></h3><ul><li>也稱為管道，去除了管道只能在父子進程中的使用限制。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mkfifo</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path, mode_t mode);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mkfifoat</span>(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path, mode_t mode);
</span></span></code></pre></div><ul><li>FIFO 常用於客戶-伺服器應用程式中，FIFO 用於匯聚點，在客戶進程與伺服器進程之間傳遞數據。
<img alt=FIFO loading=lazy src=https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png></li></ul><h3 id=3-訊息佇列>3. 訊息佇列<a hidden class=anchor aria-hidden=true href=#3-訊息佇列>#</a></h3><ul><li>相較於 FIFO，訊息佇列有以下優點：<ul><li>消息佇列可以獨立於讀寫進程存在，從而避免了 FIFO 中同步管道的打開和關閉時可能產生的困難。</li><li>避免了 FIFO 的同步阻塞問題，不需要進程自己提供同步方法。</li><li>讀進程可以根據訊息類型有選擇性地接收訊息，而不像 FIFO 那樣只能全盤地接受。</li></ul></li></ul><h3 id=4-訊號量>4. 訊號量<a hidden class=anchor aria-hidden=true href=#4-訊號量>#</a></h3><ul><li>一個計數器，用於為多個進程提供對共享數據的物件作訪問。</li></ul><h3 id=5-記憶體共享>5. 記憶體共享<a hidden class=anchor aria-hidden=true href=#5-記憶體共享>#</a></h3><ul><li>允許多個進程共享一個給定的記憶體空間。因為數據不需要在進程之間複制，所以這是最快的一種 IPC(Inter-Process Communication)。</li><li>需要使用訊號量來同步對共享記憶體的訪問。</li><li>多個進程可以將同一個文件映射到它們的地址空間從而實現共享記憶體。另外 XSI 共享記憶體不是使用文件，而是使用記憶體的匿名段。</li></ul><h3 id=6-word-套接>6. word 套接<a hidden class=anchor aria-hidden=true href=#6-word-套接>#</a></h3><ul><li>與其它通訊機制不同的是，它可以用於不同機器間的進程通訊。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/os/>OS</a></li><li><a href=https://intervalrain.github.io/tags/cs/>CS</a></li></ul></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>