<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Algo] 0-3. 鏈表(Linked List) | Rain Hu's Workspace</title>
<meta name=keywords content="C++,Leetcode,Algorithm,linked_list,鏈表,list,ListNode"><meta name=description content="演算法結構介紹，介紹鏈表的遍歷，與常見的經典考題與常用到的操作手法"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/cs/algo/linked_list/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/cs/algo/linked_list/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[Algo] 0-3. 鏈表(Linked List)"><meta property="og:description" content="演算法結構介紹，介紹鏈表的遍歷，與常見的經典考題與常用到的操作手法"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="cs"><meta property="article:published_time" content="2022-10-06T22:30:28+08:00"><meta property="article:modified_time" content="2022-10-06T22:30:28+08:00"><meta property="article:tag" content="CS"><meta property="article:tag" content="Algo"><meta property="og:image" content="https://intervalrain.github.io/images/faang.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://intervalrain.github.io/images/faang.webp"><meta name=twitter:title content="[Algo] 0-3. 鏈表(Linked List)"><meta name=twitter:description content="演算法結構介紹，介紹鏈表的遍歷，與常見的經典考題與常用到的操作手法"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"CSes","item":"https://intervalrain.github.io/cs/"},{"@type":"ListItem","position":2,"name":"[Algo] 0-3. 鏈表(Linked List)","item":"https://intervalrain.github.io/cs/algo/linked_list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Algo] 0-3. 鏈表(Linked List)","name":"[Algo] 0-3. 鏈表(Linked List)","description":"演算法結構介紹，介紹鏈表的遍歷，與常見的經典考題與常用到的操作手法","keywords":["C++","Leetcode","Algorithm","linked_list","鏈表","list","ListNode"],"articleBody":"一、鏈表的基本結構 鏈表是由節點和指針構成的數據結構，每個節點存有一個值，和一個指向下一個節點的指針。不同於數組，鏈表並不能隨機訪問，必須透過指針找到該節點才能獲取其值；同理在未遍歷到鏈表結尾時，我們也無法知道鏈表長度，除非依賴其它數據結構儲存長度。 LeetCode 中默認的鏈表： struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; 二、鏈表的基本操作 在開始演算法實踐前，先來練習一下鏈表的 CRUD 吧！ 1. 查(Read) 由於鏈表並非在儲存格中連續分布，所以無法用索引進行隨機訪問，所以我們必須逐個訪問，直到到達我們想要的元素。 藉由指針每次指向當前節點的 next，移動 n 次到達 index 為 n 的節點。 int at(ListNode* head, int n){ // index 為 n ListNode* curr = head; while (n--){ // 移動 n 次 curr = curr-\u003enext; } return curr-\u003eval; } 2. 改(Update) 改的步驟，只是將查完的元素予以賦值。 void update(ListNode* head, int n, int val){ ListNode* curr = head; while (n--){ curr = curr-\u003enext; } curr-\u003eval = val; // 查完後賦值 } 3. 增(create) 如果要新增節點，則必須找到要插入位置的前一個節點。 ListNode* insert(ListNode* head, int n, int val){ if (!head) return NULL; // 處理當鏈表為空的狀態 if (n == 0){ // 處理當插入位置為 0 時的特例 ListNode* newHead = new ListNode(val, head); head = newHead; return head; } ListNode* curr = head; while (curr \u0026\u0026 --n){ // 移動到插入位置的前一位 curr = curr-\u003enext; } ListNode* tmp = curr-\u003enext; // 預先存下來插入位置的後一位 curr-\u003enext = new ListNode(val); // 插入元素 curr-\u003enext-\u003enext = tmp; // 將元素的下一位指派給存下來的後一位 return head; } 上述的寫法很直觀，但需要處例首位的特例，不夠漂亮，這時我們常會用到 DUMMY HEAD 的手法，即在鏈表最開頭先創一個假的節點，最後再返回該節點的下一位。 ListNode* insert(ListNode* head, int n, int val){ if (!head) return NULL; ListNode* dummy = new ListNode(-1, head); // 創建一個 dummy head ListNode* curr = dummy; while (curr \u0026\u0026 n--){ // 注意為 n-- curr = curr-\u003enext; } ListNode* tmp = curr-\u003enext; curr-\u003enext = new ListNode(val); curr-\u003enext-\u003enext = tmp; return dummy-\u003enext; // 注意為返回 dummy 的下一位 } 前面兩解都是在可以取得前一位，且不更改節點的值的前提下的解法。如果只能取得當下的節點，則可以使用增+更的手法。 void insert(ListNode* node, int val){ int tmp = node-\u003eval; node-\u003eval = val; node-\u003enext = new ListNode(tmp, node-\u003enext); } 4. 減(delete) 與增類似，取得前一位再利用更改指針的方式達到刪除。 ListNode* erase(ListNode* head, int n, int val){ if (!head) return NULL; ListNode* dummy = new ListNode(-1, head); ListNode* curr = dummy; while (curr \u0026\u0026 n--){ curr = curr-\u003enext; } curr-\u003enext = curr-\u003enext-\u003enext; // 將前一位的後一位指給後一位 return dummy-\u003enext; } 只能取得當下節點的作法： [LeetCode. 237] Delete Node in a Linked List(Medium) void insert(ListNode* node, int val){ node-\u003eval = node-\u003enext-\u003eval; // 將當前的值賦值成下一位的值 node-\u003enext = node-\u003enext-\u003enext; // 將下一個節點刪除 } 三、鏈表的進階操作 1. 刪值 如何刪除表中第一個出現指定值的節點，同樣找到該值的前一個節點，再使用刪除的手法即可： void remove(ListNode* head, int target){ ListNode* prev = NULL; ListNode* curr = head; while (curr \u0026\u0026 curr-\u003eval != target){ prev = curr; curr = curr-\u003enext; } if (!prev) // 處理例外 head = head-\u003enext; else prev-\u003enext = prev-\u003enext-\u003enext; } 2. 建表 如何藉由一個數組建立一鏈表，可以藉由前面使用的 dummy head 的手法： ListNode* build(vector\u003cint\u003e nums){ ListNode* dummy = new ListNode(-1); ListNode* prev = dummy; ListNode* curr = NULL; for (int i = 0; i \u003c nums.size(); i++){ curr = new ListNode(nums[i]); prev-\u003enext = curr; prev = curr; curr = curr-\u003enext; } ListNode* head = dummy-\u003enext; delete(dummy); return head; } 3. 鏈表的後序遍歷 前文說過，鏈表也可以做前序與後序的遍歷，在此我們再複習一次。 void traverse(ListNode* head){ // pre-order traverse(head-\u003enext); // post-order } 如果我們想移除鏈表中所有值等於 target 的節點，用迭代的作法為： void removeAll(ListNode* head, int target){ ListNode* dummy = new ListNode(-1, head); ListNode* curr = dummy; while (curr \u0026\u0026 curr-\u003enext){ if (curr-\u003enext-\u003eval == target){ // 當前節點的下一位符合 target 則刪除它 curr-\u003enext = curr-\u003enext-\u003enext; } else { curr = curr-\u003enext; // 否則則繼續後下遍歷 } } } 那如果用遞迴的寫法呢： void removeAll(ListNode* head, int target){ if (!head) return; // 假如鏈表為空，則退出函式 while (head \u0026\u0026 head-\u003eval == target){ if (head-\u003enext){ head-\u003eval = head-\u003enext-\u003enext; head-\u003enext = head-\u003enext-\u003enext; // 刪除 } else { head = NULL; // 當最後一個元素需移除時 } } removeAll(head-\u003enext, target) // 前序遍歷 } 後序跟前序有個很維妙的差別在於：後序遍歷可以將值傳回給前一個元素！ 試試看用後序回傳值的特徵來實作這個函式 void removeAll(ListNode* head, int target){ int tmp; if (head-\u003enext) tmp = removeAll(head-\u003enext, target) // recursion if (tmp == target) // 後序遍歷可以取得下一位的回傳的值 head-\u003enext = head-\u003enext-\u003enext; // 有了需要刪除的節點的前一位，要刪除就容易啦！ return head-\u003eval // 傳回當前節點的值 } 四、秀一波的操作 1. 刪值 用兩個節點去做到鏈表刪除的操作，還是有一點點不夠美，試試看下面這個 pointer to pointer 的解法吧！ 改自文章你所不知道的 C 語言: linked list 和非連續記憶體 void remove(ListNode* head, int target){ ListNode** curr = \u0026head; // 將指向指針的 curr 指向 head while ((*curr)-\u003eval != target) curr = \u0026(*curr)-\u003enext; if (!(*curr)) return; // 避免掉指向 NULL *curr = (*curr)-\u003enext } 2. 建表 學會上面這個 pointer to pointer 的作法，不如試試看來用這個方法來建表！ ListNode* build(vector\u003cint\u003e nums){ ListNode* head = new ListNode(nums[0]); ListNode** curr = \u0026head; for (int i = 0; i \u003c nums.size(); i++){ (*curr)-\u003enext = new ListNode(nums[i]); curr = \u0026(*curr)-\u003enext; } } 五、鏈表的演算法 1. 反轉鏈表 [LeetCode. 206] Reverse Linked List(Easy) 藉由剛剛學習到鏈表的操作，用迭代的方式來解題吧。 考慮到一個反轉鏈表的連續操作，我們需要有三個節點 prev, curr, next。 ListNode* reverse(ListNode* head){ ListNode* prev = NULL; ListNode* curr = head; ListNode* next = NULL; while (curr){ next = curr-\u003enext; // 先記住下一個位置 curr-\u003enext = prev; // 將指針指向前一位，以達成反轉的目的 prev = curr; // 往前移動 curr = next; // 往前移垂 } return prev; } 那如果用遞迴的方式寫呢？ ListNode* reverse(ListNode* head){ if (!head || head-\u003enext) return head; // 處理終止條件 ListNode last = reverse(head-\u003enext); // post-order traversal：回傳已排序好的子鏈表，並傳回最後一項 head-\u003enext-\u003enext = head; head-\u003enext = NULL; return last; } [[Followup] 反轉前 N 個節點 反轉鏈表的前 N 個節點：用前面的函式稍作修改 ListNode* successor = NULL; ListNode* reverseN(ListNode* head, int n){ if (n == 1){ // 只反轉 1 個節點相當於沒有反轉，故轉回自己 successor = head-\u003enext; // 記錄反轉後的鏈表要接到哪裡-\u003e剩餘鏈表的頭 return head; } ListNode last = reverseN(head-\u003enext, n-1); head-\u003enext-\u003enext = head; head-\u003enext = successor; // 最後將鏈表的尾巴接到剩餘鏈表的頭 return last; } [LeetCode. 92] Reverse Linked List II(Medium) 反轉第 m 到第 n 個節點中間的節點 前進 m - 1 次就相當於就相當於反轉前 (n-m-1) 個節點，就可以用 reverseN 解了。 ListNode* reverseBetween(ListNode* head, int m, int n){ if (m == 1){ return reverseN(head, n); // 與 LeetCode.92 一樣 } head-\u003enext = reverseBetween(head-\u003enext, m-1, n-1); // 前進到 base case return head; } [LeetCode. 25] Reverse Nodes in k-Group (Hard) 結合前面的經驗，注意遞迴該返回的值是什麼。 注意結尾若節數小於 k 則不則 reverse。 ListNode* reverseKGroup(ListNode* head, int k) { ListNode* curr = head; int cnt = 0; while (curr \u0026\u0026 cnt \u003c k){ curr = curr-\u003enext; cnt++; } if (cnt == k){ // 當節數小於 k 時，不做 reverse curr = reverseKGroup(curr, k); // 傳回的是 reverse 完的鏈表的 head，故需把 reverse 完的尾與之相接 while (cnt-- \u003e 0){ ListNode* next = head-\u003enext; head-\u003enext = curr; curr = head; head = next; } return curr; // 當節數等於 k 時回傳的是尾巴 } return head; // 注意節數小於 k 時仍回傳 head } 2. 環型鏈表(龜兔賽跑-快慢指針) [LeetCode. 141] Linked List Cycle(Easy) 快慢指針是雙指針的一種應用，利用兩個指針移動的速度不同來達到目的。最經典的題型就是找尋鏈表是否含有環。 要檢查鏈表是否有環，可以使用找尋圖(graph)中是否有環的技巧，並利用 visited 來檢查是否有拜訪過，但下面快慢指針的技巧可以不用額外使用空間，使空間複雜度降到 \\(O(1)\\)。 bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast \u0026\u0026 fast-\u003enext){ // 確保快指針與他的下一位都不是 NULL fast = fast-\u003enext-\u003enext; // 快指針走兩步 slow = slow-\u003enext; // 慢指針走一步 if (fast == slow) return true; // 若兩者相撞，則必有環 } return false; } [LeetCode. 142] Linked List Cycle II(Medium) 此題是要找尋鏈表中若有環，則相交點是哪一點： 因為快指針走的距離是慢指針 k 的兩倍，令相遇點距相交點距離為 m 圓環的長度為 L：\n\\(\\text{L + m + k = 2 * k}\\)\n\\(\\text{L = k - m}\\)\n故起點到相交點的長度 \\(\\text{k - m}\\) 與相遇點到相交點的長度 \\(\\text{k - m}\\) 相同。 ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast \u0026\u0026 fast-\u003enext){ fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; if (fast == slow) break; // 若有環則退出 } if (!fast || !fast-\u003enext) return NULL; // 若快指針已經走到底表示沒有環 fast = head; // 讓其中一個指針從頭開始走，並一同樣的速度走 while (fast != slow){ // 相遇點即為相交點 fast = fast-\u003enext; slow = slow-\u003enext; } return fast; } [LeetCode. 876] Middle of the Linked List(Easy) 這題當然可以先遍歷一遍取得鏈表長度後，再重新以長度計量，走一半的長度來得到答案，但很顯然不夠漂亮，用快慢指針，令快指針比慢指針移動速度快兩倍，當快指針走完時，慢指針即指向中點。以此類推可求1/3的節點、2/5的節點等。 ListNode* middleNode(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast \u0026\u0026 fast-\u003enext){ fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; } return slow; } 3. 雙指針(前後指針) [LeetCode. 19] Remove Nth Node From End of List(Medium) 這題也是簡單的雙指針問題，當前指針先走 n 步，兩指針以同樣速度往前走(即前後指針始終保持 n 的距離)，則前指針走完時，後指針指向倒數第 k 個節點。 ListNode* removeNthFromEnd(ListNode* head, int n) { // 注意以下我們要刪除第 n 個節點，故我們需找第 n-1 個節點，為避免刪除第一個節點的例子，我們引入 dummy ListNode* dummy = new ListNode(-1, head); ListNode* slow = dummy; ListNode* fast = dummy; while (fast \u0026\u0026 n--){ // 前指針先行走 n 個節點 fast = fast-\u003enext; } while (fast-\u003enext){ // 保持等速 slow = slow-\u003enext; fast = fast-\u003enext; } slow-\u003enext = slow-\u003enext-\u003enext; // 刪除第 n 個節點 return dummy-\u003enext; } [LeetCode. 160] Intersection of Two Linked Lists(Easy) 找兩條鏈表的相交點，這題也可以用雙指針的方式解，當 A 鏈懷走完鏈表立即讓它接回 B 鏈表，B 鏈表亦如是，則相遇點則會是相交點，因為此時它們各別則的距離是都是 A 鏈表的長度加上 B 鏈表的長度，但要注意要記錄是否已經接過一遍，如果沒有相交點，又無限接下去，則程式永遠不會停止。 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* a = headA; ListNode* b = headB; bool flagA = true; // 用來標記是否已接過另一鏈表 bool flagB = true; // 用來標記是否已接過另一鏈表 while (a \u0026\u0026 b){ if (a == b) return a; // 相遇表示相交點 a = a-\u003enext; b = b-\u003enext; if (!a \u0026\u0026 flagA){ a = headB; flagA = false; // 已接過另一鏈表 } if (!b \u0026\u0026 flagB){ b = headA; flagB = false; // 已接過另一鏈表 } } return NULL; } [LeetCode. 86] Partition List(Medium) 具體作法可將鏈表一分為二，待兩條鏈表皆完成後再頭尾相接。 ListNode* partition(ListNode* head, int x) { ListNode* dummy1 = new ListNode(-1); ListNode* dummy2 = new ListNode(-1); ListNode* curr1 = dummy1; ListNode* curr2 = dummy2; while (head){ if (head-\u003eval \u003c x){ curr1-\u003enext = head; curr1 = curr1-\u003enext; } else { curr2-\u003enext = head; curr2 = curr2-\u003enext; } head = head-\u003enext; } curr1-\u003enext = dummy2-\u003enext; curr2-\u003enext = NULL; return dummy1-\u003enext; } [LeetCode. 21] Merge Two Sorted Lists(Easy) 簡單的 if-else，搭配 dummy 的做法即可解題。 ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* dummy = new ListNode(-1); ListNode* curr = dummy; while (list1 \u0026\u0026 list2){ if (list1-\u003eval \u003c= list2-\u003eval){ curr-\u003enext = list1; list1 = list1-\u003enext; } else { curr-\u003enext = list2; list2 = list2-\u003enext; } curr = curr-\u003enext; } curr-\u003enext = list1 ? list1 : list2; return dummy-\u003enext; } 4. 優先佇列 [LeetCode. 23] Merge k Sorted Lists(Hard) 這一題有點 tricky，我們可以用到優先佇列，由於每次比較只會比較鏈表的頭節表，故我們連續將鏈表推至 min heap 上，並每次把 min heap 頂端的節點接到新的鏈表後，再把 min heap 上的鏈表拿去頭後，再丟回優先佇列中，至到鏈表走完，即完成。 ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { auto cmp = [](ListNode* a, ListNode* b){return a-\u003eval \u003e b-\u003eval;}; priority_queue\u003cListNode*, vector\u003cListNode*\u003e, decltype(cmp)\u003e pq(cmp); ListNode* dummy = new ListNode(-1); ListNode* curr = dummy; for (ListNode* node : lists){ if (node) pq.push(node); } while (!pq.empty()){ ListNode* node = pq.top(); pq.pop(); curr-\u003enext = node; curr = curr-\u003enext; node = node-\u003enext; if (node) pq.push(node); } return dummy-\u003enext; } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 0-2. 演算法思維 接著閱讀：[Algo] 0-4. 二元樹(Binary Tree) ","wordCount":"1441","inLanguage":"zh-tw","image":"https://intervalrain.github.io/images/faang.webp","datePublished":"2022-10-06T22:30:28+08:00","dateModified":"2022-10-06T22:30:28+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/cs/algo/linked_list/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/cs/>CSes</a></div><h1 class="post-title entry-hint-parent">[Algo] 0-3. 鏈表(Linked List)</h1><div class=post-description>演算法結構介紹，介紹鏈表的遍歷，與常見的經典考題與常用到的操作手法</div><div class=post-meta><span title='2022-10-06 22:30:28 +0800 +0800'>October 6, 2022</span>&nbsp;·&nbsp;7 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//CS/algo/linked_list.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%8f%88%e8%a1%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%b5%90%e6%a7%8b aria-label=一、鏈表的基本結構>一、鏈表的基本結構</a></li><li><a href=#%e4%ba%8c%e9%8f%88%e8%a1%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c aria-label=二、鏈表的基本操作>二、鏈表的基本操作</a><ul><li><a href=#1-%e6%9f%a5read aria-label="1. 查(Read)">1. 查(Read)</a></li><li><a href=#2-%e6%94%b9update aria-label="2. 改(Update)">2. 改(Update)</a></li><li><a href=#3-%e5%a2%9ecreate aria-label="3. 增(create)">3. 增(create)</a></li><li><a href=#4-%e6%b8%9bdelete aria-label="4. 減(delete)">4. 減(delete)</a><ul><li><a href=#leetcode-237-delete-node-in-a-linked-listmediumhttpsleetcodecomproblemsdelete-node-in-a-linked-list aria-label="[LeetCode. 237] Delete Node in a Linked List(Medium)"><a href=https://leetcode.com/problems/delete-node-in-a-linked-list/>[LeetCode. 237] Delete Node in a Linked List(Medium)</a></a></li></ul></li></ul></li><li><a href=#%e4%b8%89%e9%8f%88%e8%a1%a8%e7%9a%84%e9%80%b2%e9%9a%8e%e6%93%8d%e4%bd%9c aria-label=三、鏈表的進階操作>三、鏈表的進階操作</a><ul><li><a href=#1-%e5%88%aa%e5%80%bc aria-label="1. 刪值">1. 刪值</a></li><li><a href=#2-%e5%bb%ba%e8%a1%a8 aria-label="2. 建表">2. 建表</a></li><li><a href=#3-%e9%8f%88%e8%a1%a8%e7%9a%84%e5%be%8c%e5%ba%8f%e9%81%8d%e6%ad%b7 aria-label="3. 鏈表的後序遍歷">3. 鏈表的後序遍歷</a></li></ul></li><li><a href=#%e5%9b%9b%e7%a7%80%e4%b8%80%e6%b3%a2%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=四、秀一波的操作>四、秀一波的操作</a><ul><li><a href=#1-%e5%88%aa%e5%80%bc-1 aria-label="1. 刪值">1. 刪值</a></li><li><a href=#2-%e5%bb%ba%e8%a1%a8-1 aria-label="2. 建表">2. 建表</a></li></ul></li><li><a href=#%e4%ba%94%e9%8f%88%e8%a1%a8%e7%9a%84%e6%bc%94%e7%ae%97%e6%b3%95 aria-label=五、鏈表的演算法>五、鏈表的演算法</a><ul><li><a href=#1-%e5%8f%8d%e8%bd%89%e9%8f%88%e8%a1%a8 aria-label="1. 反轉鏈表">1. 反轉鏈表</a><ul><li><a href=#leetcode-206-reverse-linked-listeasyhttpsleetcodecomproblemsreverse-linked-list aria-label="[LeetCode. 206] Reverse Linked List(Easy)"><a href=https://leetcode.com/problems/reverse-linked-list/>[LeetCode. 206] Reverse Linked List(Easy)</a></a></li><li><a href=#followup-%e5%8f%8d%e8%bd%89%e5%89%8d-n-%e5%80%8b%e7%af%80%e9%bb%9e aria-label="[[Followup] 反轉前 N 個節點">[[Followup] 反轉前 N 個節點</a></li><li><a href=#leetcode-92-reverse-linked-list-iimediumhttpsleetcodecomproblemsreverse-linked-list-ii aria-label="[LeetCode. 92] Reverse Linked List II(Medium)"><a href=https://leetcode.com/problems/reverse-linked-list-ii/>[LeetCode. 92] Reverse Linked List II(Medium)</a></a></li><li><a href=#leetcode-25-reverse-nodes-in-k-group-hardhttpsleetcodecomproblemsreverse-nodes-in-k-group aria-label="[LeetCode. 25] Reverse Nodes in k-Group (Hard)"><a href=https://leetcode.com/problems/reverse-nodes-in-k-group/>[LeetCode. 25] Reverse Nodes in k-Group (Hard)</a></a></li></ul></li><li><a href=#2-%e7%92%b0%e5%9e%8b%e9%8f%88%e8%a1%a8%e9%be%9c%e5%85%94%e8%b3%bd%e8%b7%91-%e5%bf%ab%e6%85%a2%e6%8c%87%e9%87%9d aria-label="2. 環型鏈表(龜兔賽跑-快慢指針)">2. 環型鏈表(龜兔賽跑-快慢指針)</a><ul><li><a href=#leetcode-141-linked-list-cycleeasyhttpsleetcodecomproblemslinked-list-cycle aria-label="[LeetCode. 141] Linked List Cycle(Easy)"><a href=https://leetcode.com/problems/linked-list-cycle/>[LeetCode. 141] Linked List Cycle(Easy)</a></a></li><li><a href=#leetcode-142-linked-list-cycle-iimediumhttpsleetcodecomproblemslinked-list-cycle-ii aria-label="[LeetCode. 142] Linked List Cycle II(Medium)"><a href=https://leetcode.com/problems/linked-list-cycle-ii/>[LeetCode. 142] Linked List Cycle II(Medium)</a></a></li><li><a href=#leetcode-876-middle-of-the-linked-listeasyhttpsleetcodecomproblemsmiddle-of-the-linked-list aria-label="[LeetCode. 876] Middle of the Linked List(Easy)"><a href=https://leetcode.com/problems/middle-of-the-linked-list/>[LeetCode. 876] Middle of the Linked List(Easy)</a></a></li></ul></li><li><a href=#3-%e9%9b%99%e6%8c%87%e9%87%9d%e5%89%8d%e5%be%8c%e6%8c%87%e9%87%9d aria-label="3. 雙指針(前後指針)">3. 雙指針(前後指針)</a><ul><li><a href=#leetcode-19-remove-nth-node-from-end-of-listmediumhttpsleetcodecomproblemsremove-nth-node-from-end-of-list aria-label="[LeetCode. 19] Remove Nth Node From End of List(Medium)"><a href=https://leetcode.com/problems/remove-nth-node-from-end-of-list/>[LeetCode. 19] Remove Nth Node From End of List(Medium)</a></a></li><li><a href=#leetcode-160-intersection-of-two-linked-listseasyhttpsleetcodecomproblemsintersection-of-two-linked-lists aria-label="[LeetCode. 160] Intersection of Two Linked Lists(Easy)"><a href=https://leetcode.com/problems/intersection-of-two-linked-lists/>[LeetCode. 160] Intersection of Two Linked Lists(Easy)</a></a></li><li><a href=#leetcode-86-partition-listmediumhttpsleetcodecomproblemspartition-list aria-label="[LeetCode. 86] Partition List(Medium)"><a href=https://leetcode.com/problems/partition-list/>[LeetCode. 86] Partition List(Medium)</a></a></li><li><a href=#leetcode-21-merge-two-sorted-listseasyhttpsleetcodecomproblemsmerge-two-sorted-lists aria-label="[LeetCode. 21] Merge Two Sorted Lists(Easy)"><a href=https://leetcode.com/problems/merge-two-sorted-lists/>[LeetCode. 21] Merge Two Sorted Lists(Easy)</a></a></li></ul></li><li><a href=#4-%e5%84%aa%e5%85%88%e4%bd%87%e5%88%97 aria-label="4. 優先佇列">4. 優先佇列</a><ul><li><a href=#leetcode-23-merge-k-sorted-listshardhttpsleetcodecomproblemsmerge-k-sorted-lists aria-label="[LeetCode. 23] Merge k Sorted Lists(Hard)"><a href=https://leetcode.com/problems/merge-k-sorted-lists/>[LeetCode. 23] Merge k Sorted Lists(Hard)</a></a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=一鏈表的基本結構>一、鏈表的基本結構<a hidden class=anchor aria-hidden=true href=#一鏈表的基本結構>#</a></h2><ul><li>鏈表是由節點和指針構成的數據結構，每個節點存有一個值，和一個指向下一個節點的指針。不同於數組，鏈表並不能隨機訪問，必須透過指針找到該節點才能獲取其值；同理在未遍歷到鏈表結尾時，我們也無法知道鏈表長度，除非依賴其它數據結構儲存長度。</li><li>LeetCode 中默認的鏈表：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ListNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val;
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>    ListNode(<span style=color:#66d9ef>int</span> x) <span style=color:#f92672>:</span> val(x), next(<span style=color:#66d9ef>nullptr</span>) {}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=二鏈表的基本操作>二、鏈表的基本操作<a hidden class=anchor aria-hidden=true href=#二鏈表的基本操作>#</a></h2><ul><li>在開始演算法實踐前，先來練習一下鏈表的 CRUD 吧！</li></ul><h3 id=1-查read>1. 查(Read)<a hidden class=anchor aria-hidden=true href=#1-查read>#</a></h3><ul><li>由於鏈表並非在儲存格中連續分布，所以無法用索引進行隨機訪問，所以我們必須逐個訪問，直到到達我們想要的元素。</li><li>藉由指針每次指向當前節點的 next，移動 n 次到達 index 為 n 的節點。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>at</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> n){      <span style=color:#75715e>// index 為 n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (n<span style=color:#f92672>--</span>){        <span style=color:#75715e>// 移動 n 次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> curr<span style=color:#f92672>-&gt;</span>val;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-改update>2. 改(Update)<a hidden class=anchor aria-hidden=true href=#2-改update>#</a></h3><ul><li>改的步驟，只是將查完的元素予以賦值。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (n<span style=color:#f92672>--</span>){
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    curr<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> val;      <span style=color:#75715e>// 查完後賦值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=3-增create>3. 增(create)<a hidden class=anchor aria-hidden=true href=#3-增create>#</a></h3><ul><li>如果要新增節點，則必須找到要插入位置的前一個節點。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>insert</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head) <span style=color:#66d9ef>return</span> NULL;                             <span style=color:#75715e>// 處理當鏈表為空的狀態
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){                                        <span style=color:#75715e>// 處理當插入位置為 0 時的特例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ListNode<span style=color:#f92672>*</span> newHead <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(val, head);
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> newHead;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (curr <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>--</span>n){                                <span style=color:#75715e>// 移動到插入位置的前一位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> tmp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;                         <span style=color:#75715e>// 預先存下來插入位置的後一位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(val);                     <span style=color:#75715e>// 插入元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    curr<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> tmp;                             <span style=color:#75715e>// 將元素的下一位指派給存下來的後一位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>上述的寫法很直觀，但需要處例首位的特例，不夠漂亮，這時我們常會用到 <strong>DUMMY HEAD</strong> 的手法，即在鏈表最開頭先創一個假的節點，最後再返回該節點的下一位。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>insert</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, head);           <span style=color:#75715e>// 創建一個 dummy head
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (curr <span style=color:#f92672>&amp;&amp;</span> n<span style=color:#f92672>--</span>){                                <span style=color:#75715e>// 注意為 n-- 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next; 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> tmp <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(val);
</span></span><span style=display:flex><span>    curr<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dummy<span style=color:#f92672>-&gt;</span>next;                                 <span style=color:#75715e>// 注意為返回 dummy 的下一位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>前面兩解都是在可以取得前一位，且不更改節點的值的前提下的解法。如果只能取得當下的節點，則可以使用<strong>增+更</strong>的手法。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(ListNode<span style=color:#f92672>*</span> node, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> tmp <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>val;
</span></span><span style=display:flex><span>    node<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> val;
</span></span><span style=display:flex><span>    node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(tmp, node<span style=color:#f92672>-&gt;</span>next);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-減delete>4. 減(delete)<a hidden class=anchor aria-hidden=true href=#4-減delete>#</a></h3><ul><li>與增類似，取得前一位再利用更改指針的方式達到刪除。
<img alt=delete loading=lazy src=https://i.imgur.com/Qof9hCw.png></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>erase</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, head);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (curr <span style=color:#f92672>&amp;&amp;</span> n<span style=color:#f92672>--</span>){
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next; 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;      <span style=color:#75715e>// 將前一位的後一位指給後一位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> dummy<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>只能取得當下節點的作法：</li></ul><h4 id=leetcode-237-delete-node-in-a-linked-listmediumhttpsleetcodecomproblemsdelete-node-in-a-linked-list><a href=https://leetcode.com/problems/delete-node-in-a-linked-list/>[LeetCode. 237] Delete Node in a Linked List(Medium)</a><a hidden class=anchor aria-hidden=true href=#leetcode-237-delete-node-in-a-linked-listmediumhttpsleetcodecomproblemsdelete-node-in-a-linked-list>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(ListNode<span style=color:#f92672>*</span> node, <span style=color:#66d9ef>int</span> val){
</span></span><span style=display:flex><span>    node<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>val;        <span style=color:#75715e>// 將當前的值賦值成下一位的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;      <span style=color:#75715e>// 將下一個節點刪除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=三鏈表的進階操作>三、鏈表的進階操作<a hidden class=anchor aria-hidden=true href=#三鏈表的進階操作>#</a></h2><h3 id=1-刪值>1. 刪值<a hidden class=anchor aria-hidden=true href=#1-刪值>#</a></h3><ul><li>如何刪除表中第一個出現指定值的節點，同樣找到該值的前一個節點，再使用刪除的手法即可：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> target){
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (curr <span style=color:#f92672>&amp;&amp;</span> curr<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>!=</span> target){
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>prev)                  <span style=color:#75715e>// 處理例外
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> prev<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-建表>2. 建表<a hidden class=anchor aria-hidden=true href=#2-建表>#</a></h3><ul><li>如何藉由一個數組建立一鏈表，可以藉由前面使用的 dummy head 的手法：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> nums){
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> prev <span style=color:#f92672>=</span> dummy;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> nums.size(); i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(nums[i]);
</span></span><span style=display:flex><span>        prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> head <span style=color:#f92672>=</span> dummy<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span>(dummy);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-鏈表的後序遍歷>3. 鏈表的後序遍歷<a hidden class=anchor aria-hidden=true href=#3-鏈表的後序遍歷>#</a></h3><ul><li>前文說過，鏈表也可以做前序與後序的遍歷，在此我們再複習一次。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>traverse</span>(ListNode<span style=color:#f92672>*</span> head){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pre-order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    traverse(head<span style=color:#f92672>-&gt;</span>next);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// post-order
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>如果我們想移除鏈表中所有值等於 target 的節點，用迭代的作法為：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>removeAll</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> target){
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, head);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (curr <span style=color:#f92672>&amp;&amp;</span> curr<span style=color:#f92672>-&gt;</span>next){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (curr<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> target){         <span style=color:#75715e>// 當前節點的下一位符合 target 則刪除它
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;                  <span style=color:#75715e>// 否則則繼續後下遍歷
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>那如果用遞迴的寫法呢：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>removeAll</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> target){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head) <span style=color:#66d9ef>return</span>;                          <span style=color:#75715e>// 假如鏈表為空，則退出函式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (head <span style=color:#f92672>&amp;&amp;</span> head<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>==</span> target){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (head<span style=color:#f92672>-&gt;</span>next){
</span></span><span style=display:flex><span>            head<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;      <span style=color:#75715e>// 刪除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> NULL;                        <span style=color:#75715e>// 當最後一個元素需移除時
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    removeAll(head<span style=color:#f92672>-&gt;</span>next, target)               <span style=color:#75715e>// 前序遍歷
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>後序跟前序有個很維妙的差別在於：<strong>後序遍歷可以將值傳回給前一個元素</strong>！</li><li>試試看用後序回傳值的特徵來實作這個函式</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>removeAll</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> target){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> tmp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (head<span style=color:#f92672>-&gt;</span>next) 
</span></span><span style=display:flex><span>        tmp <span style=color:#f92672>=</span> removeAll(head<span style=color:#f92672>-&gt;</span>next, target)     <span style=color:#75715e>// recursion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (tmp <span style=color:#f92672>==</span> target)                          <span style=color:#75715e>// 後序遍歷可以取得下一位的回傳的值       
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;          <span style=color:#75715e>// 有了需要刪除的節點的前一位，要刪除就容易啦！
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> head<span style=color:#f92672>-&gt;</span>val                            <span style=color:#75715e>// 傳回當前節點的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=四秀一波的操作>四、秀一波的操作<a hidden class=anchor aria-hidden=true href=#四秀一波的操作>#</a></h2><h3 id=1-刪值-1>1. 刪值<a hidden class=anchor aria-hidden=true href=#1-刪值-1>#</a></h3><ul><li>用兩個節點去做到鏈表刪除的操作，還是有一點點不夠美，試試看下面這個 pointer to pointer 的解法吧！</li><li>改自文章<a href="https://hackmd.io/@sysprog/c-linked-list?fbclid=IwAR2179AHDYjsbYnbDdmCyiw7d3CF0yjehNGU-GcDsNAeZ_CkermprcDBzlo">你所不知道的 C 語言: linked list 和非連續記憶體</a>
<img alt="linus delete" loading=lazy src=https://hackmd.io/_uploads/HyuZ6Z13t.png></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> target){
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>**</span> curr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>head;    <span style=color:#75715e>// 將指向指針的 curr 指向 head
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> ((<span style=color:#f92672>*</span>curr)<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>!=</span> target)
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>curr)<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(<span style=color:#f92672>*</span>curr)) <span style=color:#66d9ef>return</span>;       <span style=color:#75715e>// 避免掉指向 NULL
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>curr)<span style=color:#f92672>-&gt;</span>next
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-建表-1>2. 建表<a hidden class=anchor aria-hidden=true href=#2-建表-1>#</a></h3><ul><li>學會上面這個 pointer to pointer 的作法，不如試試看來用這個方法來建表！</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>build</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> nums){
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> head <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(nums[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>**</span> curr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> nums.size(); i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>        (<span style=color:#f92672>*</span>curr)<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(nums[i]);
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>curr)<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=五鏈表的演算法>五、鏈表的演算法<a hidden class=anchor aria-hidden=true href=#五鏈表的演算法>#</a></h2><h3 id=1-反轉鏈表>1. 反轉鏈表<a hidden class=anchor aria-hidden=true href=#1-反轉鏈表>#</a></h3><h4 id=leetcode-206-reverse-linked-listeasyhttpsleetcodecomproblemsreverse-linked-list><a href=https://leetcode.com/problems/reverse-linked-list/>[LeetCode. 206] Reverse Linked List(Easy)</a><a hidden class=anchor aria-hidden=true href=#leetcode-206-reverse-linked-listeasyhttpsleetcodecomproblemsreverse-linked-list>#</a></h4><ul><li>藉由剛剛學習到鏈表的操作，用迭代的方式來解題吧。</li><li>考慮到一個反轉鏈表的連續操作，我們需要有三個節點 prev, curr, next。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverse</span>(ListNode<span style=color:#f92672>*</span> head){
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (curr){
</span></span><span style=display:flex><span>        next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;      <span style=color:#75715e>// 先記住下一個位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> prev;      <span style=color:#75715e>// 將指針指向前一位，以達成反轉的目的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        prev <span style=color:#f92672>=</span> curr;            <span style=color:#75715e>// 往前移動
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        curr <span style=color:#f92672>=</span> next;            <span style=color:#75715e>// 往前移垂
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prev;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>那如果用遞迴的方式寫呢？
<img alt=reverselist2 loading=lazy src=https://labuladong.github.io/algo/images/%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8/2.jpg>
<img alt=reverselist3 loading=lazy src=https://labuladong.github.io/algo/images/%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8/3.jpg>
<img alt=reverselist4 loading=lazy src=https://labuladong.github.io/algo/images/%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8/5.jpg></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverse</span>(ListNode<span style=color:#f92672>*</span> head){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>head <span style=color:#f92672>||</span> head<span style=color:#f92672>-&gt;</span>next) <span style=color:#66d9ef>return</span> head;   <span style=color:#75715e>// 處理終止條件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ListNode last <span style=color:#f92672>=</span> reverse(head<span style=color:#f92672>-&gt;</span>next);    <span style=color:#75715e>// post-order traversal：回傳已排序好的子鏈表，並傳回最後一項
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> last;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=followup-反轉前-n-個節點>[[Followup] 反轉前 N 個節點<a hidden class=anchor aria-hidden=true href=#followup-反轉前-n-個節點>#</a></h4><ul><li>反轉鏈表的前 N 個節點：用前面的函式稍作修改
<img alt=reverselistN loading=lazy src=https://labuladong.github.io/algo/images/%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8/7.jpg></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> successor <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseN</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> n){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>){                            <span style=color:#75715e>// 只反轉 1 個節點相當於沒有反轉，故轉回自己
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        successor <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;             <span style=color:#75715e>// 記錄反轉後的鏈表要接到哪裡-&gt;剩餘鏈表的頭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ListNode last <span style=color:#f92672>=</span> reverseN(head<span style=color:#f92672>-&gt;</span>next, n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> successor;                 <span style=color:#75715e>// 最後將鏈表的尾巴接到剩餘鏈表的頭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> last;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=leetcode-92-reverse-linked-list-iimediumhttpsleetcodecomproblemsreverse-linked-list-ii><a href=https://leetcode.com/problems/reverse-linked-list-ii/>[LeetCode. 92] Reverse Linked List II(Medium)</a><a hidden class=anchor aria-hidden=true href=#leetcode-92-reverse-linked-list-iimediumhttpsleetcodecomproblemsreverse-linked-list-ii>#</a></h4><ul><li>反轉第 m 到第 n 個節點中間的節點</li><li>前進 m - 1 次就相當於就相當於反轉前 (n-m-1) 個節點，就可以用 reverseN 解了。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseBetween</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> n){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> reverseN(head, n);                       <span style=color:#75715e>// 與 LeetCode.92 一樣
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> reverseBetween(head<span style=color:#f92672>-&gt;</span>next, m<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);  <span style=color:#75715e>// 前進到 base case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=leetcode-25-reverse-nodes-in-k-group-hardhttpsleetcodecomproblemsreverse-nodes-in-k-group><a href=https://leetcode.com/problems/reverse-nodes-in-k-group/>[LeetCode. 25] Reverse Nodes in k-Group (Hard)</a><a hidden class=anchor aria-hidden=true href=#leetcode-25-reverse-nodes-in-k-group-hardhttpsleetcodecomproblemsreverse-nodes-in-k-group>#</a></h4><ul><li>結合前面的經驗，注意<strong>遞迴該返回的值是什麼</strong>。</li><li>注意結尾若節數小於 k 則不則 reverse。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseKGroup</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (curr <span style=color:#f92672>&amp;&amp;</span> cnt <span style=color:#f92672>&lt;</span> k){
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cnt <span style=color:#f92672>==</span> k){              <span style=color:#75715e>// 當節數小於 k 時，不做 reverse
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        curr <span style=color:#f92672>=</span> reverseKGroup(curr, k);  <span style=color:#75715e>// 傳回的是 reverse 完的鏈表的 head，故需把 reverse 完的尾與之相接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (cnt<span style=color:#f92672>--</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>            ListNode<span style=color:#f92672>*</span> next <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>            curr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> curr;            <span style=color:#75715e>// 當節數等於 k 時回傳的是尾巴
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> head;                <span style=color:#75715e>// 注意節數小於 k 時仍回傳 head
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><hr><h3 id=2-環型鏈表龜兔賽跑-快慢指針>2. 環型鏈表(龜兔賽跑-快慢指針)<a hidden class=anchor aria-hidden=true href=#2-環型鏈表龜兔賽跑-快慢指針>#</a></h3><h4 id=leetcode-141-linked-list-cycleeasyhttpsleetcodecomproblemslinked-list-cycle><a href=https://leetcode.com/problems/linked-list-cycle/>[LeetCode. 141] Linked List Cycle(Easy)</a><a hidden class=anchor aria-hidden=true href=#leetcode-141-linked-list-cycleeasyhttpsleetcodecomproblemslinked-list-cycle>#</a></h4><ul><li>快慢指針是雙指針的一種應用，利用兩個指針移動的速度不同來達到目的。最經典的題型就是找尋鏈表是否含有環。</li><li>要檢查鏈表是否有環，可以使用找尋圖(graph)中是否有環的技巧，並利用 visited 來檢查是否有拜訪過，但下面快慢指針的技巧可以不用額外使用空間，使空間複雜度降到 \(O(1)\)。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>hasCycle</span>(ListNode <span style=color:#f92672>*</span>head) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> fast <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> slow <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (fast <span style=color:#f92672>&amp;&amp;</span> fast<span style=color:#f92672>-&gt;</span>next){             <span style=color:#75715e>// 確保快指針與他的下一位都不是 NULL
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        fast <span style=color:#f92672>=</span> fast<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;            <span style=color:#75715e>// 快指針走兩步
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        slow <span style=color:#f92672>=</span> slow<span style=color:#f92672>-&gt;</span>next;                  <span style=color:#75715e>// 慢指針走一步
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (fast <span style=color:#f92672>==</span> slow) <span style=color:#66d9ef>return</span> true;      <span style=color:#75715e>// 若兩者相撞，則必有環
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=leetcode-142-linked-list-cycle-iimediumhttpsleetcodecomproblemslinked-list-cycle-ii><a href=https://leetcode.com/problems/linked-list-cycle-ii/>[LeetCode. 142] Linked List Cycle II(Medium)</a><a hidden class=anchor aria-hidden=true href=#leetcode-142-linked-list-cycle-iimediumhttpsleetcodecomproblemslinked-list-cycle-ii>#</a></h4><ul><li>此題是要找尋鏈表中若有環，則相交點是哪一點：</li><li>因為快指針走的距離是慢指針 k 的兩倍，令相遇點距相交點距離為 m 圓環的長度為 L：<br>\(\text{L + m + k = 2 * k}\)<br>\(\text{L = k - m}\)<br>故起點到相交點的長度 \(\text{k - m}\) 與相遇點到相交點的長度 \(\text{k - m}\) 相同。
<img alt="cyclic linkedlist" loading=lazy src=https://labuladong.github.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/2.jpeg></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode <span style=color:#f92672>*</span><span style=color:#a6e22e>detectCycle</span>(ListNode <span style=color:#f92672>*</span>head) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> fast <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> slow <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (fast <span style=color:#f92672>&amp;&amp;</span> fast<span style=color:#f92672>-&gt;</span>next){
</span></span><span style=display:flex><span>        fast <span style=color:#f92672>=</span> fast<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        slow <span style=color:#f92672>=</span> slow<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (fast <span style=color:#f92672>==</span> slow) <span style=color:#66d9ef>break</span>;                <span style=color:#75715e>// 若有環則退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>fast <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>fast<span style=color:#f92672>-&gt;</span>next) <span style=color:#66d9ef>return</span> NULL;      <span style=color:#75715e>// 若快指針已經走到底表示沒有環
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    fast <span style=color:#f92672>=</span> head;                              <span style=color:#75715e>// 讓其中一個指針從頭開始走，並一同樣的速度走
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (fast <span style=color:#f92672>!=</span> slow){                     <span style=color:#75715e>// 相遇點即為相交點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        fast <span style=color:#f92672>=</span> fast<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        slow <span style=color:#f92672>=</span> slow<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fast;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=leetcode-876-middle-of-the-linked-listeasyhttpsleetcodecomproblemsmiddle-of-the-linked-list><a href=https://leetcode.com/problems/middle-of-the-linked-list/>[LeetCode. 876] Middle of the Linked List(Easy)</a><a hidden class=anchor aria-hidden=true href=#leetcode-876-middle-of-the-linked-listeasyhttpsleetcodecomproblemsmiddle-of-the-linked-list>#</a></h4><ul><li>這題當然可以先遍歷一遍取得鏈表長度後，再重新以長度計量，走一半的長度來得到答案，但很顯然不夠漂亮，用快慢指針，令快指針比慢指針移動速度快兩倍，當快指針走完時，慢指針即指向中點。以此類推可求1/3的節點、2/5的節點等。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>middleNode</span>(ListNode<span style=color:#f92672>*</span> head) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> fast <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> slow <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (fast <span style=color:#f92672>&amp;&amp;</span> fast<span style=color:#f92672>-&gt;</span>next){
</span></span><span style=display:flex><span>        fast <span style=color:#f92672>=</span> fast<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        slow <span style=color:#f92672>=</span> slow<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> slow;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-雙指針前後指針>3. 雙指針(前後指針)<a hidden class=anchor aria-hidden=true href=#3-雙指針前後指針>#</a></h3><h4 id=leetcode-19-remove-nth-node-from-end-of-listmediumhttpsleetcodecomproblemsremove-nth-node-from-end-of-list><a href=https://leetcode.com/problems/remove-nth-node-from-end-of-list/>[LeetCode. 19] Remove Nth Node From End of List(Medium)</a><a hidden class=anchor aria-hidden=true href=#leetcode-19-remove-nth-node-from-end-of-listmediumhttpsleetcodecomproblemsremove-nth-node-from-end-of-list>#</a></h4><ul><li>這題也是簡單的雙指針問題，當前指針先走 n 步，兩指針以同樣速度往前走(即前後指針始終保持 n 的距離)，則前指針走完時，後指針指向倒數第 k 個節點。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>removeNthFromEnd</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注意以下我們要刪除第 n 個節點，故我們需找第 n-1 個節點，為避免刪除第一個節點的例子，我們引入 dummy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ListNode<span style=color:#f92672>*</span> dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, head);  
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> slow <span style=color:#f92672>=</span> dummy;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> fast <span style=color:#f92672>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (fast <span style=color:#f92672>&amp;&amp;</span> n<span style=color:#f92672>--</span>){                <span style=color:#75715e>// 前指針先行走 n 個節點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        fast <span style=color:#f92672>=</span> fast<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (fast<span style=color:#f92672>-&gt;</span>next){                 <span style=color:#75715e>// 保持等速
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        slow <span style=color:#f92672>=</span> slow<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        fast <span style=color:#f92672>=</span> fast<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    slow<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> slow<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;      <span style=color:#75715e>// 刪除第 n 個節點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dummy<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=leetcode-160-intersection-of-two-linked-listseasyhttpsleetcodecomproblemsintersection-of-two-linked-lists><a href=https://leetcode.com/problems/intersection-of-two-linked-lists/>[LeetCode. 160] Intersection of Two Linked Lists(Easy)</a><a hidden class=anchor aria-hidden=true href=#leetcode-160-intersection-of-two-linked-listseasyhttpsleetcodecomproblemsintersection-of-two-linked-lists>#</a></h4><ul><li>找兩條鏈表的相交點，這題也可以用雙指針的方式解，當 A 鏈懷走完鏈表立即讓它接回 B 鏈表，B 鏈表亦如是，則相遇點則會是相交點，因為此時它們各別則的距離是都是 A 鏈表的長度加上 B 鏈表的長度，但要注意要記錄是否已經接過一遍，如果沒有相交點，又無限接下去，則程式永遠不會停止。
<img alt=intersection1 loading=lazy src=https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/4.png>
<img alt=intersection2 loading=lazy src=https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/5.jpeg>
<img alt=interscetion3 loading=lazy src=https://labuladong.github.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/6.jpeg></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode <span style=color:#f92672>*</span><span style=color:#a6e22e>getIntersectionNode</span>(ListNode <span style=color:#f92672>*</span>headA, ListNode <span style=color:#f92672>*</span>headB) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> a <span style=color:#f92672>=</span> headA;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> b <span style=color:#f92672>=</span> headB;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> flagA <span style=color:#f92672>=</span> true;          <span style=color:#75715e>// 用來標記是否已接過另一鏈表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> flagB <span style=color:#f92672>=</span> true;          <span style=color:#75715e>// 用來標記是否已接過另一鏈表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (a <span style=color:#f92672>&amp;&amp;</span> b){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> b) <span style=color:#66d9ef>return</span> a;   <span style=color:#75715e>// 相遇表示相交點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        a <span style=color:#f92672>=</span> a<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        b <span style=color:#f92672>=</span> b<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>a <span style=color:#f92672>&amp;&amp;</span> flagA){
</span></span><span style=display:flex><span>            a <span style=color:#f92672>=</span> headB;
</span></span><span style=display:flex><span>            flagA <span style=color:#f92672>=</span> false;      <span style=color:#75715e>// 已接過另一鏈表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        } 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>b <span style=color:#f92672>&amp;&amp;</span> flagB){
</span></span><span style=display:flex><span>            b <span style=color:#f92672>=</span> headA;
</span></span><span style=display:flex><span>            flagB <span style=color:#f92672>=</span> false;      <span style=color:#75715e>// 已接過另一鏈表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        } 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=leetcode-86-partition-listmediumhttpsleetcodecomproblemspartition-list><a href=https://leetcode.com/problems/partition-list/>[LeetCode. 86] Partition List(Medium)</a><a hidden class=anchor aria-hidden=true href=#leetcode-86-partition-listmediumhttpsleetcodecomproblemspartition-list>#</a></h4><ul><li>具體作法可將鏈表一分為二，待兩條鏈表皆完成後再頭尾相接。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>partition</span>(ListNode<span style=color:#f92672>*</span> head, <span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> dummy1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> dummy2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr1 <span style=color:#f92672>=</span> dummy1;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr2 <span style=color:#f92672>=</span> dummy2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (head){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (head<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>&lt;</span> x){
</span></span><span style=display:flex><span>            curr1<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>            curr1 <span style=color:#f92672>=</span> curr1<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            curr2<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>            curr2 <span style=color:#f92672>=</span> curr2<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    curr1<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> dummy2<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    curr2<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dummy1<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=leetcode-21-merge-two-sorted-listseasyhttpsleetcodecomproblemsmerge-two-sorted-lists><a href=https://leetcode.com/problems/merge-two-sorted-lists/>[LeetCode. 21] Merge Two Sorted Lists(Easy)</a><a hidden class=anchor aria-hidden=true href=#leetcode-21-merge-two-sorted-listseasyhttpsleetcodecomproblemsmerge-two-sorted-lists>#</a></h4><ul><li>簡單的 if-else，搭配 dummy 的做法即可解題。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>mergeTwoLists</span>(ListNode<span style=color:#f92672>*</span> list1, ListNode<span style=color:#f92672>*</span> list2) {
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (list1 <span style=color:#f92672>&amp;&amp;</span> list2){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (list1<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>&lt;=</span> list2<span style=color:#f92672>-&gt;</span>val){
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> list1;
</span></span><span style=display:flex><span>            list1 <span style=color:#f92672>=</span> list1<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> list2;
</span></span><span style=display:flex><span>            list2 <span style=color:#f92672>=</span> list2<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> list1 <span style=color:#f92672>?</span> list1 : list2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dummy<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-優先佇列>4. 優先佇列<a hidden class=anchor aria-hidden=true href=#4-優先佇列>#</a></h3><h4 id=leetcode-23-merge-k-sorted-listshardhttpsleetcodecomproblemsmerge-k-sorted-lists><a href=https://leetcode.com/problems/merge-k-sorted-lists/>[LeetCode. 23] Merge k Sorted Lists(Hard)</a><a hidden class=anchor aria-hidden=true href=#leetcode-23-merge-k-sorted-listshardhttpsleetcodecomproblemsmerge-k-sorted-lists>#</a></h4><ul><li>這一題有點 tricky，我們可以用到優先佇列，由於每次比較只會比較鏈表的頭節表，故我們連續將鏈表推至 min heap 上，並每次把 min heap 頂端的節點接到新的鏈表後，再把 min heap 上的鏈表拿去頭後，再丟回優先佇列中，至到鏈表走完，即完成。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>ListNode<span style=color:#f92672>*</span> <span style=color:#a6e22e>mergeKLists</span>(vector<span style=color:#f92672>&lt;</span>ListNode<span style=color:#f92672>*&gt;&amp;</span> lists) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> cmp <span style=color:#f92672>=</span> [](ListNode<span style=color:#f92672>*</span> a, ListNode<span style=color:#f92672>*</span> b){<span style=color:#66d9ef>return</span> a<span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>&gt;</span> b<span style=color:#f92672>-&gt;</span>val;};
</span></span><span style=display:flex><span>    priority_queue<span style=color:#f92672>&lt;</span>ListNode<span style=color:#f92672>*</span>, vector<span style=color:#f92672>&lt;</span>ListNode<span style=color:#f92672>*&gt;</span>, <span style=color:#66d9ef>decltype</span>(cmp)<span style=color:#f92672>&gt;</span> pq(cmp);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> dummy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (ListNode<span style=color:#f92672>*</span> node : lists){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (node) pq.push(node);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.empty()){
</span></span><span style=display:flex><span>        ListNode<span style=color:#f92672>*</span> node <span style=color:#f92672>=</span> pq.top();
</span></span><span style=display:flex><span>        pq.pop();
</span></span><span style=display:flex><span>        curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (node) pq.push(node);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dummy<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><ul><li>回到目錄：<a href=/cs/algo>[Algo] 演算法筆記</a></li><li>想要複習：<a href=/cs/algo/concept>[Algo] 0-2. 演算法思維</a></li><li>接著閱讀：<a href=/cs/algo/binary_tree>[Algo] 0-4. 二元樹(Binary Tree)</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/cs/>CS</a></li><li><a href=https://intervalrain.github.io/tags/algo/>Algo</a></li></ul></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>