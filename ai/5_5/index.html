<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[AI] 機器學習的流程 | Rain Hu's Workspace</title><meta name=keywords content="AI"><meta name=description content="The flow of machine learning"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/ai/5_5/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/ai/5_5/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[AI] 機器學習的流程"><meta property="og:description" content="The flow of machine learning"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="ai"><meta property="article:published_time" content="2025-01-12T17:54:31+08:00"><meta property="article:modified_time" content="2025-01-12T17:54:31+08:00"><meta property="article:tag" content="AI"><meta name=twitter:card content="summary"><meta name=twitter:title content="[AI] 機器學習的流程"><meta name=twitter:description content="The flow of machine learning"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[AI] 機器學習的流程","item":"https://intervalrain.github.io/ai/5_5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[AI] 機器學習的流程","name":"[AI] 機器學習的流程","description":"The flow of machine learning","keywords":["AI"],"articleBody":"機器學器的工作流程 一般而言，機器學習的通用工作流程可以歸納為三個部分: 定義任務(Define the task): 瞭解需求背後的問題領域與業務邏輯、收集資料、瞭解資料內容，並選擇衡量任務成功的標準。 開發模型(Develop a model): 準備好模型可以處理的資料、定義基準線、先訓練出一個能 overfitting 的模型，最後進行常規化、調整模型以提高普適化表現。 部署模型(Deploy a model): 將模型部署至伺服器、app、網頁或嵌入式裝置，並監控模型表現。 定義任務 問題域\n輸入資料: 我們需要知道輸入資料是什麼 目標: 我們要知道想要預測什麼 任務類型\n我們要定義我的的任務是哪種類型: 二元分類任務 多類別分類任務 純量迴歸 向量迴歸 多類別且多標籤任務 影像分割任務 排序任務 資料分群分任 生成任務 強式化學習任務 … 並不一定所有的任務類型都適用機器學習，傳統的統計分析方法也許更有效。 參考現有的解決方案\n我們必須先瞭解當前的解決方案是怎麼運作。 限制條件\n模型是在伺服器運作嗎？或是因為端到到加密，模型需在裝置上運行，並使用外部資料訓練。 資料的充足性\n我們想要預測的資料是否可以透過輸入來預測。 舉例來說我們想要預測未來股價，但是我們只有該股的歷史股價，則不具備資料充足性，應該要加入如 eps 等其它表徵資料。 建立資料集\n資料甚至比演算法還重要(The Unreasonable Effectiveness of Data)\n投資在資料標註工具 自行標註 外包平台，如 Mechanical Turk 專業資料標註公司 注意：需考慮資料標註是否需要領域專家 留意不具代表性的資料: 資料一定要足以代表實際運作的資料 即我們的訓練資料要可以表達實際運用的場景。可以參考抽樣偏差(sampling bias) 概念漂移: 資料具有時間性，2020 年訓練出來的模型，無法描述 2025 年發生的事。 理解資料 先從資料中抽幾個樣本與標籤，對資料進行解讀。 對資料有些概觀性的瞭解，判斷是否缺少特徵值、瞭解資料的 pattern。 檢查是否存在目標值洩漏(target leaking) 的問題。 選擇測量成效的方法 考慮準確度(accuracy)、精準度(precision)、故障召回率(recall)、客戶回流率? 好的評量指標(metric) 會引導專案的所有技術選擇，盡可能要與更高層次的目標保持一致。 ROC(receiveer operating characteristic) 曲線下面積 (ROC AUC, ROC Area Under Curve) 開發模型 準備資料\n通常模型無法接受原始資料，需經過預處理。 向量化(vectorization) 正規化(normalization) 處理缺失值 選擇驗證機制\n拆分驗證集(holdout validation set) K-fold Iterated K-fold 超越基準線\n特徵工程 選擇架構 決定訓練配置 $$ \\begin{array}{|c|c|c|} \\text{問題類型}\u0026\\text{輸出層激活函數}\u0026\\text{損失函數}\\\\\\hline \\text{二元分類}\u0026\\text{sigmoid}\u0026\\text{binary crossentropy}\\\\ \\text{多類別、單標籤分類}\u0026\\text{softmax}\u0026\\text{categorical crossentropy}\\\\ \\text{多類別、多標籤分類}\u0026\\text{sigmoid}\u0026\\text{binary crossentropy} \\end{array} $$ 擴大規模: 開發一個會 overfitting 的模型\n添加更多神經層 選擇更寬的神經層 訓練更多週期(epoch) 將模型常規化並調整超參數\n嘗試不同架構 dropout L1, L2 常規化(當模型不大) 嘗試不同超參數(ex. 優化器策略) 資料篩選、特徵工程 部署模型 向客戶說明成果、建立合理期待\n清楚說明模型的能力與限制 提供模型在不同場景下的表現數據 說明可能的錯誤類型與處理方式 建立明確的效能指標與監控機制 交付模型\nREST API 部署 建立可擴展的API架構 實作請求限制與認證機制 考慮負載平衡策略 裝置上部署 考慮記憶體與運算資源限制 進行模型優化 權重修剪(weight pruning)移除不重要的連接 權重量化(weight quantization)降低數值精度 整合至原生應用程式 瀏覽器部署 使用 TensorFlow.js 等前端架構 優化模型大小與載入時間 處理跨瀏覽器相容性 監控模型運作\n實施 A/B 測試 比較不同版本模型的表現 收集使用者行為數據 評估新功能的效果 收集使用者回饋 建立回饋機制 分析錯誤案例 持續改善模型表現 監控模型效能 追蹤關鍵指標變化 設定警示機制 分析效能瓶頸 維護模型\n關注新特徵 評估新資料源的價值 驗證特徵的穩定性 更新特徵工程流程 處理概念漂移 定期重新訓練模型 監控資料分布變化 更新評估指標 版本管理 維護模型版本紀錄 建立回滾機制 文件化更新流程 ","wordCount":"187","inLanguage":"zh-tw","datePublished":"2025-01-12T17:54:31+08:00","dateModified":"2025-01-12T17:54:31+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/ai/5_5/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a></div><h1 class="post-title entry-hint-parent">[AI] 機器學習的流程</h1><div class=post-description>The flow of machine learning</div><div class=post-meta><span title='2025-01-12 17:54:31 +0800 +0800'>January 12, 2025</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//AI/5_5.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e6%a9%9f%e5%99%a8%e5%ad%b8%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b aria-label=機器學器的工作流程>機器學器的工作流程</a><ul><li><a href=#%e5%ae%9a%e7%be%a9%e4%bb%bb%e5%8b%99 aria-label=定義任務>定義任務</a></li><li><a href=#%e9%96%8b%e7%99%bc%e6%a8%a1%e5%9e%8b aria-label=開發模型>開發模型</a></li><li><a href=#%e9%83%a8%e7%bd%b2%e6%a8%a1%e5%9e%8b aria-label=部署模型>部署模型</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=機器學器的工作流程>機器學器的工作流程<a hidden class=anchor aria-hidden=true href=#機器學器的工作流程>#</a></h1><ul><li>一般而言，機器學習的通用工作流程可以歸納為三個部分:<ol><li>定義任務(Define the task): 瞭解需求背後的問題領域與業務邏輯、收集資料、瞭解資料內容，並選擇衡量任務成功的標準。</li><li>開發模型(Develop a model): 準備好模型可以處理的資料、定義基準線、先訓練出一個能 overfitting 的模型，最後進行常規化、調整模型以提高普適化表現。</li><li>部署模型(Deploy a model): 將模型部署至伺服器、app、網頁或嵌入式裝置，並監控模型表現。</li></ol></li></ul><h2 id=定義任務>定義任務<a hidden class=anchor aria-hidden=true href=#定義任務>#</a></h2><ul><li><p>問題域</p><ul><li>輸入資料: 我們需要知道輸入資料是什麼</li><li>目標: 我們要知道想要預測什麼</li></ul></li><li><p>任務類型</p><ul><li>我們要定義我的的任務是哪種類型:<ul><li>二元分類任務</li><li>多類別分類任務</li><li>純量迴歸</li><li>向量迴歸</li><li>多類別且多標籤任務</li><li>影像分割任務</li><li>排序任務</li><li>資料分群分任</li><li>生成任務</li><li>強式化學習任務</li><li>&mldr;</li></ul></li><li>並不一定所有的任務類型都適用機器學習，傳統的統計分析方法也許更有效。</li></ul></li><li><p>參考現有的解決方案</p><ul><li>我們必須先瞭解當前的解決方案是怎麼運作。</li></ul></li><li><p>限制條件</p><ul><li>模型是在伺服器運作嗎？或是因為端到到加密，模型需在裝置上運行，並使用外部資料訓練。</li></ul></li><li><p>資料的充足性</p><ul><li>我們想要預測的資料是否可以透過輸入來預測。<ul><li>舉例來說我們想要預測未來股價，但是我們只有該股的歷史股價，則不具備資料充足性，應該要加入如 eps 等其它表徵資料。</li></ul></li></ul></li><li><p><strong>建立資料集</strong></p></li><li><p>資料甚至比演算法還重要(The Unreasonable Effectiveness of Data)</p><ul><li>投資在資料標註工具<ul><li>自行標註</li><li>外包平台，如 Mechanical Turk</li><li>專業資料標註公司</li><li>注意：需考慮資料標註是否需要領域專家</li></ul></li><li>留意不具代表性的資料: 資料一定要足以代表實際運作的資料<ul><li>即我們的訓練資料要可以表達實際運用的場景。可以參考抽樣偏差(sampling bias)</li><li>概念漂移: 資料具有時間性，2020 年訓練出來的模型，無法描述 2025 年發生的事。</li></ul></li><li>理解資料<ul><li>先從資料中抽幾個樣本與標籤，對資料進行解讀。</li><li>對資料有些概觀性的瞭解，判斷是否缺少特徵值、瞭解資料的 pattern。</li><li>檢查是否存在目標值洩漏(target leaking) 的問題。</li></ul></li><li>選擇測量成效的方法<ul><li>考慮準確度(accuracy)、精準度(precision)、故障召回率(recall)、客戶回流率?</li><li>好的評量指標(metric) 會引導專案的所有技術選擇，盡可能要與更高層次的目標保持一致。</li><li>ROC(receiveer operating characteristic) 曲線下面積 (ROC AUC, ROC Area Under Curve)</li></ul></li></ul></li></ul><h2 id=開發模型>開發模型<a hidden class=anchor aria-hidden=true href=#開發模型>#</a></h2><ul><li><p>準備資料</p><ul><li>通常模型無法接受原始資料，需經過預處理。<ul><li>向量化(vectorization)</li><li>正規化(normalization)</li><li>處理缺失值</li></ul></li></ul></li><li><p>選擇驗證機制</p><ul><li>拆分驗證集(holdout validation set)</li><li>K-fold</li><li>Iterated K-fold</li></ul></li><li><p>超越基準線</p><ul><li>特徵工程</li><li>選擇架構</li><li>決定訓練配置
$$
\begin{array}{|c|c|c|}
\text{問題類型}&\text{輸出層激活函數}&\text{損失函數}\\\hline
\text{二元分類}&\text{sigmoid}&\text{binary crossentropy}\\
\text{多類別、單標籤分類}&\text{softmax}&\text{categorical crossentropy}\\
\text{多類別、多標籤分類}&\text{sigmoid}&\text{binary crossentropy}
\end{array}
$$</li></ul></li><li><p>擴大規模: 開發一個會 overfitting 的模型</p><ul><li>添加更多神經層</li><li>選擇更寬的神經層</li><li>訓練更多週期(epoch)</li></ul></li><li><p>將模型常規化並調整超參數</p><ul><li>嘗試不同架構</li><li>dropout</li><li>L1, L2 常規化(當模型不大)</li><li>嘗試不同超參數(ex. 優化器策略)</li><li>資料篩選、特徵工程</li></ul></li></ul><h2 id=部署模型>部署模型<a hidden class=anchor aria-hidden=true href=#部署模型>#</a></h2><ul><li><p>向客戶說明成果、建立合理期待</p><ul><li>清楚說明模型的能力與限制</li><li>提供模型在不同場景下的表現數據</li><li>說明可能的錯誤類型與處理方式</li><li>建立明確的效能指標與監控機制</li></ul></li><li><p>交付模型</p><ul><li>REST API 部署<ul><li>建立可擴展的API架構</li><li>實作請求限制與認證機制</li><li>考慮負載平衡策略</li></ul></li><li>裝置上部署<ul><li>考慮記憶體與運算資源限制</li><li>進行模型優化<ul><li>權重修剪(weight pruning)移除不重要的連接</li><li>權重量化(weight quantization)降低數值精度</li></ul></li><li>整合至原生應用程式</li></ul></li><li>瀏覽器部署<ul><li>使用 TensorFlow.js 等前端架構</li><li>優化模型大小與載入時間</li><li>處理跨瀏覽器相容性</li></ul></li></ul></li><li><p>監控模型運作</p><ul><li>實施 A/B 測試<ul><li>比較不同版本模型的表現</li><li>收集使用者行為數據</li><li>評估新功能的效果</li></ul></li><li>收集使用者回饋<ul><li>建立回饋機制</li><li>分析錯誤案例</li><li>持續改善模型表現</li></ul></li><li>監控模型效能<ul><li>追蹤關鍵指標變化</li><li>設定警示機制</li><li>分析效能瓶頸</li></ul></li></ul></li><li><p>維護模型</p><ul><li>關注新特徵<ul><li>評估新資料源的價值</li><li>驗證特徵的穩定性</li><li>更新特徵工程流程</li></ul></li><li>處理概念漂移<ul><li>定期重新訓練模型</li><li>監控資料分布變化</li><li>更新評估指標</li></ul></li><li>版本管理<ul><li>維護模型版本紀錄</li><li>建立回滾機制</li><li>文件化更新流程</li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/ai/>AI</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/ai/5_4/><span class=title>« 上一頁</span><br><span>[AI] 提高普適化能力</span>
</a><a class=next href=https://intervalrain.github.io/leetcode_list/binary_search/><span class=title>下一頁 »</span><br><span>[LeetCode] Binary Search 科學刷題</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>