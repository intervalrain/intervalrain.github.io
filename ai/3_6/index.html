<!doctype html><html lang=zh-tw dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[AI] 3-6. 實作線性分類器 | Rain Hu's Workspace</title><meta name=keywords content="AI"><meta name=description content="A implementation of linear classification using Tensorflow library"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cefe5a1d95e3d0f0cce057d37c60cd238d1a4af825090f831a18f21671f621d.css integrity="sha256-DO/lodlePQ8MzgV9N8YM0jjRpK+CUJD4MaGPIWcfYh0=" rel="preload stylesheet" as=style><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-tw href=https://intervalrain.github.io/ai/3_6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:url" content="https://intervalrain.github.io/ai/3_6/"><meta property="og:site_name" content="Rain Hu's Workspace"><meta property="og:title" content="[AI] 3-6. 實作線性分類器"><meta property="og:description" content="A implementation of linear classification using Tensorflow library"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="ai"><meta property="article:published_time" content="2024-12-19T16:55:12+08:00"><meta property="article:modified_time" content="2024-12-19T16:55:12+08:00"><meta property="article:tag" content="AI"><meta name=twitter:card content="summary"><meta name=twitter:title content="[AI] 3-6. 實作線性分類器"><meta name=twitter:description content="A implementation of linear classification using Tensorflow library"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"[AI] 3-6. 實作線性分類器","item":"https://intervalrain.github.io/ai/3_6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[AI] 3-6. 實作線性分類器","name":"[AI] 3-6. 實作線性分類器","description":"A implementation of linear classification using Tensorflow library","keywords":["AI"],"articleBody":"命題 我們先嘗試製作一個 sample data，考慮某一個台獨國內的房價與坪數的分布，標記出「城市」與「鄉下」兩個標籤：\n紫色代表城市的房子、黃色代表鄉下的房子 城市的房子房價較高且坪數較小、鄉下的房子房價較低且坪數較大。 隱藏的特徵為單位坪數的價格，城市會高於鄉下。 以下是產生的 data，seed 設為 42 import numpy as np def load_data(n1=1000,n2=300,seed=42): np.random.seed(seed) n=n1+n2 # 城市房屋 city = np.random.multivariate_normal( mean=[25.9, 1503.7], # [坪數, 總價(萬)] cov=[[33.64, 400], # 坪數標準差 5.8 [400, 64112.24]], # 總價標準差 253.2 size=n ) # 鄉村房屋 rural = np.random.multivariate_normal( mean=[31.8, 834.3], # [坪數, 總價(萬)] cov=[[62.41, 200], # 坪數標準差 7.9 [200, 9623.61]], # 總價標準差 98.1 size=n ) # 合併資料 data = np.vstack((city, rural)).astype(np.float32) labels = np.vstack((np.zeros((n,1), dtype=\"float32\"), np.ones((n,1), dtype=\"float32\"))) # 打散順序 shuffle_idx = np.random.permutation(len(data)) data = data[shuffle_idx] labels = labels[shuffle_idx] # 分割訓練集和測試集 train_data = data[:2*n1] test_data = data[2*n1:] train_labels = labels[:2*n1] test_labels = labels[2*n1:] return (train_data, train_labels), (test_data, test_labels) (train_data, train_labels), (test_data, test_labels) = load_data() 通用函式 因為 price 與 size 之間的值相差較大，所以我定義了正規化的函式、繪圖的函式、training 函式。 import numpy as np import matplotlib.pyplot as plt from sklearn.preprocessing import StandardScaler import tensorflow as tf from tensorflow.keras import layers, models, callbacks import pandas as pd # 共用參數 LEARNING_RATE = 0.01 BATCH_SIZE = 32 EPOCHS = 100 EARLY_STOPPING_PATIENCE = 10 def normalize_data(train_data, test_data): \"\"\"標準化資料\"\"\" scaler = StandardScaler() train_normalized = scaler.fit_transform(train_data) test_normalized = scaler.transform(test_data) return train_normalized, test_normalized, scaler def plot_decision_boundary(model, X, y, title, scaler=None, is_extended=False): \"\"\"繪製決策邊界 Parameters: ----------- model : 訓練好的模型 X : array-like, shape (n_samples, 2) or (n_samples, 3) 輸入特徵 y : array-like 目標變數 title : str 圖表標題 scaler : StandardScaler, optional 用於還原正規化的scaler is_extended : bool 是否為擴展特徵模型 \"\"\" if is_extended: # 對於擴展特徵模型，只使用前兩個特徵繪圖 X_plot = X[:, :2] else: X_plot = X # 設定決策邊界的範圍 x_min, x_max = X_plot[:, 0].min() - 0.5, X_plot[:, 0].max() + 0.5 y_min, y_max = X_plot[:, 1].min() - 0.5, X_plot[:, 1].max() + 0.5 # 創建網格點 xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.02), np.arange(y_min, y_max, 0.02)) # 預測網格點的類別 grid_points = np.c_[xx.ravel(), yy.ravel()] if is_extended: # 為擴展特徵模型添加 price/size ratio ratio = grid_points[:, 1:2] / grid_points[:, 0:1] grid_points = np.hstack((grid_points, ratio)) Z = model.predict(grid_points) Z = Z.reshape(xx.shape) # 如果提供了scaler，將數據轉換回原始尺度 if scaler is not None: # 轉換網格點 grid_points_original = scaler.inverse_transform(grid_points[:, :2]) xx_original = grid_points_original[:, 0].reshape(xx.shape) yy_original = grid_points_original[:, 1].reshape(yy.shape) # 轉換特徵點 X_original = scaler.inverse_transform(X_plot) x_plot = X_original[:, 0] y_plot = X_original[:, 1] xlabel = 'Size' ylabel = 'Price' else: x_plot = X_plot[:, 0] y_plot = X_plot[:, 1] xx_original = xx yy_original = yy xlabel = 'Normalized Size' ylabel = 'Normalized Price' # 繪製圖形 plt.figure(figsize=(10, 8)) # 繪製預測機率的漸層 plt.contourf(xx_original, yy_original, Z, alpha=0.4, levels=np.linspace(0, 1, 11)) # 添加決策邊界（機率=0.5的等高線） plt.contour(xx_original, yy_original, Z, levels=[0.5], colors='red', linestyles='-', linewidths=2) # 繪製資料點 plt.scatter(x_plot, y_plot, c=y.ravel(), alpha=0.8) plt.title(title) plt.xlabel(xlabel) plt.ylabel(ylabel) # 添加顏色條 plt.colorbar(label='Prediction Probability') plt.show() def train_and_evaluate(model, train_data, train_labels, test_data, test_labels, epochs=EPOCHS, batch_size=BATCH_SIZE, use_early_stopping=False): \"\"\"訓練模型並評估\"\"\" callbacks_list = [] if use_early_stopping: early_stopping = callbacks.EarlyStopping( monitor='val_loss', patience=EARLY_STOPPING_PATIENCE, restore_best_weights=True ) callbacks_list.append(early_stopping) history = model.fit( train_data, train_labels, epochs=epochs, batch_size=batch_size, validation_split=0.2, callbacks=callbacks_list, verbose=0 ) test_loss, test_accuracy = model.evaluate(test_data, test_labels, verbose=0) return history, test_loss, test_accuracy 定義模型 本篇設定了不同的 model, optimizer, loss，不代表哪一種 pattern 的優劣，純粹是示範 library 使用。 由於我想看不同的 optimizer/activation/loss function的差異，所以我共用了部分參數 LEARNING_RATE = 0.01 BATCH_SIZE = 32 EPOCHS = 100 EARLY_STOPPING_PATIENCE = 10 我列了幾個不同的策略，來看看結果的差異 SGD + 線性模型 (wx+b) + MSE SGD + Sigmoid 模型 + MSE SGD + ReLU 模型 + MSE SGD + Sigmoid 模型 + BCE Adam + Sigmoid 模型 + BCE Adam + Sigmoid 模型 + BCE (加入新特徵 price/size) Adam + 雜複模型 + BCD Adam + 複雜模型 + BCD (加入新特徵 price/size) 1. SGD + 線性模型 (wx+b) + MSE # 1. 線性模型 (wx+b) def create_linear_model(): model = models.Sequential([ layers.Dense(1, input_shape=(2,), activation='linear') ]) model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=LEARNING_RATE), loss='mse', metrics=['accuracy']) return model 2. SGD + Sigmoid + MSE # 2. Sigmoid模型 def create_sigmoid_model(): model = models.Sequential([ layers.Dense(1, input_shape=(2,), activation='sigmoid') ]) model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=LEARNING_RATE), loss='mse', metrics=['accuracy']) return model 3. SGD + ReLU + MSE # 3. ReLU模型 + MSE def create_relu_mse_model(): model = models.Sequential([ layers.Dense(1, input_shape=(2,), activation='relu') ]) model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=LEARNING_RATE), loss='mse', metrics=['accuracy']) return model 4. SGD + ReLU + BCE # 4. ReLU模型 + BCE def create_relu_bce_model(): model = models.Sequential([ layers.Dense(1, input_shape=(2,), activation='relu') ]) model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=LEARNING_RATE), loss='binary_crossentropy', metrics=['accuracy']) return model 5. Adam + Sigmoid + BCE # 5. Adam + BCE def create_adam_model(): model = models.Sequential([ layers.Dense(1, input_shape=(2,), activation='sigmoid') ]) model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy']) return model 6. Adam + Sigmoid + BCE (加入新特徵) # 6. 新增 price/size feature 的模型 def add_price_size_ratio(data): price_size_ratio = data[:, 1:2] / data[:, 0:1] return np.hstack((data, price_size_ratio)) def create_extended_model(): model = models.Sequential([ layers.Dense(1, input_shape=(3,), activation='sigmoid') ]) model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy']) return model 7. Adam + 複雜模型 + Dropout + Early Stop # 7. 複雜模型 + Dropout def create_complex_model(input_shape): model = models.Sequential([ layers.Dense(64, input_shape=input_shape, activation='relu'), layers.Dropout(0.3), layers.Dense(32, activation='relu'), layers.Dropout(0.2), layers.Dense(16, activation='relu'), layers.Dense(1, activation='sigmoid') ]) model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy']) return model 8. Adam + 複雜模型 + Dropout + Early Stop (加入新特徵) 執行 def main(): # 載入資料 (train_data, train_labels), (test_data, test_labels) = load_data() # 標準化資料 train_normalized, test_normalized, scaler = normalize_data(train_data, test_data) # 儲存結果的列表 results = [] # 1. 線性模型 model1 = create_linear_model() history1, test_loss1, test_acc1 = train_and_evaluate( model1, train_normalized, train_labels, test_normalized, test_labels) plot_decision_boundary(model1, train_normalized, train_labels, 'Linear Model (wx+b)', scaler) results.append(('Linear Model', test_acc1)) # 2. Sigmoid模型 model2 = create_sigmoid_model() history2, test_loss2, test_acc2 = train_and_evaluate( model2, train_normalized, train_labels, test_normalized, test_labels) plot_decision_boundary(model2, train_normalized, train_labels, 'Sigmoid Model', scaler) results.append(('Sigmoid Model', test_acc2)) # 3. ReLU + MSE model3 = create_relu_mse_model() history3, test_loss3, test_acc3 = train_and_evaluate( model3, train_normalized, train_labels, test_normalized, test_labels) plot_decision_boundary(model3, train_normalized, train_labels, 'ReLU + MSE', scaler) results.append(('ReLU + MSE', test_acc3)) # 4. ReLU + BCE model4 = create_relu_bce_model() history4, test_loss4, test_acc4 = train_and_evaluate( model4, train_normalized, train_labels, test_normalized, test_labels) plot_decision_boundary(model4, train_normalized, train_labels, 'ReLU + BCE', scaler) results.append(('ReLU + BCE', test_acc4)) # 5. Adam + BCE model5 = create_adam_model() history5, test_loss5, test_acc5 = train_and_evaluate( model5, train_normalized, train_labels, test_normalized, test_labels) plot_decision_boundary(model5, train_normalized, train_labels, 'Adam + BCE', scaler) results.append(('Adam + BCE', test_acc5)) # 6. 加入 price/size ratio train_extended = add_price_size_ratio(train_normalized) test_extended = add_price_size_ratio(test_normalized) model6 = create_extended_model() history6, test_loss6, test_acc6 = train_and_evaluate( model6, train_extended, train_labels, test_extended, test_labels) plot_decision_boundary(model6, train_normalized, train_labels, 'Extended Model', scaler, is_extended=True) results.append(('Extended Features', test_acc6)) # 7. 複雜模型 + Dropout + Early Stopping model7 = create_complex_model((2,)) history7, test_loss7, test_acc7 = train_and_evaluate( model7, train_normalized, train_labels, test_normalized, test_labels, use_early_stopping=True) plot_decision_boundary(model7, train_normalized, train_labels, 'Complex Model + Dropout', scaler) results.append(('Complex Model', test_acc7)) # 8. 複雜模型 + new feature model8 = create_complex_model((3,)) history8, test_loss8, test_acc8 = train_and_evaluate( model8, train_extended, train_labels, test_extended, test_labels, use_early_stopping=True) plot_decision_boundary(model8, train_extended, train_labels, 'Extended Complex Model + Dropout', scaler, is_extended=True) results.append(('Extended Features Complex Model', test_acc8)) # 顯示結果比較 results_df = pd.DataFrame(results, columns=['Model', 'Test Accuracy']) print(\"\\nModel Comparison:\") print(results_df.to_string(index=False)) if __name__ == \"__main__\": main() 結果比較 Model Comparison: Model Test Accuracy Linear Model 0.968333 Sigmoid Model 0.975000 ReLU + MSE 0.985000 ReLU + BCE 0.985000 Adam + BCE 0.976667 Extended Features 0.973333 Complex Model 0.986667 Extended Features Complex Model 0.981667 其中紅色的線是我們得出的決策邊界，如果在高維空間，則會是一個「超平面」。 ","wordCount":"1034","inLanguage":"zh-tw","datePublished":"2024-12-19T16:55:12+08:00","dateModified":"2024-12-19T16:55:12+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://intervalrain.github.io/ai/3_6/"},"publisher":{"@type":"Organization","name":"Rain Hu's Workspace","logo":{"@type":"ImageObject","url":"https://intervalrain.github.io/images/rain.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt aria-label=logo height=35>Rain Hu's Workspace</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li><li><a href=https://intervalrain.github.io/ai title=AI><span>AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>首頁</a></div><h1 class="post-title entry-hint-parent">[AI] 3-6. 實作線性分類器</h1><div class=post-description>A implementation of linear classification using Tensorflow library</div><div class=post-meta><span title='2024-12-19 16:55:12 +0800 +0800'>December 19, 2024</span>&nbsp;·&nbsp;5 分鐘&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//AI/3_6.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e5%91%bd%e9%a1%8c aria-label=命題>命題</a></li><li><a href=#%e9%80%9a%e7%94%a8%e5%87%bd%e5%bc%8f aria-label=通用函式>通用函式</a></li><li><a href=#%e5%ae%9a%e7%be%a9%e6%a8%a1%e5%9e%8b aria-label=定義模型>定義模型</a><ul><li><a href=#1-sgd--%e7%b7%9a%e6%80%a7%e6%a8%a1%e5%9e%8b-wxb--mse aria-label="1. SGD + 線性模型 (wx+b) + MSE">1. SGD + 線性模型 (wx+b) + MSE</a></li><li><a href=#2-sgd--sigmoid--mse aria-label="2. SGD + Sigmoid + MSE">2. SGD + Sigmoid + MSE</a></li><li><a href=#3-sgd--relu--mse aria-label="3. SGD + ReLU + MSE">3. SGD + ReLU + MSE</a></li><li><a href=#4-sgd--relu--bce aria-label="4. SGD + ReLU + BCE">4. SGD + ReLU + BCE</a></li><li><a href=#5-adam--sigmoid--bce aria-label="5. Adam + Sigmoid + BCE">5. Adam + Sigmoid + BCE</a></li><li><a href=#6-adam--sigmoid--bce-%e5%8a%a0%e5%85%a5%e6%96%b0%e7%89%b9%e5%be%b5 aria-label="6. Adam + Sigmoid + BCE (加入新特徵)">6. Adam + Sigmoid + BCE (加入新特徵)</a></li><li><a href=#7-adam--%e8%a4%87%e9%9b%9c%e6%a8%a1%e5%9e%8b--dropout--early-stop aria-label="7. Adam + 複雜模型 + Dropout + Early Stop">7. Adam + 複雜模型 + Dropout + Early Stop</a></li><li><a href=#8-adam--%e8%a4%87%e9%9b%9c%e6%a8%a1%e5%9e%8b--dropout--early-stop-%e5%8a%a0%e5%85%a5%e6%96%b0%e7%89%b9%e5%be%b5 aria-label="8. Adam + 複雜模型 + Dropout + Early Stop (加入新特徵)">8. Adam + 複雜模型 + Dropout + Early Stop (加入新特徵)</a></li></ul></li><li><a href=#%e5%9f%b7%e8%a1%8c aria-label=執行>執行</a></li><li><a href=#%e7%b5%90%e6%9e%9c%e6%af%94%e8%bc%83 aria-label=結果比較>結果比較</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=命題>命題<a hidden class=anchor aria-hidden=true href=#命題>#</a></h2><p>我們先嘗試製作一個 sample data，考慮某一個台獨國內的房價與坪數的分布，標記出「城市」與「鄉下」兩個標籤：</p><ul><li>紫色代表城市的房子、黃色代表鄉下的房子</li><li>城市的房子房價較高且坪數較小、鄉下的房子房價較低且坪數較大。</li><li>隱藏的特徵為單位坪數的價格，城市會高於鄉下。
<img alt=ori loading=lazy src=/ai/AI/3_6/ori.png></li><li>以下是產生的 data，<code>seed</code> 設為 <code>42</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>load_data</span>(n1<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span>,n2<span style=color:#f92672>=</span><span style=color:#ae81ff>300</span>,seed<span style=color:#f92672>=</span><span style=color:#ae81ff>42</span>):
</span></span><span style=display:flex><span>  np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>seed(seed)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  n<span style=color:#f92672>=</span>n1<span style=color:#f92672>+</span>n2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 城市房屋</span>
</span></span><span style=display:flex><span>  city <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>multivariate_normal(
</span></span><span style=display:flex><span>    mean<span style=color:#f92672>=</span>[<span style=color:#ae81ff>25.9</span>, <span style=color:#ae81ff>1503.7</span>],    <span style=color:#75715e># [坪數, 總價(萬)]</span>
</span></span><span style=display:flex><span>    cov<span style=color:#f92672>=</span>[[<span style=color:#ae81ff>33.64</span>, <span style=color:#ae81ff>400</span>],      <span style=color:#75715e># 坪數標準差 5.8</span>
</span></span><span style=display:flex><span>         [<span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>64112.24</span>]],  <span style=color:#75715e># 總價標準差 253.2</span>
</span></span><span style=display:flex><span>    size<span style=color:#f92672>=</span>n
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 鄉村房屋</span>
</span></span><span style=display:flex><span>  rural <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>multivariate_normal(
</span></span><span style=display:flex><span>    mean<span style=color:#f92672>=</span>[<span style=color:#ae81ff>31.8</span>, <span style=color:#ae81ff>834.3</span>],     <span style=color:#75715e># [坪數, 總價(萬)]</span>
</span></span><span style=display:flex><span>    cov<span style=color:#f92672>=</span>[[<span style=color:#ae81ff>62.41</span>, <span style=color:#ae81ff>200</span>],      <span style=color:#75715e># 坪數標準差 7.9</span>
</span></span><span style=display:flex><span>         [<span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>9623.61</span>]],   <span style=color:#75715e># 總價標準差 98.1</span>
</span></span><span style=display:flex><span>    size<span style=color:#f92672>=</span>n
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 合併資料</span>
</span></span><span style=display:flex><span>  data <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>vstack((city, rural))<span style=color:#f92672>.</span>astype(np<span style=color:#f92672>.</span>float32)
</span></span><span style=display:flex><span>  labels <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>vstack((np<span style=color:#f92672>.</span>zeros((n,<span style=color:#ae81ff>1</span>), dtype<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;float32&#34;</span>),
</span></span><span style=display:flex><span>                      np<span style=color:#f92672>.</span>ones((n,<span style=color:#ae81ff>1</span>), dtype<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;float32&#34;</span>)))
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e># 打散順序</span>
</span></span><span style=display:flex><span>  shuffle_idx <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>permutation(len(data))
</span></span><span style=display:flex><span>  data <span style=color:#f92672>=</span> data[shuffle_idx]
</span></span><span style=display:flex><span>  labels <span style=color:#f92672>=</span> labels[shuffle_idx]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 分割訓練集和測試集</span>
</span></span><span style=display:flex><span>  train_data <span style=color:#f92672>=</span> data[:<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>n1]
</span></span><span style=display:flex><span>  test_data <span style=color:#f92672>=</span> data[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>n1:]
</span></span><span style=display:flex><span>  train_labels <span style=color:#f92672>=</span> labels[:<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>n1]
</span></span><span style=display:flex><span>  test_labels <span style=color:#f92672>=</span> labels[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>n1:]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (train_data, train_labels), (test_data, test_labels)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(train_data, train_labels), (test_data, test_labels) <span style=color:#f92672>=</span> load_data()
</span></span></code></pre></div><h2 id=通用函式>通用函式<a hidden class=anchor aria-hidden=true href=#通用函式>#</a></h2><ul><li>因為 price 與 size 之間的值相差較大，所以我定義了正規化的函式、繪圖的函式、training 函式。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> sklearn.preprocessing <span style=color:#f92672>import</span> StandardScaler
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> tensorflow <span style=color:#66d9ef>as</span> tf
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> tensorflow.keras <span style=color:#f92672>import</span> layers, models, callbacks
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 共用參數</span>
</span></span><span style=display:flex><span>LEARNING_RATE <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>
</span></span><span style=display:flex><span>BATCH_SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>EPOCHS <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>EARLY_STOPPING_PATIENCE <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>normalize_data</span>(train_data, test_data):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;標準化資料&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    scaler <span style=color:#f92672>=</span> StandardScaler()
</span></span><span style=display:flex><span>    train_normalized <span style=color:#f92672>=</span> scaler<span style=color:#f92672>.</span>fit_transform(train_data)
</span></span><span style=display:flex><span>    test_normalized <span style=color:#f92672>=</span> scaler<span style=color:#f92672>.</span>transform(test_data)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> train_normalized, test_normalized, scaler
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>plot_decision_boundary</span>(model, X, y, title, scaler<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, is_extended<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;繪製決策邊界
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Parameters:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    -----------
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    model : 訓練好的模型
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    X : array-like, shape (n_samples, 2) or (n_samples, 3)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        輸入特徵
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    y : array-like
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        目標變數
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    title : str
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        圖表標題
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    scaler : StandardScaler, optional
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        用於還原正規化的scaler
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    is_extended : bool
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        是否為擴展特徵模型
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_extended:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 對於擴展特徵模型，只使用前兩個特徵繪圖</span>
</span></span><span style=display:flex><span>        X_plot <span style=color:#f92672>=</span> X[:, :<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        X_plot <span style=color:#f92672>=</span> X
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 設定決策邊界的範圍</span>
</span></span><span style=display:flex><span>    x_min, x_max <span style=color:#f92672>=</span> X_plot[:, <span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>min() <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span>, X_plot[:, <span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>max() <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>    y_min, y_max <span style=color:#f92672>=</span> X_plot[:, <span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>min() <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.5</span>, X_plot[:, <span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>max() <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 創建網格點</span>
</span></span><span style=display:flex><span>    xx, yy <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>meshgrid(np<span style=color:#f92672>.</span>arange(x_min, x_max, <span style=color:#ae81ff>0.02</span>),
</span></span><span style=display:flex><span>                        np<span style=color:#f92672>.</span>arange(y_min, y_max, <span style=color:#ae81ff>0.02</span>))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 預測網格點的類別</span>
</span></span><span style=display:flex><span>    grid_points <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>c_[xx<span style=color:#f92672>.</span>ravel(), yy<span style=color:#f92672>.</span>ravel()]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_extended:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 為擴展特徵模型添加 price/size ratio</span>
</span></span><span style=display:flex><span>        ratio <span style=color:#f92672>=</span> grid_points[:, <span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>2</span>] <span style=color:#f92672>/</span> grid_points[:, <span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        grid_points <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>hstack((grid_points, ratio))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Z <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>predict(grid_points)
</span></span><span style=display:flex><span>    Z <span style=color:#f92672>=</span> Z<span style=color:#f92672>.</span>reshape(xx<span style=color:#f92672>.</span>shape)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 如果提供了scaler，將數據轉換回原始尺度</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> scaler <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 轉換網格點</span>
</span></span><span style=display:flex><span>        grid_points_original <span style=color:#f92672>=</span> scaler<span style=color:#f92672>.</span>inverse_transform(grid_points[:, :<span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span>        xx_original <span style=color:#f92672>=</span> grid_points_original[:, <span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>reshape(xx<span style=color:#f92672>.</span>shape)
</span></span><span style=display:flex><span>        yy_original <span style=color:#f92672>=</span> grid_points_original[:, <span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>reshape(yy<span style=color:#f92672>.</span>shape)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># 轉換特徵點</span>
</span></span><span style=display:flex><span>        X_original <span style=color:#f92672>=</span> scaler<span style=color:#f92672>.</span>inverse_transform(X_plot)
</span></span><span style=display:flex><span>        x_plot <span style=color:#f92672>=</span> X_original[:, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        y_plot <span style=color:#f92672>=</span> X_original[:, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        xlabel <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Size&#39;</span>
</span></span><span style=display:flex><span>        ylabel <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Price&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        x_plot <span style=color:#f92672>=</span> X_plot[:, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        y_plot <span style=color:#f92672>=</span> X_plot[:, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        xx_original <span style=color:#f92672>=</span> xx
</span></span><span style=display:flex><span>        yy_original <span style=color:#f92672>=</span> yy
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        xlabel <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Normalized Size&#39;</span>
</span></span><span style=display:flex><span>        ylabel <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Normalized Price&#39;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 繪製圖形</span>
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>8</span>))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 繪製預測機率的漸層</span>
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>contourf(xx_original, yy_original, Z, alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>0.4</span>, levels<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>linspace(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>11</span>))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 添加決策邊界（機率=0.5的等高線）</span>
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>contour(xx_original, yy_original, Z, levels<span style=color:#f92672>=</span>[<span style=color:#ae81ff>0.5</span>], 
</span></span><span style=display:flex><span>               colors<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;red&#39;</span>, linestyles<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;-&#39;</span>, linewidths<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 繪製資料點</span>
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>scatter(x_plot, y_plot, c<span style=color:#f92672>=</span>y<span style=color:#f92672>.</span>ravel(), alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>0.8</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>title(title)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>xlabel(xlabel)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>ylabel(ylabel)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 添加顏色條</span>
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>colorbar(label<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Prediction Probability&#39;</span>)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>show()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>train_and_evaluate</span>(model, train_data, train_labels, test_data, test_labels, 
</span></span><span style=display:flex><span>                      epochs<span style=color:#f92672>=</span>EPOCHS, batch_size<span style=color:#f92672>=</span>BATCH_SIZE, use_early_stopping<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;訓練模型並評估&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    callbacks_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> use_early_stopping:
</span></span><span style=display:flex><span>        early_stopping <span style=color:#f92672>=</span> callbacks<span style=color:#f92672>.</span>EarlyStopping(
</span></span><span style=display:flex><span>            monitor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;val_loss&#39;</span>,
</span></span><span style=display:flex><span>            patience<span style=color:#f92672>=</span>EARLY_STOPPING_PATIENCE,
</span></span><span style=display:flex><span>            restore_best_weights<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        callbacks_list<span style=color:#f92672>.</span>append(early_stopping)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    history <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>fit(
</span></span><span style=display:flex><span>        train_data, train_labels,
</span></span><span style=display:flex><span>        epochs<span style=color:#f92672>=</span>epochs,
</span></span><span style=display:flex><span>        batch_size<span style=color:#f92672>=</span>batch_size,
</span></span><span style=display:flex><span>        validation_split<span style=color:#f92672>=</span><span style=color:#ae81ff>0.2</span>,
</span></span><span style=display:flex><span>        callbacks<span style=color:#f92672>=</span>callbacks_list,
</span></span><span style=display:flex><span>        verbose<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    test_loss, test_accuracy <span style=color:#f92672>=</span> model<span style=color:#f92672>.</span>evaluate(test_data, test_labels, verbose<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> history, test_loss, test_accuracy
</span></span></code></pre></div><h2 id=定義模型>定義模型<a hidden class=anchor aria-hidden=true href=#定義模型>#</a></h2><ul><li>本篇設定了不同的 model, optimizer, loss，不代表哪一種 pattern 的優劣，純粹是示範 library 使用。</li><li>由於我想看不同的 optimizer/activation/loss function的差異，所以我共用了部分參數<ul><li><code>LEARNING_RATE = 0.01</code></li><li><code>BATCH_SIZE = 32</code></li><li><code>EPOCHS = 100</code></li><li><code>EARLY_STOPPING_PATIENCE = 10</code></li></ul></li><li>我列了幾個不同的策略，來看看結果的差異<ol><li>SGD + 線性模型 (wx+b) + MSE</li><li>SGD + Sigmoid 模型 + MSE</li><li>SGD + ReLU 模型 + MSE</li><li>SGD + Sigmoid 模型 + BCE</li><li>Adam + Sigmoid 模型 + BCE</li><li>Adam + Sigmoid 模型 + BCE (加入新特徵 price/size)</li><li>Adam + 雜複模型 + BCD</li><li>Adam + 複雜模型 + BCD (加入新特徵 price/size)</li></ol></li></ul><h3 id=1-sgd--線性模型-wxb--mse>1. SGD + 線性模型 (wx+b) + MSE<a hidden class=anchor aria-hidden=true href=#1-sgd--線性模型-wxb--mse>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 1. 線性模型 (wx+b)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_linear_model</span>():
</span></span><span style=display:flex><span>    model <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>1</span>, input_shape<span style=color:#f92672>=</span>(<span style=color:#ae81ff>2</span>,), activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;linear&#39;</span>)
</span></span><span style=display:flex><span>    ])
</span></span><span style=display:flex><span>    model<span style=color:#f92672>.</span>compile(optimizer<span style=color:#f92672>=</span>tf<span style=color:#f92672>.</span>keras<span style=color:#f92672>.</span>optimizers<span style=color:#f92672>.</span>SGD(learning_rate<span style=color:#f92672>=</span>LEARNING_RATE),
</span></span><span style=display:flex><span>                 loss<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mse&#39;</span>,
</span></span><span style=display:flex><span>                 metrics<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> model
</span></span></code></pre></div><p><img alt=test1 loading=lazy src=/ai/AI/3_6/test1.png></p><h3 id=2-sgd--sigmoid--mse>2. SGD + Sigmoid + MSE<a hidden class=anchor aria-hidden=true href=#2-sgd--sigmoid--mse>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 2. Sigmoid模型</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_sigmoid_model</span>():
</span></span><span style=display:flex><span>    model <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>1</span>, input_shape<span style=color:#f92672>=</span>(<span style=color:#ae81ff>2</span>,), activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;sigmoid&#39;</span>)
</span></span><span style=display:flex><span>    ])
</span></span><span style=display:flex><span>    model<span style=color:#f92672>.</span>compile(optimizer<span style=color:#f92672>=</span>tf<span style=color:#f92672>.</span>keras<span style=color:#f92672>.</span>optimizers<span style=color:#f92672>.</span>SGD(learning_rate<span style=color:#f92672>=</span>LEARNING_RATE),
</span></span><span style=display:flex><span>                 loss<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mse&#39;</span>,
</span></span><span style=display:flex><span>                 metrics<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> model
</span></span></code></pre></div><p><img alt=test1 loading=lazy src=/ai/AI/3_6/test2.png></p><h3 id=3-sgd--relu--mse>3. SGD + ReLU + MSE<a hidden class=anchor aria-hidden=true href=#3-sgd--relu--mse>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 3. ReLU模型 + MSE</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_relu_mse_model</span>():
</span></span><span style=display:flex><span>    model <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>1</span>, input_shape<span style=color:#f92672>=</span>(<span style=color:#ae81ff>2</span>,), activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;relu&#39;</span>)
</span></span><span style=display:flex><span>    ])
</span></span><span style=display:flex><span>    model<span style=color:#f92672>.</span>compile(optimizer<span style=color:#f92672>=</span>tf<span style=color:#f92672>.</span>keras<span style=color:#f92672>.</span>optimizers<span style=color:#f92672>.</span>SGD(learning_rate<span style=color:#f92672>=</span>LEARNING_RATE),
</span></span><span style=display:flex><span>                 loss<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mse&#39;</span>,
</span></span><span style=display:flex><span>                 metrics<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> model
</span></span></code></pre></div><p><img alt=test1 loading=lazy src=/ai/AI/3_6/test3.png></p><h3 id=4-sgd--relu--bce>4. SGD + ReLU + BCE<a hidden class=anchor aria-hidden=true href=#4-sgd--relu--bce>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 4. ReLU模型 + BCE</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_relu_bce_model</span>():
</span></span><span style=display:flex><span>    model <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>1</span>, input_shape<span style=color:#f92672>=</span>(<span style=color:#ae81ff>2</span>,), activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;relu&#39;</span>)
</span></span><span style=display:flex><span>    ])
</span></span><span style=display:flex><span>    model<span style=color:#f92672>.</span>compile(optimizer<span style=color:#f92672>=</span>tf<span style=color:#f92672>.</span>keras<span style=color:#f92672>.</span>optimizers<span style=color:#f92672>.</span>SGD(learning_rate<span style=color:#f92672>=</span>LEARNING_RATE),
</span></span><span style=display:flex><span>                 loss<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;binary_crossentropy&#39;</span>,
</span></span><span style=display:flex><span>                 metrics<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> model
</span></span></code></pre></div><p><img alt=test1 loading=lazy src=/ai/AI/3_6/test4.png></p><h3 id=5-adam--sigmoid--bce>5. Adam + Sigmoid + BCE<a hidden class=anchor aria-hidden=true href=#5-adam--sigmoid--bce>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 5. Adam + BCE</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_adam_model</span>():
</span></span><span style=display:flex><span>    model <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>1</span>, input_shape<span style=color:#f92672>=</span>(<span style=color:#ae81ff>2</span>,), activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;sigmoid&#39;</span>)
</span></span><span style=display:flex><span>    ])
</span></span><span style=display:flex><span>    model<span style=color:#f92672>.</span>compile(optimizer<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;adam&#39;</span>,
</span></span><span style=display:flex><span>                 loss<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;binary_crossentropy&#39;</span>,
</span></span><span style=display:flex><span>                 metrics<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> model
</span></span></code></pre></div><p><img alt=test1 loading=lazy src=/ai/AI/3_6/test5.png></p><h3 id=6-adam--sigmoid--bce-加入新特徵>6. Adam + Sigmoid + BCE (加入新特徵)<a hidden class=anchor aria-hidden=true href=#6-adam--sigmoid--bce-加入新特徵>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 6. 新增 price/size feature 的模型</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_price_size_ratio</span>(data):
</span></span><span style=display:flex><span>    price_size_ratio <span style=color:#f92672>=</span> data[:, <span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>2</span>] <span style=color:#f92672>/</span> data[:, <span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> np<span style=color:#f92672>.</span>hstack((data, price_size_ratio))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_extended_model</span>():
</span></span><span style=display:flex><span>    model <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>1</span>, input_shape<span style=color:#f92672>=</span>(<span style=color:#ae81ff>3</span>,), activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;sigmoid&#39;</span>)
</span></span><span style=display:flex><span>    ])
</span></span><span style=display:flex><span>    model<span style=color:#f92672>.</span>compile(optimizer<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;adam&#39;</span>,
</span></span><span style=display:flex><span>                 loss<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;binary_crossentropy&#39;</span>,
</span></span><span style=display:flex><span>                 metrics<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> model
</span></span></code></pre></div><p><img alt=test1 loading=lazy src=/ai/AI/3_6/test6.png></p><h3 id=7-adam--複雜模型--dropout--early-stop>7. Adam + 複雜模型 + Dropout + Early Stop<a hidden class=anchor aria-hidden=true href=#7-adam--複雜模型--dropout--early-stop>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 7. 複雜模型 + Dropout</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_complex_model</span>(input_shape):
</span></span><span style=display:flex><span>    model <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>Sequential([
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>64</span>, input_shape<span style=color:#f92672>=</span>input_shape, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;relu&#39;</span>),
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dropout(<span style=color:#ae81ff>0.3</span>),
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>32</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;relu&#39;</span>),
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dropout(<span style=color:#ae81ff>0.2</span>),
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>16</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;relu&#39;</span>),
</span></span><span style=display:flex><span>        layers<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>1</span>, activation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;sigmoid&#39;</span>)
</span></span><span style=display:flex><span>    ])
</span></span><span style=display:flex><span>    model<span style=color:#f92672>.</span>compile(optimizer<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;adam&#39;</span>,
</span></span><span style=display:flex><span>                 loss<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;binary_crossentropy&#39;</span>,
</span></span><span style=display:flex><span>                 metrics<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> model
</span></span></code></pre></div><p><img alt=test1 loading=lazy src=/ai/AI/3_6/test7.png></p><h3 id=8-adam--複雜模型--dropout--early-stop-加入新特徵>8. Adam + 複雜模型 + Dropout + Early Stop (加入新特徵)<a hidden class=anchor aria-hidden=true href=#8-adam--複雜模型--dropout--early-stop-加入新特徵>#</a></h3><p><img alt=test1 loading=lazy src=/ai/AI/3_6/test8.png></p><h2 id=執行>執行<a hidden class=anchor aria-hidden=true href=#執行>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># 載入資料</span>
</span></span><span style=display:flex><span>    (train_data, train_labels), (test_data, test_labels) <span style=color:#f92672>=</span> load_data()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 標準化資料</span>
</span></span><span style=display:flex><span>    train_normalized, test_normalized, scaler <span style=color:#f92672>=</span> normalize_data(train_data, test_data)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 儲存結果的列表</span>
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 1. 線性模型</span>
</span></span><span style=display:flex><span>    model1 <span style=color:#f92672>=</span> create_linear_model()
</span></span><span style=display:flex><span>    history1, test_loss1, test_acc1 <span style=color:#f92672>=</span> train_and_evaluate(
</span></span><span style=display:flex><span>        model1, train_normalized, train_labels, test_normalized, test_labels)
</span></span><span style=display:flex><span>    plot_decision_boundary(model1, train_normalized, train_labels, <span style=color:#e6db74>&#39;Linear Model (wx+b)&#39;</span>, scaler)
</span></span><span style=display:flex><span>    results<span style=color:#f92672>.</span>append((<span style=color:#e6db74>&#39;Linear Model&#39;</span>, test_acc1))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 2. Sigmoid模型</span>
</span></span><span style=display:flex><span>    model2 <span style=color:#f92672>=</span> create_sigmoid_model()
</span></span><span style=display:flex><span>    history2, test_loss2, test_acc2 <span style=color:#f92672>=</span> train_and_evaluate(
</span></span><span style=display:flex><span>        model2, train_normalized, train_labels, test_normalized, test_labels)
</span></span><span style=display:flex><span>    plot_decision_boundary(model2, train_normalized, train_labels, <span style=color:#e6db74>&#39;Sigmoid Model&#39;</span>, scaler)
</span></span><span style=display:flex><span>    results<span style=color:#f92672>.</span>append((<span style=color:#e6db74>&#39;Sigmoid Model&#39;</span>, test_acc2))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 3. ReLU + MSE</span>
</span></span><span style=display:flex><span>    model3 <span style=color:#f92672>=</span> create_relu_mse_model()
</span></span><span style=display:flex><span>    history3, test_loss3, test_acc3 <span style=color:#f92672>=</span> train_and_evaluate(
</span></span><span style=display:flex><span>        model3, train_normalized, train_labels, test_normalized, test_labels)
</span></span><span style=display:flex><span>    plot_decision_boundary(model3, train_normalized, train_labels, <span style=color:#e6db74>&#39;ReLU + MSE&#39;</span>, scaler)
</span></span><span style=display:flex><span>    results<span style=color:#f92672>.</span>append((<span style=color:#e6db74>&#39;ReLU + MSE&#39;</span>, test_acc3))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 4. ReLU + BCE</span>
</span></span><span style=display:flex><span>    model4 <span style=color:#f92672>=</span> create_relu_bce_model()
</span></span><span style=display:flex><span>    history4, test_loss4, test_acc4 <span style=color:#f92672>=</span> train_and_evaluate(
</span></span><span style=display:flex><span>        model4, train_normalized, train_labels, test_normalized, test_labels)
</span></span><span style=display:flex><span>    plot_decision_boundary(model4, train_normalized, train_labels, <span style=color:#e6db74>&#39;ReLU + BCE&#39;</span>, scaler)
</span></span><span style=display:flex><span>    results<span style=color:#f92672>.</span>append((<span style=color:#e6db74>&#39;ReLU + BCE&#39;</span>, test_acc4))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 5. Adam + BCE</span>
</span></span><span style=display:flex><span>    model5 <span style=color:#f92672>=</span> create_adam_model()
</span></span><span style=display:flex><span>    history5, test_loss5, test_acc5 <span style=color:#f92672>=</span> train_and_evaluate(
</span></span><span style=display:flex><span>        model5, train_normalized, train_labels, test_normalized, test_labels)
</span></span><span style=display:flex><span>    plot_decision_boundary(model5, train_normalized, train_labels, <span style=color:#e6db74>&#39;Adam + BCE&#39;</span>, scaler)
</span></span><span style=display:flex><span>    results<span style=color:#f92672>.</span>append((<span style=color:#e6db74>&#39;Adam + BCE&#39;</span>, test_acc5))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 6. 加入 price/size ratio</span>
</span></span><span style=display:flex><span>    train_extended <span style=color:#f92672>=</span> add_price_size_ratio(train_normalized)
</span></span><span style=display:flex><span>    test_extended <span style=color:#f92672>=</span> add_price_size_ratio(test_normalized)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    model6 <span style=color:#f92672>=</span> create_extended_model()
</span></span><span style=display:flex><span>    history6, test_loss6, test_acc6 <span style=color:#f92672>=</span> train_and_evaluate(
</span></span><span style=display:flex><span>        model6, train_extended, train_labels, test_extended, test_labels)
</span></span><span style=display:flex><span>    plot_decision_boundary(model6, train_normalized, train_labels, <span style=color:#e6db74>&#39;Extended Model&#39;</span>, scaler, is_extended<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    results<span style=color:#f92672>.</span>append((<span style=color:#e6db74>&#39;Extended Features&#39;</span>, test_acc6))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 7. 複雜模型 + Dropout + Early Stopping</span>
</span></span><span style=display:flex><span>    model7 <span style=color:#f92672>=</span> create_complex_model((<span style=color:#ae81ff>2</span>,))
</span></span><span style=display:flex><span>    history7, test_loss7, test_acc7 <span style=color:#f92672>=</span> train_and_evaluate(
</span></span><span style=display:flex><span>        model7, train_normalized, train_labels, test_normalized, test_labels,
</span></span><span style=display:flex><span>        use_early_stopping<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    plot_decision_boundary(model7, train_normalized, train_labels, <span style=color:#e6db74>&#39;Complex Model + Dropout&#39;</span>, scaler)
</span></span><span style=display:flex><span>    results<span style=color:#f92672>.</span>append((<span style=color:#e6db74>&#39;Complex Model&#39;</span>, test_acc7))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 8. 複雜模型 + new feature</span>
</span></span><span style=display:flex><span>    model8 <span style=color:#f92672>=</span> create_complex_model((<span style=color:#ae81ff>3</span>,))
</span></span><span style=display:flex><span>    history8, test_loss8, test_acc8 <span style=color:#f92672>=</span> train_and_evaluate(
</span></span><span style=display:flex><span>        model8, train_extended, train_labels, test_extended, test_labels,
</span></span><span style=display:flex><span>        use_early_stopping<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    plot_decision_boundary(model8, train_extended, train_labels, <span style=color:#e6db74>&#39;Extended Complex Model + Dropout&#39;</span>, scaler, is_extended<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    results<span style=color:#f92672>.</span>append((<span style=color:#e6db74>&#39;Extended Features Complex Model&#39;</span>, test_acc8))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 顯示結果比較</span>
</span></span><span style=display:flex><span>    results_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(results, columns<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;Model&#39;</span>, <span style=color:#e6db74>&#39;Test Accuracy&#39;</span>])
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Model Comparison:&#34;</span>)
</span></span><span style=display:flex><span>    print(results_df<span style=color:#f92672>.</span>to_string(index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><h2 id=結果比較>結果比較<a hidden class=anchor aria-hidden=true href=#結果比較>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Model Comparison:
</span></span><span style=display:flex><span>                          Model  Test Accuracy
</span></span><span style=display:flex><span>                   Linear Model       <span style=color:#ae81ff>0.968333</span>
</span></span><span style=display:flex><span>                  Sigmoid Model       <span style=color:#ae81ff>0.975000</span>
</span></span><span style=display:flex><span>                     ReLU <span style=color:#f92672>+</span> MSE       <span style=color:#ae81ff>0.985000</span>
</span></span><span style=display:flex><span>                     ReLU <span style=color:#f92672>+</span> BCE       <span style=color:#ae81ff>0.985000</span>
</span></span><span style=display:flex><span>                     Adam <span style=color:#f92672>+</span> BCE       <span style=color:#ae81ff>0.976667</span>
</span></span><span style=display:flex><span>              Extended Features       <span style=color:#ae81ff>0.973333</span>
</span></span><span style=display:flex><span>                  Complex Model       <span style=color:#ae81ff>0.986667</span>
</span></span><span style=display:flex><span>Extended Features Complex Model       <span style=color:#ae81ff>0.981667</span>
</span></span></code></pre></div><ul><li>其中紅色的線是我們得出的決策邊界，如果在高維空間，則會是一個「超平面」。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://intervalrain.github.io/tags/ai/>AI</a></li></ul><nav class=paginav><a class=prev href=https://intervalrain.github.io/ai/3_5/><span class=title>« 上一頁</span><br><span>[AI] 3-5. 邏輯斯迴歸(logistic regression)</span>
</a><a class=next href=https://intervalrain.github.io/ai/3_7/><span class=title>下一頁 »</span><br><span>[AI] 3-7. Keras API</span></a></nav><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>